<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法 -- 二叉树(链式存储)</title>
      <link href="/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/"/>
      <url>/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树-链式存储"><a href="#二叉树-链式存储" class="headerlink" title="二叉树(链式存储)"></a>二叉树(链式存储)</h1><p>链式存储二叉树的C++语言实现，模板方式。</p><span id="more"></span><p><strong>链式存储方式的结构示意图</strong></p><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_LinkedStorage_1.png" alt="BinaryTree_LinkedStorage_1"></p><p>需要用到链式栈、链式队列头文件，可以从之前文章中获取。</p><p><a href="https://brkzh.github.io/2022/07/09/DataStructureAndAlgorithms/008.LinkedStack/">数据结构与算法 – 链式栈 </a></p><p><a href="https://brkzh.github.io/2022/07/15/DataStructureAndAlgorithms/010.LinkedQueue/">数据结构与算法 – 链式队列</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkQueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkStack.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// 二叉树的链式存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ECCHILDSIGN</span><span class="comment">// 节点标记</span></span><br><span class="line">&#123;</span><br><span class="line">    E_Root,<span class="comment">// 树根</span></span><br><span class="line">    E_ChildLeft,<span class="comment">// 左孩子</span></span><br><span class="line">    E_ChildRight<span class="comment">// 右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* leftChild;<span class="comment">// 左子节点指针</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* rightChild;<span class="comment">// 右子节点指针</span></span><br><span class="line">    <span class="comment">// BinaryTreeNode&lt;T&gt;* parent;// 父节点指针</span></span><br><span class="line">    <span class="comment">// BinaryTreeNode* leftChild, rightChild, parent;// 这样写也可以，不用&lt;T&gt; ，因为是在类内部定义的，所以可以不需要加上&lt;T&gt;也可以</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为实现二叉树的非递归后序遍历引入的新模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode_extra</span></span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* point;</span><br><span class="line">    ECCHILDSIGN pointSign;<span class="comment">// 节点标记，标记该节点是 左孩子、右孩子、根</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BinaryTree</span>();</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建一个树节点</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">CreateNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="comment">// 释放树节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* pnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 利用扩展二叉树的前序遍历序列来创建一个二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPT</span><span class="params">(<span class="type">char</span>* pstr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(root, pstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 利用扩展二叉树的前序遍历序列创建二叉树的递归函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPTRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>*&amp; pstr)</span></span>;<span class="comment">// 参数类型为引用，确保递归调用中对参数的改变会影响到调用者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归方式前序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line">    <span class="comment">// 递归方式中序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line">    <span class="comment">// 递归方式后序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层序遍历二叉树</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int8_t</span> mis = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">levelOrder</span>(root, mis);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 参数2说明：=1 表示要判断该树是否是一颗完全二叉树，返回的结果记录在ifct里，如果返回-1，则不是一颗完全二叉树，返回1则是</span></span><br><span class="line">    <span class="comment">//=0 表示层序遍历输出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">int8_t</span>&amp; ifct)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断该树是否是一颗完全二叉树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IfCompleteTree</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求二叉树节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSize</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 也可以用遍历二叉树的方式求节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 左子树个数 + 右子树个数 + 1（之所以+1，是因为还有一个根节点）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSize</span>(tnode-&gt;leftChild) + <span class="built_in">GetSize</span>(tnode-&gt;rightChild) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求二叉树高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetHeight</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找某个节点（假设二叉树的节点各不相同）</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">SearchElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchElem</span>(root, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">SearchElem</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找某个节点的父节点（如果节点存在指向父节点的指针，那就很方便，如果不存在，那么就要从根开始查找）</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">GetParent</span><span class="params">(BinaryTreeNode&lt;T&gt;* tSonNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetParent</span>(root, tSonNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">GetParent</span><span class="params">(BinaryTreeNode&lt;T&gt;* tParNode, BinaryTreeNode&lt;T&gt;* tSonNode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 树的拷贝</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinaryTree&lt;T&gt;* targetTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">CopyTree</span>(root, targetTree-&gt;root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 注意参数2：是指针的引用， 因为需要修改参数2的值，得用引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinaryTreeNode&lt;T&gt;* sSource, BinaryTreeNode&lt;T&gt;*&amp; tTarget)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------- 非递归遍历操作</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">需要借助栈来实现</span></span><br><span class="line"><span class="comment">前序遍历  根 左 右</span></span><br><span class="line"><span class="comment">1) 现将根节点入栈</span></span><br><span class="line"><span class="comment">2) 如果栈不为空，则循环下面的步骤，直到栈为空</span></span><br><span class="line"><span class="comment">2.1) 栈顶元素出栈并访问（显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.2) 如果这个被访问的元素右子节点不为空，则把其右子节点入栈</span></span><br><span class="line"><span class="comment">2.3) 如果这个被访问的元素左子节点不为空，则把其左子节点入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">中序遍历 左 根 右</span></span><br><span class="line"><span class="comment">1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line"><span class="comment">2) 如果 栈不为空，则循环下面步骤</span></span><br><span class="line"><span class="comment">2.1) 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line"><span class="comment">(1) 将 当前节点的左子节点入栈,</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line"><span class="comment">2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历</span></span><br><span class="line"><span class="comment">左 右 根</span></span><br><span class="line"><span class="comment">1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"><span class="comment">2) 循环下面的步骤(循环1)：</span></span><br><span class="line"><span class="comment">2.1) 如果 当前节点 不为空，则循环(循环2)做两件事情，直到当前节点为空：</span></span><br><span class="line"><span class="comment">(1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 如果栈不为空，则循环(循环3)做如下事情：</span></span><br><span class="line"><span class="comment">(1) 栈顶元素出栈</span></span><br><span class="line"><span class="comment">(2) 如果出栈的元素有 &quot;左子树&quot;标记，则</span></span><br><span class="line"><span class="comment">(2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line"><span class="comment">(2.2) 重新将该元素入栈</span></span><br><span class="line"><span class="comment">(2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line"><span class="comment">(2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line"><span class="comment">(3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.3） 如果栈为空，则遍历结束，循环1结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------- ## 通过遍历序列创建二叉树</span></span><br><span class="line">    <span class="comment">// 结论：已知前序和中序遍历序列，是能够唯一确定一颗二叉树的。</span></span><br><span class="line">    <span class="comment">// 如何根据前序、中序遍历序列来创建一颗二叉树</span></span><br><span class="line">    <span class="comment">// 参数 pP_T：前序遍历序列(根左右)， 比如  “ABCDE”</span></span><br><span class="line">    <span class="comment">// 参数 pI_T：中序遍历序列(左根右)，比如 &quot;DBACE&quot;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPI</span><span class="params">(<span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPI</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何根据中序、后序遍历序列来创建一颗二叉树？</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordIPO</span><span class="params">(<span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordIPO</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* root;<span class="comment">// 树根节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// *************************************************************</span></span><br><span class="line"><span class="comment">// *************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTree&lt;T&gt;::<span class="built_in">BinaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTree&lt;T&gt;::~<span class="built_in">BinaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从根开始释放节点</span></span><br><span class="line">    <span class="built_in">ReleaseNode</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">ReleaseNode</span>(BinaryTreeNode&lt;T&gt;* pnode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(pnode-&gt;leftChild);</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(pnode-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pnode;<span class="comment">// delete一个空也无所谓</span></span><br><span class="line">    pnode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">CreateNode</span>(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (parentnode == <span class="literal">nullptr</span> &amp;&amp; pointSign != E_Root)<span class="comment">// 只有创建根节点时，parentnode才允许为nullptr</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新节点创建出来</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;</span><br><span class="line">    tmpnode-&gt;data = e;</span><br><span class="line">    tmpnode-&gt;leftChild = <span class="literal">nullptr</span>;</span><br><span class="line">    tmpnode-&gt;rightChild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新节点放入正确的位置</span></span><br><span class="line">    <span class="keyword">if</span> (pointSign == E_Root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)<span class="comment">// 已经存在了根节点，那么就把就得根节点释放掉，用新的替换</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpnode-&gt;leftChild = root-&gt;leftChild;</span><br><span class="line">            tmpnode-&gt;rightChild = root-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pointSign == E_ChildLeft)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是左孩子节点</span></span><br><span class="line">        parentnode-&gt;leftChild = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是右孩子节点</span></span><br><span class="line">        parentnode-&gt;rightChild = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式前序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">preOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式前序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历：根 左 右</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">        <span class="built_in">preOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        <span class="built_in">preOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式中序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">inOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式中序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 中序遍历：左 根 右</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">        <span class="built_in">inOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式后序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">postOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式后序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 后续遍历：左 右 根</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        <span class="built_in">postOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该树是否是一颗完全二叉树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BinaryTree&lt;T&gt;::<span class="built_in">IfCompleteTree</span>()<span class="comment">// 判断是否是一颗完全二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int8_t</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">levelOrder</span>(root, res);<span class="comment">// res返回来的值，要么是1 要么是 -1 </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">bool</span>)(res + <span class="number">1</span>);<span class="comment">// res + 1 然后强转成bool值，就不会出错了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数2说明：=1 表示要判断该树是否是一颗完全二叉树，返回的结果记录在ifct里，如果返回-1，则不是一颗完全二叉树，返回1则是</span></span><br><span class="line"><span class="comment">//=0 表示层序遍历输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">levelOrder</span>(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">int8_t</span>&amp; ifct)<span class="comment">// 层序遍历函数，因为判断一颗树是否是一颗完全二叉树，通过程序遍历 比较方便，在层序遍历中，如果某个节点不存在左孩子，却存在右孩子，那么肯定就不是一颗完全二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">        LinkQueue&lt;BinaryTreeNode&lt;T&gt;*&gt; lnobj;<span class="comment">// 注意队列的元素类型是  节点指针  类型</span></span><br><span class="line">        lnobj.<span class="built_in">EnQueue</span>(tnode);<span class="comment">// 先把根节点指针入队</span></span><br><span class="line">        <span class="keyword">while</span> (lnobj.<span class="built_in">IsEmpty</span>() == <span class="literal">false</span>)<span class="comment">// 循环判断队列是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            lnobj.<span class="built_in">DeQueue</span>(tmpnode);<span class="comment">// 出队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ifct != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果某个节点 左孩子不存在 却存在 右孩子 那么这棵树肯定不是一颗完全二叉树</span></span><br><span class="line">                <span class="keyword">if</span> (tmpnode-&gt;leftChild == <span class="literal">nullptr</span> &amp;&amp; tmpnode-&gt;rightChild)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;这颗二叉树不是一颗完全二叉树.&quot; &lt;&lt; endl;</span></span><br><span class="line">                    ifct = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ifct = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmpnode-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lnobj.<span class="built_in">EnQueue</span>(tmpnode-&gt;leftChild);<span class="comment">// 左孩子入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lnobj.<span class="built_in">EnQueue</span>(tmpnode-&gt;rightChild);<span class="comment">// 右孩子入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line">    &#125; <span class="comment">// end if</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用扩展二叉树的前序遍历序列创建二叉树的递归函数</span></span><br><span class="line"><span class="comment">// 参数类型为引用，确保递归调用中对参数的改变会影响到调用者</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPTRecu</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>*&amp; pstr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历序列：ABD###C#E##    根左右</span></span><br><span class="line">    <span class="keyword">if</span> (*pstr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根左右</span></span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = *pstr;</span><br><span class="line">        tnode-&gt;leftChild = <span class="literal">nullptr</span>;</span><br><span class="line">        tnode-&gt;rightChild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(tnode-&gt;leftChild, ++pstr);<span class="comment">// 创建左子树</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(tnode-&gt;rightChild, ++pstr);<span class="comment">// 创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二叉树高度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> BinaryTree&lt;T&gt;::<span class="built_in">GetHeight</span>(BinaryTreeNode&lt;T&gt;* tnode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftheight = <span class="built_in">GetHeight</span>(tnode-&gt;leftChild);<span class="comment">// 左子树高度</span></span><br><span class="line">    <span class="type">int</span> rightheight = <span class="built_in">GetHeight</span>(tnode-&gt;rightChild);<span class="comment">// 右子树高度</span></span><br><span class="line">    <span class="keyword">if</span> (leftheight &gt; rightheight)</span><br><span class="line">        <span class="keyword">return</span> leftheight + <span class="number">1</span>;<span class="comment">// 左子树高度 + 1（根节点）</span></span><br><span class="line">    <span class="keyword">return</span> rightheight + <span class="number">1</span>;<span class="comment">// 右子树高度 + 1（根节点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个节点（假设二叉树的节点各不相同）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">SearchElem</span>(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (tnode-&gt;data == e)<span class="comment">// 从根开始找</span></span><br><span class="line">        <span class="keyword">return</span> tnode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* p = <span class="built_in">SearchElem</span>(tnode-&gt;leftChild, e);<span class="comment">// 查找左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)<span class="comment">// 这里判断不可少</span></span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">// 在左孩子这里扎到了，那就返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SearchElem</span>(tnode-&gt;rightChild, e);<span class="comment">// 左子树查不到的情况，那就继续到右子树里面查找，这里直接return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个节点的父节点（如果节点存在指向父节点的指针，那就很方便，如果不存在，那么就要从根开始查找）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">GetParent</span>(BinaryTreeNode&lt;T&gt;* tParNode, BinaryTreeNode&lt;T&gt;* tSonNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tParNode == <span class="literal">nullptr</span> || tSonNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (tParNode-&gt;leftChild == tSonNode || tParNode-&gt;rightChild == tSonNode)</span><br><span class="line">        <span class="keyword">return</span> tParNode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* p_left = <span class="built_in">GetParent</span>(tParNode-&gt;leftChild, tSonNode);</span><br><span class="line">    <span class="keyword">if</span> (p_left != <span class="literal">nullptr</span>)<span class="comment">// 走到这里，如果在左孩子树中找到了，那就返回</span></span><br><span class="line">        <span class="keyword">return</span> p_left;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetParent</span>(tParNode-&gt;rightChild, tSonNode);<span class="comment">// 左孩子没找到，那么就去右孩子树递归找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的拷贝</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 注意参数2：是指针的引用， 因为需要修改参数2的值，得用引用</span></span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CopyTree</span>(BinaryTreeNode&lt;T&gt;* sSource, BinaryTreeNode&lt;T&gt;*&amp; tTarget)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sSource == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tTarget = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tTarget = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;</span><br><span class="line">        tTarget-&gt;data = sSource-&gt;data;</span><br><span class="line">        <span class="built_in">CopyTree</span>(sSource-&gt;leftChild, tTarget-&gt;leftChild);<span class="comment">// 对左子树进行拷贝</span></span><br><span class="line">        <span class="built_in">CopyTree</span>(sSource-&gt;rightChild, tTarget-&gt;rightChild);<span class="comment">// 对右子树进行拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************************** 非递归遍历操作</span></span><br><span class="line"><span class="comment">// 需要借助栈来实现</span></span><br><span class="line"><span class="comment">// 前序遍历  根 左 右</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 现将根节点入栈</span></span><br><span class="line"><span class="comment">2) 如果栈不为空，则循环下面的步骤，直到栈为空</span></span><br><span class="line"><span class="comment">2.1) 栈顶元素出栈并访问（显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.2) 如果这个被访问的元素右子节点不为空，则把其右子节点入栈</span></span><br><span class="line"><span class="comment">2.3) 如果这个被访问的元素左子节点不为空，则把其左子节点入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">preOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkStack&lt;BinaryTreeNode&lt;T&gt;*&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(troot);<span class="comment">// 根节点入栈</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">    <span class="keyword">while</span> (slinkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)<span class="comment">// 栈不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        slinkobj.<span class="built_in">Pop</span>(tmpnode);<span class="comment">// 栈顶元素出栈</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(tmpnode-&gt;rightChild);</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(tmpnode-&gt;leftChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 左 根 右</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line"><span class="comment">2) 如果 栈不为空，则循环下面步骤</span></span><br><span class="line"><span class="comment">2.1) 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line"><span class="comment">(1) 将 当前节点的左子节点入栈,</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line"><span class="comment">2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">inOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkStack&lt;BinaryTreeNode&lt;T&gt;*&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(troot);<span class="comment">// 1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* curr_node = troot;<span class="comment">// 这个可以不要，因为形参是指针类型，而不是指针引用，因此修改troot不会影响到外面， 但是为了方便阅读代码，直观表达 当前节点 这个概念，就直接使用curr_node来表示</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">    <span class="keyword">while</span> (slinkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr_node-&gt;leftChild != <span class="literal">nullptr</span>)<span class="comment">// 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(curr_node-&gt;leftChild);<span class="comment">// (1) 将 当前节点的左子节点入栈,</span></span><br><span class="line">            curr_node = curr_node-&gt;leftChild;<span class="comment">// (2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        slinkobj.<span class="built_in">Pop</span>(tmpnode);<span class="comment">// 2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)<span class="comment">// 2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            curr_node = tmpnode-&gt;rightChild;</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(curr_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="comment">// 左 右 根</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"><span class="comment">2) 循环下面的步骤(循环1)：</span></span><br><span class="line"><span class="comment">2.1) 如果 当前节点 不为空，则循环(循环2)做两件事情，直到当前节点为空：</span></span><br><span class="line"><span class="comment">(1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 如果栈不为空，则循环(循环3)做如下事情：</span></span><br><span class="line"><span class="comment">(1) 栈顶元素出栈</span></span><br><span class="line"><span class="comment">(2) 如果出栈的元素有 &quot;左子树&quot;标记，则</span></span><br><span class="line"><span class="comment">(2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line"><span class="comment">(2.2) 重新将该元素入栈</span></span><br><span class="line"><span class="comment">(2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line"><span class="comment">(2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line"><span class="comment">(3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.3） 如果栈为空，则遍历结束，循环1结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">postOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkStack&lt;BTNode_extra&lt;T&gt;&gt; linkobj;</span><br><span class="line">    BTNode_extra&lt;T&gt; ext_tmpnode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* curr_node = troot;<span class="comment">// 1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span><span class="comment">// 循环1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr_node != <span class="literal">nullptr</span>)<span class="comment">// 循环2</span></span><br><span class="line">        &#123;</span><br><span class="line">            ext_tmpnode.point = curr_node;</span><br><span class="line">            ext_tmpnode.pointSign = E_ChildLeft;<span class="comment">// 标记先处理该节点的左孩子</span></span><br><span class="line">            linkobj.<span class="built_in">Push</span>(ext_tmpnode);<span class="comment">// (1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line">            curr_node = curr_node-&gt;leftChild;<span class="comment">// (2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (linkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)<span class="comment">// 循环3</span></span><br><span class="line">        &#123;</span><br><span class="line">            linkobj.<span class="built_in">Pop</span>(ext_tmpnode);<span class="comment">// (1) 栈顶元素出栈</span></span><br><span class="line">            <span class="keyword">if</span> (ext_tmpnode.pointSign == E_ChildLeft)</span><br><span class="line">            &#123;</span><br><span class="line">                ext_tmpnode.pointSign = E_ChildRight;<span class="comment">// (2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line">                linkobj.<span class="built_in">Push</span>(ext_tmpnode);<span class="comment">// (2.2) 重新将该元素入栈</span></span><br><span class="line">                curr_node = ext_tmpnode.point-&gt;rightChild;<span class="comment">// (2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// (2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ext_tmpnode.pointSign == E_ChildRight)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="type">char</span>)ext_tmpnode.point-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// (3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (linkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************** ## 通过遍历序列创建二叉树</span></span><br><span class="line"><span class="comment">// 结论：已知前序和中序遍历序列，是能够唯一确定一颗二叉树的。</span></span><br><span class="line"><span class="comment">// 如何根据前序、中序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">// 参数 pP_T：前序遍历序列(根左右)， 比如  “ABCDE”</span></span><br><span class="line"><span class="comment">// 参数 pI_T：中序遍历序列(左根右)，比如 &quot;DBACE&quot;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPI</span>(<span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有个小插曲，这个成员函数是通过 前序、中序 序列来创建二叉树的，而且创建到 root里面去。</span></span><br><span class="line">    <span class="comment">// 如果 root原本就保存着一颗二叉树，那么在创建之前最好先把原本的树节点给释放掉，以免造成内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(root);<span class="comment">// 释放节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreateBTreeAccordPI</span>(root, pP_T, pI_T, <span class="built_in">strlen</span>(pP_T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPI</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// (1)在中序遍历序列中找到根，前序遍历序列中根是在最前面的</span></span><br><span class="line">        <span class="type">int</span> tmpindex = <span class="number">0</span>;<span class="comment">// 下标，从0开始</span></span><br><span class="line">        <span class="keyword">while</span> (pP_T[<span class="number">0</span>] != pI_T[tmpindex])</span><br><span class="line">        &#123;</span><br><span class="line">            ++tmpindex;<span class="comment">// 先找到根节点在 中序序列字符串中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = pI_T[tmpindex];<span class="comment">// 给根节点的数据域赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 创建左孩子  通过递归来创建</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPI</span>(</span><br><span class="line">            tnode-&gt;leftChild,<span class="comment">// 创建左孩子</span></span><br><span class="line">            pP_T + <span class="number">1</span>,<span class="comment">// 找到前序遍历序列中左树开始节点的位置，这里跳过了第一个节点（根），  （根 左 右）</span></span><br><span class="line">            pI_T,<span class="comment">// 中序遍历不需要改动</span></span><br><span class="line">            tmpindex<span class="comment">// 左孩子的节点个数，因为 tmpindex是父节点(根)的下标</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// (3) 创建右孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPI</span>(</span><br><span class="line">            tnode-&gt;rightChild,<span class="comment">// 创建右孩子</span></span><br><span class="line">            pP_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到前序遍历序列中右树开始节点的位置，不难发现前序遍历序列和中序遍历序列右树开始节点的位置相同</span></span><br><span class="line">            pI_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到中序遍历序列中右树节点开始的位置</span></span><br><span class="line">            n - tmpindex - <span class="number">1</span><span class="comment">// 右孩子节点数  n 节点总数， tmpindex 左孩子节点数， -1 减去根 所以 右孩子 = n - tmpindex - 1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何根据中序、后序遍历序列来创建一颗二叉树？</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordIPO</span>(<span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有个小插曲，这个成员函数是通过 前序、中序 序列来创建二叉树的，而且创建到 root里面去。</span></span><br><span class="line">    <span class="comment">// 如果 root原本就保存着一颗二叉树，那么在创建之前最好先把原本的树节点给释放掉，以免造成内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(root);<span class="comment">// 释放节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreateBTreeAccordIPO</span>(root, pInorder_T, pPostOrder_T, <span class="built_in">strlen</span>(pInorder_T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordIPO</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以通过 后序遍历 找到根节点 （最后一个就是）</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在中序遍历序列中 找根，后序遍历序列中 根是在最后</span></span><br><span class="line">        <span class="type">int</span> tmpindex = <span class="number">0</span>;<span class="comment">// 找根的 下标，找打了的话，那么下标就是根节点在中序序列中的下标</span></span><br><span class="line">        <span class="keyword">while</span> (pPostOrder_T[n - <span class="number">1</span>] != pInorder_T[tmpindex])</span><br><span class="line">            ++tmpindex;</span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = pInorder_T[tmpindex];<span class="comment">// 给根节点数据域赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) 创建左孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordIPO</span>(</span><br><span class="line">            tnode-&gt;leftChild,<span class="comment">// 创建左孩子</span></span><br><span class="line">            pInorder_T,<span class="comment">// 中序(左根右)的不需要改动，因为开头的都是左孩子</span></span><br><span class="line">            pPostOrder_T,<span class="comment">// 后序(左右根） 仍旧不需要改动</span></span><br><span class="line">            tmpindex<span class="comment">// 左孩子节点个数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 创建右孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordIPO</span>(</span><br><span class="line">            tnode-&gt;rightChild,<span class="comment">// 创建右孩子</span></span><br><span class="line">            pInorder_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到中序遍历序列中右树开始节点的位置</span></span><br><span class="line">            pPostOrder_T + tmpindex,<span class="comment">// 找到后序遍历序列中右树开始的节点位置</span></span><br><span class="line">            n - tmpindex - <span class="number">1</span><span class="comment">// 右孩子节点数</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkBinaryTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree;</span><br><span class="line">    <span class="comment">// 创建一颗二叉树</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* rootpoint = mytree.<span class="built_in">CreateNode</span>(<span class="literal">nullptr</span>, E_Root, <span class="string">&#x27;A&#x27;</span>);<span class="comment">// 创建树根节点 A</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeB = mytree.<span class="built_in">CreateNode</span>(rootpoint, E_ChildLeft, <span class="string">&#x27;B&#x27;</span>);<span class="comment">// 创建A的左孩子B</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeC = mytree.<span class="built_in">CreateNode</span>(rootpoint, E_ChildRight, <span class="string">&#x27;C&#x27;</span>);<span class="comment">// 创建A的右孩子C</span></span><br><span class="line"></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeD = mytree.<span class="built_in">CreateNode</span>(treenodeB, E_ChildLeft, <span class="string">&#x27;D&#x27;</span>);<span class="comment">// 创建B的左孩子D</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeE = mytree.<span class="built_in">CreateNode</span>(treenodeC, E_ChildRight, <span class="string">&#x27;E&#x27;</span>);<span class="comment">// 创建C的右孩子D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历序列：ABD###C#E##(给出一个扩展二叉树的前序遍历序列，是能够唯一确定一颗二叉树的)</span></span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree2;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">CreateBTreeAccordPT</span>((<span class="type">char</span>*)<span class="string">&quot;ABD###C#E##&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">前序遍历序列为：A  B  D  C  E</span></span><br><span class="line"><span class="comment">中序遍历序列为：D  B  A  C  E</span></span><br><span class="line"><span class="comment">后序遍历序列为：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;层序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.l</span>evelOrder();</span><br><span class="line">    <span class="comment">/* 层序遍历序列为：A  B  C  D  E */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;是否是一颗完全二叉树? &quot;</span> &lt;&lt; ((mytree<span class="number">2.</span><span class="built_in">IfCompleteTree</span>()) ? <span class="string">&quot;是的&quot;</span> : <span class="string">&quot;不是&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树节点个数为：&quot;</span> &lt;&lt; mytree<span class="number">2.</span><span class="built_in">GetSize</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树的高度为：&quot;</span> &lt;&lt; mytree<span class="number">2.</span><span class="built_in">GetHeight</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 查找某个节点</span></span><br><span class="line">    <span class="type">int</span> val = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* s_node = mytree<span class="number">2.</span><span class="built_in">SearchElem</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (s_node != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)val &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 查找某个节点的父节点</span></span><br><span class="line">        BinaryTreeNode&lt;<span class="type">int</span>&gt;* p_node = mytree<span class="number">2.</span><span class="built_in">GetParent</span>(s_node);</span><br><span class="line">        <span class="keyword">if</span> (p_node != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;找到了节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)s_node-&gt;data &lt;&lt; <span class="string">&quot; 的父节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)p_node-&gt;data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;未找到节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)s_node-&gt;data &lt;&lt; <span class="string">&quot; 的父节&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试树的拷贝</span></span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree3;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">CopyTree</span>(&amp;mytree3);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝的树mytree3的中序遍历：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归 前序遍历二叉树</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 前序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">preOrder_noRecu</span>();</span><br><span class="line">    <span class="comment">// 非递归 中序遍历二叉树</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 中序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">inOrder_noRecu</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 后序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">postOrder_noRecu</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用前序遍历、中序遍历序列来创建一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree4;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">CreateBTreeAccordPI</span>((<span class="type">char</span>*)<span class="string">&quot;ABDCE&quot;</span>, (<span class="type">char</span>*)<span class="string">&quot;DBACE&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用前序：ABDCE 中序：DBACE 序列创建了一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的前序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的中序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的后序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">使用前序遍历、中序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">使用前序：ABDCE 中序：DBACE 序列创建了一颗二叉树</span></span><br><span class="line"><span class="comment">该二叉树的前序遍历序列：A  B  D  C  E</span></span><br><span class="line"><span class="comment">该二叉树的中序遍历序列：D  B  A  C  E</span></span><br><span class="line"><span class="comment">该二叉树的后序遍历序列：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用中序遍历、后序遍历序列来创建一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree5;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">CreateBTreeAccordIPO</span>((<span class="type">char</span>*)<span class="string">&quot;DBACE&quot;</span>, (<span class="type">char</span>*)<span class="string">&quot;DBECA&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用中序：DBACE 后序：DBECA 序列创建了一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的前序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的中序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的后序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">使用中序遍历、后序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">使用中序：DBACE 后序：DBECA 序列创建了一颗二叉树</span></span><br><span class="line"><span class="comment">该二叉树的前序遍历序列：A  B  D  C  E</span></span><br><span class="line"><span class="comment">该二叉树的中序遍历序列：D  B  A  C  E</span></span><br><span class="line"><span class="comment">该二叉树的后序遍历序列：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_LinkedStorage_2.png" alt="BinaryTree_LinkedStorage_2"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 二叉树(顺序存储)</title>
      <link href="/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/"/>
      <url>/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树-顺序存储"><a href="#二叉树-顺序存储" class="headerlink" title="二叉树(顺序存储)"></a>二叉树(顺序存储)</h1><p>顺序存储二叉树的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ECCHILDSIGN</span><span class="comment">// 节点标记</span></span><br><span class="line">&#123;</span><br><span class="line">    E_Root,<span class="comment">// 树根</span></span><br><span class="line">    E_ChildLeft,<span class="comment">// 左孩子</span></span><br><span class="line">    E_ChildRight<span class="comment">// 右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，用于存放数据元素</span></span><br><span class="line">    <span class="type">bool</span> isValid;<span class="comment">// 该节点是否有效以应对非完全二叉树(只有保存了实际节点数据的节点才是有效的)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BinaryTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MaxSize; ++i)<span class="comment">// 这里数组大小是MaxSize +1，所以这里i的终止值没有问题</span></span><br><span class="line">        &#123;</span><br><span class="line">            SqBiTree[i].isValid = <span class="literal">false</span>;<span class="comment">// 开始时节点无效，没有保存任何数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建一个树节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CreateNode</span><span class="params">(<span class="type">int</span> parindex, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="comment">// 获取父节点的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetParentIdx</span><span class="params">(<span class="type">int</span> sonindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ifValidRangeIdx(sonindex))<span class="comment">// 位置不合理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[sonindex].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点，不要尝试找父节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(sonindex / <span class="number">2</span>); <span class="comment">// i的父节点是(i/2)向下取整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取某个节点所在的高度</span></span><br><span class="line">    <span class="comment">// 根据二叉树的性质5：具有n(n&gt;0)个节点的完全二叉树的高度log2(n+1) 向上取整 或者是 log2(n) 向下取整 再来 + 1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPointLevel</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点，不要尝试找父节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 采用公式计算：log2(n) 向下取整 再来 +1</span></span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">int</span>(<span class="built_in">log</span>(index) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// c++中的log(n)函数求的是以e(2.71828)为底的对数值，如果要求以数字m为底的，则需要 log(n) / log(m)</span></span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = MaxSize; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[i].isValid == <span class="literal">true</span>)<span class="comment">// 找到了最后一个有效节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPointLevel</span>(i);<span class="comment">// 最后一个有效节点的高度，就是整个二叉树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是个完全二叉树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IfCompleteBT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = MaxSize; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[i].isValid == <span class="literal">true</span>)<span class="comment">// 找到了最后一个有效节点</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 找到最后一个有效节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个有效节点之前的所有下标必须都是有效的，才是一颗完全二叉树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[k].isValid == <span class="literal">false</span>)<span class="comment">// 所有节点必须都要有效</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历二叉树，其他的遍历方式在二叉树的链式存储中再详细书写代码</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">1</span>);<span class="comment">// 根节点的数组下标是1，所以这里把根的下标传递进去</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根左右顺序</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="comment">// 输出节点的数据域的值，为了方便观察，这里用char以显示字符</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">2</span> * index);<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);<span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 左右根 顺序</span></span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">2</span> * index);</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">posOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">posOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 左右根 顺序</span></span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">2</span> * index);</span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 判断下标是否有效</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ifValidRangeIdx</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 位置必须合理</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; MaxSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt; SqBiTree[MaxSize + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 存储二叉树节点的数组，为了写程序方便，下标为0的数组元素不使用，因此这里需要+1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 参数1：父节点所在的数组下标</span></span><br><span class="line"><span class="comment">// 参数2：标记所创建的是树根、左孩子、右孩子</span></span><br><span class="line"><span class="comment">// 参数3：插入的数据节点的元素值</span></span><br><span class="line"><span class="type">int</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateNode</span>(<span class="type">int</span> parindex, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointSign != E_Root)</span><br><span class="line">    &#123;<span class="comment">// 创建的是 非根节点，则一定是子节点，要求parindex一定是个合理值</span></span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(parindex) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[parindex].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pointSign == E_Root)<span class="comment">// 创建的是根</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">1</span>;<span class="comment">// 根节点固定存储在下标为1的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pointSign == E_ChildLeft)<span class="comment">// 左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是左孩子的节点，节点i的左孩子节点的下标是2*i</span></span><br><span class="line">        index = <span class="number">2</span> * parindex;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是右孩子的节点，节点i的右孩子节点的下标是2*i + 1</span></span><br><span class="line">        index = <span class="number">2</span> * parindex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SqBiTree[index].data = e;</span><br><span class="line">    SqBiTree[index].isValid = <span class="literal">true</span>;<span class="comment">// 标记该下标中有有效数据</span></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqBinaryTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree;</span><br><span class="line">    <span class="comment">// 创建一颗二叉树</span></span><br><span class="line">    <span class="type">int</span> indexRoot = mytree.<span class="built_in">CreateNode</span>(<span class="number">-1</span>, E_Root, <span class="string">&#x27;A&#x27;</span>);<span class="comment">// 创建树根节点A</span></span><br><span class="line">    <span class="type">int</span> indexNodeB = mytree.<span class="built_in">CreateNode</span>(indexRoot, E_ChildLeft, <span class="string">&#x27;B&#x27;</span>);<span class="comment">// 创建根节点的左孩子节点B</span></span><br><span class="line">    <span class="type">int</span> indexNodeC = mytree.<span class="built_in">CreateNode</span>(indexRoot, E_ChildRight, <span class="string">&#x27;C&#x27;</span>);<span class="comment">// 创建根节点的右孩子节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeD = mytree.<span class="built_in">CreateNode</span>(indexNodeB, E_ChildLeft, <span class="string">&#x27;D&#x27;</span>);<span class="comment">// 创建节点B的左孩子节点D</span></span><br><span class="line">    <span class="type">int</span> indexNodeE = mytree.<span class="built_in">CreateNode</span>(indexNodeB, E_ChildRight, <span class="string">&#x27;E&#x27;</span>);<span class="comment">// 创建节点C的右孩子节点E</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeG = mytree.<span class="built_in">CreateNode</span>(indexNodeD, E_ChildRight, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> indexNodeH = mytree.<span class="built_in">CreateNode</span>(indexNodeE, E_ChildLeft, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeF = mytree.<span class="built_in">CreateNode</span>(indexNodeC, E_ChildRight, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iParentIndexE = mytree.<span class="built_in">GetParentIdx</span>(indexNodeE);<span class="comment">// 获取某个节点父节点的下标</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点E的父节点的下标是:&quot;</span> &lt;&lt; iParentIndexE &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iLevel = mytree.<span class="built_in">GetPointLevel</span>(indexNodeD);<span class="comment">// 获取某个节点所在的高度/深度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点D所在的高度/深度是:&quot;</span> &lt;&lt; iLevel &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    iLevel = mytree.<span class="built_in">GetPointLevel</span>(indexNodeB);<span class="comment">// 获取某个节点所在的高度/深度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点B所在的高度/深度是:&quot;</span> &lt;&lt; iLevel &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整个二叉树的深度是:&quot;</span> &lt;&lt; mytree.<span class="built_in">GetLevel</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树是个完全二叉树码? &quot;</span> &lt;&lt; (mytree.<span class="built_in">IfCompleteBT</span>() ? <span class="string">&quot;是的&quot;</span> : <span class="string">&quot;不是&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">PreOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">posOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">节点E的父节点的下标是:2</span></span><br><span class="line"><span class="comment">节点D所在的高度/深度是:3</span></span><br><span class="line"><span class="comment">节点B所在的高度/深度是:2</span></span><br><span class="line"><span class="comment">整个二叉树的深度是:4</span></span><br><span class="line"><span class="comment">二叉树是个完全二叉树码? 不是</span></span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="comment">前序遍历序列为:A  B  D  G  E  H  C  F</span></span><br><span class="line"><span class="comment">中序遍历序列为:D  G  B  H  E  A  C  F</span></span><br><span class="line"><span class="comment">后序遍历序列为:G  D  H  E  B  F  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_SeqStorage.png" alt="BinaryTree_SeqStorage"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 循环队列</title>
      <link href="/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/"/>
      <url>/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>循环队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYCIRCLEQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYCIRCLEQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircleQueue</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">CircleQueue</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EntQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入队列（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelQueue</span><span class="params">(T&amp; e)</span></span>;    <span class="comment">// 出队列（删除数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;   <span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;  <span class="comment">// 将队列清空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序队列中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>; <span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断顺序队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序队列是否为满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data; <span class="comment">// 存放顺序队列中的元素</span></span><br><span class="line">    <span class="type">int</span> m_front;  <span class="comment">// 队头指针（数组下标），允许删除的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> m_rear;  <span class="comment">// 队尾指针（数组下标），允许插入的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队尾元素的下一个位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircleQueue&lt;T&gt;::<span class="built_in">CircleQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[MaxSize];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    <span class="comment">// 空队列，约定m_front 和 m_rear 都为0</span></span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序队列进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircleQueue&lt;T&gt;::~<span class="built_in">CircleQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列（增加数据）,也就是从队尾增加数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">EntQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂时先不扩容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列已满，无法进行入队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[m_rear] = e;  <span class="comment">// 将数据放到队尾</span></span><br><span class="line">    <span class="comment">// m_rear++;  // 队尾指针往后走， +1</span></span><br><span class="line">    m_rear = (m_rear + <span class="number">1</span>) % MaxSize;  </span><br><span class="line">    <span class="comment">// 队尾指针+1并取余，这样m_data的下标就控制在0~（MaxSize-1）之间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列（删除数据），也就是从队头删除数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">DelQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法进行出队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_front];   <span class="comment">// 队头元素值返回到e中</span></span><br><span class="line">    <span class="comment">// m_front++;  // 队头往后走一个</span></span><br><span class="line">    m_front = (m_front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法读取队头元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_rear];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列清空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CircleQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_rear = m_front = <span class="number">0</span>;  <span class="comment">// 直接修改队头、队尾指针，设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序队列中的所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CircleQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123; <span class="comment">// 按照从队头到队尾的顺序来显示数据</span></span><br><span class="line">    <span class="comment">// for (int i = m_front; i &lt; m_rear; ++i)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m_front; i != m_rear;)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line"></span><br><span class="line">        i = (i + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> CircleQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return m_rear - m_front;</span></span><br><span class="line">    <span class="keyword">return</span> (m_rear + MaxSize - m_front) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为空, 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为满,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_rear + <span class="number">1</span>)%MaxSize == m_front)<span class="comment">// 队尾指针和数组容量作比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYCIRCLEQUEUE_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCircleQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CircleQueue&lt;<span class="type">int</span>&gt; cricleobj;</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">150</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">200</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">300</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">400</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    cricleobj.<span class="built_in">DelQueue</span>(eval);</span><br><span class="line">    cricleobj.<span class="built_in">DelQueue</span>(eval);</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">500</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">600</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">700</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">800</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">900</span>);</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopQueue.png" alt="LoopQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 双端链式队列</title>
      <link href="/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/"/>
      <url>/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/</url>
      
        <content type="html"><![CDATA[<h1 id="双端链式队列"><a href="#双端链式队列" class="headerlink" title="双端链式队列"></a>双端链式队列</h1><p>双端链式队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T 代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblQueueNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* prev;<span class="comment">// 指针域，指向前一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblLinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblLinkQueue</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">DblLinkQueue</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue_Front</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素） 队头入</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue_Front</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素） 队头出</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素） 队尾入</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue_Back</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素） 队尾出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetRear</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队尾元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList_Front</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素  队头开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList_Back</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素  队尾开始</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取链式队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">// 判断链式队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblQueueNode&lt;T&gt;* m_front;<span class="comment">// 头指针（指向头结点），这一端允许出队（删除）</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* m_rear;<span class="comment">// 专门引入尾指针以方便入队（插入）操作</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 记录长度，方便长度使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkQueue&lt;T&gt;::<span class="built_in">DblLinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_front = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_front-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear = m_front;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对链式队列进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkQueue&lt;T&gt;::~<span class="built_in">DblLinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* pnode = m_front-&gt;next;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_front;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_front = m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列 队头开始入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">EnQueue_Front</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* node = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;next = m_front-&gt;next;</span><br><span class="line">    node-&gt;prev = m_front;</span><br><span class="line">    <span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">    &#123;</span><br><span class="line">        m_rear = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_front-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    m_front-&gt;next = node;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列 队尾开始入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">EnQueue_Back</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* node = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear-&gt;next = node;<span class="comment">// 新节点插入到m_rear后面</span></span><br><span class="line">    node-&gt;prev = m_rear;</span><br><span class="line">    m_rear = node;<span class="comment">// 更新队尾指针</span></span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列 从队头出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DeQueue_Front</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp = m_front-&gt;next;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_front-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="comment">// 这里需要考虑，如果只有一个元素时，出队了就为空了</span></span><br><span class="line">    <span class="keyword">if</span> (ptmp == m_rear)</span><br><span class="line">    &#123;<span class="comment">// 只有一个元素，出队了就为空了，那么尾指针就指向m_front了</span></span><br><span class="line">        m_rear = m_front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 超过2个元素，那么就需要更新前向指针指向m_front</span></span><br><span class="line">        ptmp-&gt;next-&gt;prev = m_front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == ptmp)</span><br><span class="line">    &#123;<span class="comment">// 队列中只有一个元素节点（被删除后，整个队列为空）</span></span><br><span class="line">        m_rear = m_front;<span class="comment">// 设置队列为空，尾指针指向头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列 从队尾出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DeQueue_Back</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp = m_rear;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_rear = m_rear-&gt;prev;</span><br><span class="line">    m_rear-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取队头元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队尾元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">GetRear</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_rear-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)  从前往后输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DispList_Front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* p = m_front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)  从后往输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DispList_Back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* p = m_rear;</span><br><span class="line">    <span class="keyword">while</span> (p != m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链式队列的长度 O&#123;1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkQueue&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链式队列是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m_length &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblLinkQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblLinkQueue&lt;<span class="type">int</span>&gt; lnobj;</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    lnobj.<span class="built_in">DeQueue_Front</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">212</span>);</span><br><span class="line">    lnobj.<span class="built_in">DeQueue_Back</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">200</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">700</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList_Front</span>();<span class="comment">// 200  700</span></span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">666</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">888</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList_Front</span>();</span><br><span class="line">    lnobj.<span class="built_in">DispList_Back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">700  200</span></span><br><span class="line"><span class="comment">888  700  200  666</span></span><br><span class="line"><span class="comment">666  200  700  888</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedDequeue.png" alt="LinkedDequeue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 链式队列</title>
      <link href="/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/"/>
      <url>/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h1><p>链式队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T 代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    QueueNode&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkQueue</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkQueue</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取链式队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">// 判断链式队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    QueueNode&lt;T&gt;* m_front;<span class="comment">// 头指针（指向头结点），这一端允许出队（删除）</span></span><br><span class="line">    QueueNode&lt;T&gt;* m_rear;<span class="comment">// 专门引入尾指针以方便入队（插入）操作</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 记录长度，方便长度使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_front = <span class="keyword">new</span> QueueNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear = m_front;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对链式队列进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::~<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* pnode = m_front-&gt;next;</span><br><span class="line">    QueueNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_front;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_front = m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* node = <span class="keyword">new</span> QueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear-&gt;next = node;<span class="comment">// 新节点插入到m_rear后面</span></span><br><span class="line">    m_rear = node;<span class="comment">// 更新队尾指针</span></span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode&lt;T&gt;* ptmp = m_front-&gt;next;;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_front-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == ptmp)<span class="comment">// 队列中只有一个元素节点（被删除后，整个队列为空）</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_rear = m_front;<span class="comment">// 设置队列为空，尾指针指向头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取队头元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkQueue&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* p = m_front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链式队列的长度 O&#123;1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkQueue&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链式队列是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue&lt;<span class="type">int</span>&gt; lnobj;</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    lnobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">200</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">700</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList</span>();<span class="comment">// 200  700</span></span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">666</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">888</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedQueue.png" alt="LinkedQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序队列</title>
      <link href="/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/"/>
      <url>/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><p>顺序队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqQueue</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">SeqQueue</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EntQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入队列（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelQueue</span><span class="params">(T&amp; e)</span></span>;    <span class="comment">// 出队列（删除数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;   <span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;  <span class="comment">// 将队列清空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序队列中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>;  <span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断顺序队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序队列是否为满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;  <span class="comment">// 存放顺序队列中的元素</span></span><br><span class="line">    <span class="type">int</span> m_front;  <span class="comment">// 队头指针（数组下标），允许删除的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> m_rear;  <span class="comment">// 队尾指针（数组下标），允许插入的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队尾元素的下一个位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[MaxSize];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    <span class="comment">// 空队列，约定m_front 和 m_rear 都为0</span></span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序队列进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::~<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列（增加数据）,也就是从队尾增加数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">EntQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂时先不扩容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列已满，无法进行入队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[m_rear] = e;  <span class="comment">// 将数据放到队尾</span></span><br><span class="line">    m_rear++;  <span class="comment">// 队尾指针往后走， +1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列（删除数据），也就是从队头删除数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">DelQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法进行出队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_front];   <span class="comment">// 队头元素值返回到e中</span></span><br><span class="line">    m_front++;  <span class="comment">// 队头往后走一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法读取队头元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_rear];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列清空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_rear = m_front = <span class="number">0</span>;   <span class="comment">// 直接修改队头、队尾指针，设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序队列中的所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123; <span class="comment">// 按照从队头到队尾的顺序来显示数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m_front; i &lt; m_rear; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_rear - m_front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为空, 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为满,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear &gt;= MaxSize)  <span class="comment">// 队尾指针和数组容量作比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSEQQUEUE_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqQueue&lt;<span class="type">int</span>&gt; seqobj;</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">150</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">200</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">300</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">400</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqQueue.png" alt="SeqQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 链式栈</title>
      <link href="/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/"/>
      <url>/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/</url>
      
        <content type="html"><![CDATA[<h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><p>链式栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYLINKSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYLINKSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 链式栈中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;  <span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    StackNode&lt;T&gt;* next;  <span class="comment">// 指针域，指向下一个同类型(和本节点类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式栈的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkStack</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkStack</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入栈元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>; <span class="comment">// 出栈(删除数据)操作，也就是删除栈顶数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;  <span class="comment">// 读取栈顶数据，但该元素并没有出栈，依旧在栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;  <span class="comment">// 输出链式栈中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;   <span class="comment">// 获取链式栈的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;  <span class="comment">// 判断链式栈是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    StackNode&lt;T&gt;* m_top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> m_length; <span class="comment">// 链式栈当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_top = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作。入栈元素e，时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode&lt;T&gt;* p_new = <span class="keyword">new</span> StackNode&lt;T&gt;;</span><br><span class="line">    p_new-&gt;data = e;</span><br><span class="line">    p_new-&gt;next = m_top;</span><br><span class="line">    m_top = p_new;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈(删除数据)操作，也就是删除栈顶数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;当前链式栈为空，无法进行出栈操作!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode&lt;T&gt;* p_curr = m_top;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    m_top = m_top-&gt;next;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;出栈操作成功，元素为值为:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">delete</span> p_curr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取栈顶数据，但该元素并没有出栈，依旧在栈中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前链式栈为空，无法读取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_top-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出链式栈中所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    StackNode&lt;T&gt;* p_curr = m_top;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取链式栈的长度 O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断链式栈是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数 释放链式栈内存空间</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::~<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T tmp_value = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Pop</span>(tmp_value) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里不用干啥</span></span><br><span class="line">        <span class="comment">// 把栈顶元素删除光，while循环也就退出了，此时也就是空栈了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYLINKSTACK_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkStack.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数字相加的和值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> tmpA, <span class="type">int</span> tmpB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = tmpA + tmpB;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_operator_ch[] = &#123; <span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result = <span class="built_in">Add</span>(a1, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;和值为:&quot;</span> &lt;&lt; result &lt;&lt; endl;<span class="comment">// 和值为:115</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isMatchSucc = <span class="literal">true</span>;<span class="comment">// 是否匹配成功的标志，先标记为匹配成功</span></span><br><span class="line">    LinkStack&lt;<span class="type">char</span>&gt; slinkobjprocKH;<span class="comment">// 用来保存左括号的栈 &#123; [ (</span></span><br><span class="line">    string strExp = <span class="string">&quot;[(&#123;&#125;)&#123;&#125;]&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strExp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (strExp[i] == <span class="string">&#x27;(&#x27;</span> || </span><br><span class="line">            strExp[i] == <span class="string">&#x27;[&#x27;</span> || </span><br><span class="line">            strExp[i] == <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">           )</span><br><span class="line">        &#123;</span><br><span class="line">            slinkobjprocKH.<span class="built_in">Push</span>(strExp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前是个右括号，则从栈顶取出一个左括号</span></span><br><span class="line">            <span class="type">char</span> tmpTopChar;</span><br><span class="line">            <span class="keyword">if</span> (slinkobjprocKH.<span class="built_in">Pop</span>(tmpTopChar) == <span class="literal">false</span>)</span><br><span class="line">            &#123;<span class="comment">// 从栈顶取出数据失败</span></span><br><span class="line">                isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((strExp[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (strExp[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                (strExp[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;&#123;&#x27;</span>) </span><br><span class="line">               )  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// isMatchSucc = true;</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 匹配，继续扫描</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;  <span class="comment">// 不匹配，直接退出循环，因为已经不匹配了，直接不扫描了</span></span><br><span class="line">                isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// end if</span></span><br><span class="line">    &#125;  <span class="comment">// end for</span></span><br><span class="line">    <span class="comment">// 扫描完成，还要确定slinkobjprocKH为空才可以</span></span><br><span class="line">    <span class="keyword">if</span> ((isMatchSucc == <span class="literal">true</span>) &amp;&amp; (slinkobjprocKH.<span class="built_in">Empty</span>() == <span class="literal">false</span>))</span><br><span class="line">    &#123; <span class="comment">// 栈不为空，也是不可以的</span></span><br><span class="line">        isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMatchSucc)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式合法，括号配对数量和顺序都正确！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式非法，括号配对数量和顺序都不正确！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------- Main 结束 -------------------------&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedStack.png" alt="LinkedStack"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 共享栈</title>
      <link href="/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/"/>
      <url>/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/</url>
      
        <content type="html"><![CDATA[<h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><p>共享栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSHARESTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSHARESTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5   <span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"><span class="comment">// 共享栈</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShareStack</span>(<span class="type">int</span> length = InitSize);  <span class="comment">// 构造函数参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">ShareStack</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span>  <span class="comment">// 判断共享栈是否满</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_top1 + <span class="number">1</span> &gt;= m_top2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> stackNum, <span class="type">const</span> T&amp; e)</span>  <span class="comment">// 入栈(增加数据) 参数 stackNum用于表示栈1还是栈2</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里简单处理</span></span><br><span class="line">            <span class="comment">// 也可以增加代码支持共享栈的扩容操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;共享栈满了，无法入栈新数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的入栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的入栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;  <span class="comment">// 走这里，就是入栈1</span></span><br><span class="line">            m_data[++m_top1] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// 前面已经判断过 stackNum 不是1 就是2</span></span><br><span class="line">        &#123; <span class="comment">// 走到这里，就是入栈2</span></span><br><span class="line">            m_data[--m_top2] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(<span class="type">int</span> stackNum, T&amp; e)</span>  <span class="comment">// 出栈(删除数据)，也就是删除栈顶数据</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top1 &lt;= <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈1为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top1--];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top2 &gt;= m_maxsize)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈2为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top2++];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetPop</span><span class="params">(<span class="type">int</span> stackNum, T&amp; e)</span>  <span class="comment">// 获取栈顶元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top1 &lt;= <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈1为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top1];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top2 &gt;= m_maxsize)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈2为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top2];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DisplayStack</span><span class="params">(<span class="type">int</span> stackNum = <span class="number">0</span>)</span><span class="comment">// 打印栈元素</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">/* 参数说明：  </span></span><br><span class="line"><span class="comment">stackNum = 0 代表打印所有元素， 先打印栈1，后打印栈2，从栈顶往栈底打印</span></span><br><span class="line"><span class="comment">stackNum = 1 代表打印栈1的元素，从栈顶往栈顶打印</span></span><br><span class="line"><span class="comment">stackNum = 2 代表打印栈2的元素，从栈顶往栈底打印</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span> &amp;&amp; stackNum != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[0 或者 1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(stackNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Priv_DisplayStack</span><span class="params">(<span class="type">int</span> stackNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打印共享栈1的数据:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m_top1; i &gt; <span class="number">-1</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打印共享栈2的数据:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m_top2; i &lt; m_maxsize; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;   <span class="comment">// 存放共享栈中的元素</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;  <span class="comment">// 动态数组最大容量</span></span><br><span class="line">    <span class="type">int</span> m_top1;   <span class="comment">// 顺序栈1的栈顶指针为-1，表示空栈</span></span><br><span class="line">    <span class="type">int</span> m_top2;  <span class="comment">// 顺序栈2的栈顶指针为m_maxsize，表示空栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数参数可以有默认值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ShareStack&lt;T&gt;::<span class="built_in">ShareStack</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    m_maxsize = length;  <span class="comment">// 共享栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">    m_top1 = <span class="number">-1</span>;   <span class="comment">// 顺序栈1的栈顶指针为-1，表示空栈</span></span><br><span class="line">    m_top2 = m_maxsize;  <span class="comment">// 顺序栈2的栈顶指针为m_maxsize，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ShareStack&lt;T&gt;::~<span class="built_in">ShareStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSHARESTACK_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 共享栈 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyShareStack.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ShareStack&lt;<span class="type">int</span>&gt; <span class="title">shareobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">1</span>, <span class="number">150</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">1</span>, <span class="number">200</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">2</span>, <span class="number">1500</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">    shareobj.<span class="built_in">DisplayStack</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SharedStack.png" alt="SharedStack"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序栈</title>
      <link href="/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/"/>
      <url>/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>顺序栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySeqStack.h 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="type">int</span> length = InitSize);<span class="comment">// 构造函数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//入栈（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出栈（删除数据），也就是删除栈顶数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 读取栈顶元素，但该元素并没有出栈，而依旧是在栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispStack</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序栈中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;  <span class="comment">// 获取顺序栈的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序栈是否已满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;  <span class="comment">// 当顺序栈存满数据后可以调用此函数为顺序栈扩容</span></span><br><span class="line"></span><br><span class="line">    T* m_data;  <span class="comment">// 存放顺序栈中的元素</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;  <span class="comment">// 动态数组最大容量</span></span><br><span class="line">    <span class="type">int</span> m_top;  <span class="comment">// 栈顶指针（用作数组下标），指向栈顶元素，该值为-1表示空栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::<span class="built_in">SeqStack</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];  <span class="comment">// 为一维数组动态分配内存，该值和算法空间复杂度无关。</span></span><br><span class="line">    <span class="comment">// 空间复杂度一般指的是，算法额外需要的存储空间</span></span><br><span class="line">    m_top = <span class="number">-1</span>;  <span class="comment">// -1 代表空栈</span></span><br><span class="line">    m_maxsize = length;  <span class="comment">// 顺序栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序栈进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::~<span class="built_in">SeqStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈（增加数据） 通常时间复杂度为O(1)，但一旦栈满了，就需要扩容，时间复杂度就变为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 栈已经满了，需要扩容</span></span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;顺序栈已满，无法进行入栈操作了!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">        <span class="built_in">IncreaseSize</span>();  <span class="comment">// 扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_top++;  <span class="comment">// 栈顶指针向后走</span></span><br><span class="line">    m_data[m_top] = e;</span><br><span class="line">    <span class="comment">// 或者写成  m_data[++m_top] = e;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当顺序栈存满数据后可以调用此函数为顺序栈扩容, 时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T* p = m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[m_maxsize + IncSize];<span class="comment">// 重新为顺序栈分配更大的内存空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m_top; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = p[i];  <span class="comment">// 将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_maxsize = m_maxsize + IncSize;<span class="comment">// 顺序栈最大长度增加 IncSize;</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈（删除数据），也就是删除栈顶数据  时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_top];  <span class="comment">// 栈顶元素返回到e中</span></span><br><span class="line">    <span class="comment">// 有的实现版本不会在Pop成员函数中返回栈顶元素，此时要取得栈顶元素，就得通过GetTop成员函数取得</span></span><br><span class="line">    --m_top;</span><br><span class="line">    <span class="comment">// 代码合并  e = m_data[m_top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取栈顶元素，但该元素并没有出栈，而依旧是在栈中   时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_top];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序栈中所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">DispStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从栈顶到栈底的顺序显示数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m_top; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序栈的长度（实际拥有的元素数量） 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序栈是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序栈是否已满</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top &gt;= m_maxsize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqStack.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SeqStack&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">150</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">200</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">300</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">400</span>);</span><br><span class="line">    seqobj.<span class="built_in">DispStack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    seqobj.<span class="built_in">DispStack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqQueue.png" alt="SeqQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 静态链表</title>
      <link href="/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/"/>
      <url>/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>静态链表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTATICLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTATICLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 201</span></span><br><span class="line"><span class="comment">// 静态链表的尺寸，可以根据实际需要设定该值，可用数组下标 0 - 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点使用情况，枚举标记值</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">NODEUSE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这些枚举值都给负值，以免和数组下标(从0开始的正值)冲突</span></span><br><span class="line">    e_NOUSE = <span class="number">-1</span>,<span class="comment">// 未使用(未用)</span></span><br><span class="line">    e_LAST = <span class="number">-2</span>,<span class="comment">// 最后一个节点(末尾)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 元素数据域，存放数据元素</span></span><br><span class="line">    <span class="type">int</span> cur;<span class="comment">// 游标，记录下个静态链表节点的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StaticLinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">StaticLinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findAnIdlePos</span><span class="params">()</span></span>; <span class="comment">// 找到一个空闲位置用于保存数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 在第i个位置插入指定元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelte</span><span class="params">(<span class="type">int</span> i)</span></span>;  <span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;  <span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 按元素值查找其在静态链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;  <span class="comment">// 输出静态链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;  <span class="comment">// 获取静态链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;  <span class="comment">// 判断静态链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; m_data[MaxSize];  <span class="comment">// 保存节点数据的数组</span></span><br><span class="line">    <span class="type">int</span> m_length; <span class="comment">// 当前长度，也就是当前保存的数据节点数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对静态链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">StaticLinkList&lt;T&gt;::<span class="built_in">StaticLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MaxSize; ++i)</span><br><span class="line">    &#123;<span class="comment">// 从下标1开始的节点用于保存实际的数据，这些节点的curr有必要设置值，而头结点其实不用给任何值</span></span><br><span class="line">        m_data[i].cur = e_NOUSE;</span><br><span class="line">    &#125;</span><br><span class="line">    m_length = <span class="number">0</span>;  <span class="comment">// 还未向其中存入任何数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在m_data中找到一个空闲位置用于保存数据,若没找到(静态链表满了)就返回-1</span></span><br><span class="line"><span class="comment">// (插入数据的辅助函数)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">findAnIdlePos</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MaxSize; ++i)  </span><br><span class="line">    &#123;<span class="comment">// 因为下标0是头结点，不能用于保存数据，所以循环变量从1开始</span></span><br><span class="line">        <span class="keyword">if</span> (m_data[i].cur == e_NOUSE)  <span class="comment">// 未使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第iPos个位置(编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> iPos, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (iPos &lt; <span class="number">1</span> || iPos &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;不合法，合法位置是: [1 - &quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;] !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> iIdx;</span><br><span class="line">    <span class="keyword">if</span> ((iIdx = <span class="built_in">findAnIdlePos</span>()) == <span class="number">-1</span>)  <span class="comment">// 静态链表满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表已满!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然需要在第iPos位置插入元素，那么肯定需要找到iPos-1个位置</span></span><br><span class="line">    <span class="type">int</span> iDataCount = <span class="number">1</span>;  <span class="comment">// 统计静态链表中元素数量</span></span><br><span class="line">    <span class="type">int</span> iIdxPrev;   <span class="comment">// 保存第iPos-1个位置对应的m_data数组的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iPos == <span class="number">1</span>)   <span class="comment">// 向第一个位置插入元素，需要单独处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data[iIdx].data = e;</span><br><span class="line">        <span class="keyword">if</span> (m_length == <span class="number">0</span>)  <span class="comment">// 插入前是，空表</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[iIdx].cur = e_LAST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 非空表</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[iIdx].cur = m_data[<span class="number">0</span>].cur;  </span><br><span class="line">            <span class="comment">// 新插入的元素的游标指向原来头节点游标指向的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_data[<span class="number">0</span>].cur = iIdx;  <span class="comment">// 头节点的游标指向新插入的节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 插入位置不等于1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> iPosCount = <span class="number">0</span>;  <span class="comment">// 位置计数</span></span><br><span class="line">        <span class="type">int</span> tmpcur = m_data[<span class="number">0</span>].cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为前面已经判断过插入位置合法，所以一定可以扎到合适的位置</span></span><br><span class="line">            <span class="comment">// while(true)循环肯定可以正常退出</span></span><br><span class="line">            iPosCount++;</span><br><span class="line">            <span class="keyword">if</span> (iPosCount &gt;= (iPos - <span class="number">1</span>))  <span class="comment">// 找到了第iPos-1个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                iIdxPrev = tmpcur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpcur = m_data[tmpcur].cur;</span><br><span class="line">        &#125;  <span class="comment">// end while</span></span><br><span class="line">        <span class="type">int</span> iTmpCurr = m_data[iIdxPrev].cur;</span><br><span class="line">        m_data[iIdxPrev].cur = iIdx;</span><br><span class="line">        m_data[iIdx].data = e;</span><br><span class="line">        m_data[iIdx].cur = iTmpCurr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法获取数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1-&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="type">int</span> iPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iPos++;</span><br><span class="line">        <span class="keyword">if</span> (iPos == i)</span><br><span class="line">        &#123;</span><br><span class="line">            e = m_data[tmp_cur].data;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在静态链表中第一次出现的位置  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法获取数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="type">int</span> iPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iPos++;</span><br><span class="line">        <span class="keyword">if</span> (e == m_data[tmp_cur].data &amp;&amp; m_data[tmp_cur].cur != e_NOUSE)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;成功找到元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;在静态链表中的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> iPos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_data[tmp_cur].cur == e_LAST)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;在静态链表中没有找到!:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出静态链表中的所有元素 O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> StaticLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[tmp_cur].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((tmp_cur = m_data[tmp_cur].cur) == e_LAST)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态链表的长度  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断静态链表是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第iPos个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListDelte</span>(<span class="type">int</span> iPos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iPos &lt; <span class="number">1</span> || iPos &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;待删除的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1-&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur; <span class="comment">// 第一个数据节点的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> (iPos == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 删除第一个位置元素，要单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (m_length != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这个静态链表里有多个元素，那么</span></span><br><span class="line">            m_data[<span class="number">0</span>].cur = m_data[tmp_cur].cur; </span><br><span class="line">            <span class="comment">// 头结点指向第二个数据节点数组下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_data[tmp_cur].cur = e_NOUSE;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;的元素，该元素值为:&quot;</span> &lt;&lt; m_data[tmp_cur].data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 删除的不是第一个位置的元素</span></span><br><span class="line">        <span class="type">int</span> iIdxPrev;  <span class="comment">// 第iPos - 1个位置对应的m_data数组的下标</span></span><br><span class="line">        <span class="type">int</span> iPosCount = <span class="number">0</span>; <span class="comment">// 位置计数</span></span><br><span class="line">        <span class="comment">// 前面已经判断过删除位置合法，所以一定可以找到合适位置，while(true)循环肯定可以正常退出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iPosCount++;</span><br><span class="line">            <span class="keyword">if</span> (iPosCount &gt;= (iPos - <span class="number">1</span>))<span class="comment">// 找到了第i-1个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                iIdxPrev = tmp_cur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line">        <span class="type">int</span> iTmpCur = m_data[iIdxPrev].cur;<span class="comment">// 当前要删除的这个节点的数组下标</span></span><br><span class="line">        m_data[iIdxPrev].cur = m_data[iTmpCur].cur;<span class="comment">// 前一个系欸但的cur指向当前要删除节点的cur</span></span><br><span class="line">        m_data[iTmpCur].cur = e_NOUSE;<span class="comment">// 标记被删除数据节点的数组下标为未用状态</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;的元素，该元素值为:&quot;</span> &lt;&lt; m_data[iTmpCur].data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">StaticLinkList&lt;T&gt;::~<span class="built_in">StaticLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先暂时为空</span></span><br><span class="line">    <span class="comment">// 静态链表没有动态new空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSTATICLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyStaticLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StaticLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">5</span>, <span class="number">190</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">190</span>);</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">300</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">0</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">6</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">1</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">5</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">10</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">600</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">700</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/StaticLinkedList.png" alt="StaticLinkedList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 循环链表</title>
      <link href="/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/"/>
      <url>/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>循环链表的C++语言实现，模板方式。</p><span id="more"></span><h1 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单循环链表中每个节点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;       <span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;                <span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    Node&lt;T&gt;* next;         <span class="comment">// 指针域，指向下一个同类型(和本节点类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CirLinkList</span>();                   <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">CirLinkList</span>();                  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;    <span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;                <span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;    <span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;   <span class="comment">// 按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;              <span class="comment">// 输出单循环链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;             <span class="comment">// 获取单循环链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                 <span class="comment">// 判断单循环链表是否为空</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* m_head; <span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;    <span class="comment">// 单循环链表当前长度(当前有几个元素)，为编程更方便而引入的，但非必须</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对单循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    m_head-&gt;next = m_head;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要插入的位置，比如要在第2个位置插入，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next; </span><br><span class="line">    <span class="comment">// 让新节点链上后续链表，因为pcurr-&gt;next指向后续的链表节点</span></span><br><span class="line">    </span><br><span class="line">    p_curr-&gt;next = node; <span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length++;                                                     <span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next; </span><br><span class="line">        <span class="comment">// pcurr会找到当前要删除的位置所代表的节点的前一个节点的位置，比如要删除第2个位置的节点，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_curr-&gt;next;   <span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;   <span class="comment">// 第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length--;     <span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        e = p_curr-&gt;data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span> CirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;                                                      <span class="comment">// 返回-1表示查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出单循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != m_head)                                             <span class="comment">// 这里采用while循环或者for循环书写都可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;                                <span class="comment">// 每个数据之间以空格分隔</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;                                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span>  CirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_head-&gt;next == m_head)                                     <span class="comment">// 单循环链表为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对单循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::~<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">    Node&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != m_head)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;</span><br><span class="line">    m_head = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYCIRLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCirLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单循环链表</span></span><br><span class="line">    CirLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval); <span class="comment">//如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">100</span>; <span class="comment">//在单循环链表中要找的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单循环链表的长度为：&quot;</span> &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopLinkedList_1.png" alt="LoopLinkedList_1"></p><h1 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h1><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYDBLCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYDBLCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//双循环链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T        data;          <span class="comment">//数据域，存放数据元素</span></span><br><span class="line">    DblNode&lt;T&gt;* prior;      <span class="comment">//前趋指针，指向前一个同类型（和本节点类型相同）节点</span></span><br><span class="line">    DblNode&lt;T&gt;* next;       <span class="comment">//后继指针，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblCirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblCirLinkList</span>();     <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">DblCirLinkList</span>();    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;    <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;                <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;     <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;   <span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;               <span class="comment">//输出双循环链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;             <span class="comment">//获取双循环链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                  <span class="comment">//判断双循环链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;T&gt;* m_head;            </span><br><span class="line">    <span class="comment">//头指针（指向链表第一个节点的指针，如果链表有头结点则指向头结点）</span></span><br><span class="line">    <span class="type">int</span> m_length;                  </span><br><span class="line">    <span class="comment">//双循环链表当前长度（当前有几个元素），为编写程序更加方便和提高程序运行效率而引入，但不是必须引入</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对双循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblCirLinkList&lt;T&gt;::<span class="built_in">DblCirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> DblNode&lt;T&gt;;    <span class="comment">//先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = m_head;</span><br><span class="line">    m_head-&gt;prior = m_head;</span><br><span class="line">    m_length = <span class="number">0</span>;               <span class="comment">//头结点不计入双循环链表的长度     </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要插入的位置，比如要在第2个位置插入，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next; </span><br><span class="line">    <span class="comment">// 让新节点链上后续链表，因为pcurr-&gt;next指向后续的链表节点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;prior = p_curr;</span><br><span class="line">    <span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        p_curr-&gt;next-&gt;prior = node;</span><br><span class="line"></span><br><span class="line">    p_curr-&gt;next = node;   <span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length++;     <span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要删除的位置所代表的节点的前一个节点的位置，比如要删除第2个位置的节点，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_willdel = p_curr-&gt;next;   <span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    DblNode&lt;T&gt;* p_willdelNext = p_willdel-&gt;next; <span class="comment">// p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;  <span class="comment">// 第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_willdelNext != <span class="literal">nullptr</span>)</span><br><span class="line">        p_willdelNext-&gt;prior = p_curr;  <span class="comment">// 第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length--;       <span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        e = p_curr-&gt;data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span> DblCirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出双循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">void</span> DblCirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        DblNode&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != m_head)                                             <span class="comment">// 这里采用while循环或者for循环书写都可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;                                <span class="comment">// 每个数据之间以空格分隔</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span>  DblCirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_head-&gt;next == m_head)                                     <span class="comment">// 双循环链表为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对双循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblCirLinkList&lt;T&gt;::~<span class="built_in">DblCirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">    DblNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != m_head)                                         <span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;                                                  <span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;                                               <span class="comment">// 非必须</span></span><br><span class="line">    m_length = <span class="number">0</span>;                                                   <span class="comment">// 非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYDBLCIRLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblCirLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblCirLinkList&lt;<span class="type">int</span>&gt; sdblcirlinkobj;</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">2</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopLinkedList_2.png" alt="LoopLinkedList_2"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 双向链表</title>
      <link href="/2023/06/03/DataStructuresAndAlgorithms/003.DeList/"/>
      <url>/2023/06/03/DataStructuresAndAlgorithms/003.DeList/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>双向链表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYDBLLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYDBLLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，用于存放数据元素</span></span><br><span class="line">    DblNode&lt;T&gt;* prior; <span class="comment">// 前趋指针，指向前一个同类型(和本节点类型相同的)节点</span></span><br><span class="line">    DblNode&lt;T&gt;* next; <span class="comment">// 后继指针，指向下一个同类型(和本节点类型相同的)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblLinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">DblLinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(DblNode&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 通过已知节点之前插入新元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeletePriorNode</span><span class="params">(DblNode&lt;T&gt;* p_del)</span></span>;<span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出双链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispListAndAddr</span><span class="params">()</span></span>;<span class="comment">// 输出双链表中的所有元素并打印地址</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取双链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">// 判断双链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListReverse</span><span class="params">()</span></span>;<span class="comment">// 双链表的翻转操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DblNode&lt;T&gt;* <span class="title">GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DblNode&lt;T&gt;* p_tmp = m_head;</span><br><span class="line">        <span class="keyword">return</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;T&gt;* m_head;</span><br><span class="line">    <span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点，则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 双链表当前长度(当前有几个元素),</span></span><br><span class="line">    <span class="comment">// 为了编写程序更方便和提高程序运行效率而引入，但不是必须引入。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的翻转操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListReverse</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next-&gt;next;</span><br><span class="line">    m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    DblNode&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_curr!= <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_curr;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        p_tmp-&gt;prior = m_head;</span><br><span class="line">        p_tmp-&gt;next = m_head-&gt;next;</span><br><span class="line">        m_head-&gt;next-&gt;prior = p_tmp;</span><br><span class="line">        m_head-&gt;next = p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取双链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断双链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*if (m_length &lt; 1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    <span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="comment">// 如果是不带头节点的双链表，则用if(m_head == nullptr)来判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; i || i &gt;(m_length ))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中第一次出现的位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对双链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkList&lt;T&gt;::<span class="built_in">DblLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> DblNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 该值暂时为nullptr，因为还没有后继节点</span></span><br><span class="line">    m_head-&gt;prior = <span class="literal">nullptr</span>;<span class="comment">// 该值一直为nullptr</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 头结点不计入双链表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的元素插入操作  在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断插入的位置i是否合法，i的合法位置应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; (m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于扎到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头节点)</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next;</span><br><span class="line">    <span class="comment">// 让新节点链上后续节点，因为p_curr-&gt;next 指向后续的链表节点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;prior = p_curr;<span class="comment">// 新节点的前趋节点指向当前p_curr节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr-&gt;next-&gt;prior = node;<span class="comment">// 原p_curr的下一个节点的前趋指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p_curr-&gt;next = node;<span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;<span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过已知节点之前插入新元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">InsertPriorNode</span>(DblNode&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* new_node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    new_node-&gt;data = e;</span><br><span class="line">    new_node-&gt;next = p_curr;</span><br><span class="line">    new_node-&gt;prior = p_curr-&gt;prior;</span><br><span class="line">    p_curr-&gt;prior-&gt;next = new_node;</span><br><span class="line">    p_curr-&gt;prior = new_node;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出双链表中的所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>  DblLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;  </span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出双链表中的所有元素并打印地址</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>  DblLinkList&lt;T&gt;::<span class="built_in">DispListAndAddr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m_head:&quot;</span> &lt;&lt; m_head &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node :&quot;</span> &lt;&lt; i &lt;&lt; p_curr &lt;&lt; <span class="string">&quot;  value:&quot;</span> &lt;&lt; p_curr-&gt;data &lt;&lt; std::endl;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkList&lt;T&gt;::~<span class="built_in">DblLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_node = m_head-&gt;next;</span><br><span class="line">    DblNode&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_node != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_node;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;<span class="comment">// 非必须</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;<span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头结点)</span></span><br><span class="line">        p_curr = p_curr-&gt;next;  </span><br><span class="line">        <span class="comment">// p_curr会找到当前要删除的位置所代表的节点的前一个节点位置，</span></span><br><span class="line">        <span class="comment">// 比如要删除第2个位置的节点，p_curr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    DblNode&lt;T&gt;* p_willdelNext = p_willdel-&gt;next;</span><br><span class="line">    <span class="comment">// p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">    </span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">// 第i-1个节点的next指针指向第i+1节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_willdelNext != <span class="literal">nullptr</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        p_willdelNext-&gt;prior = p_curr;</span><br><span class="line">        <span class="comment">// 第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">DeletePriorNode</span>(DblNode&lt;T&gt;* p_del)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_del_prod = p_del-&gt;prior;</span><br><span class="line">    DblNode&lt;T&gt;* p_del_next = p_del-&gt;next;</span><br><span class="line">    p_del_prod-&gt;next = p_del_next;</span><br><span class="line">    <span class="keyword">if</span> (p_del_next)</span><br><span class="line">    &#123;</span><br><span class="line">        p_del_next-&gt;prior = p_del_prod;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除元素为:&quot;</span> &lt;&lt; p_del-&gt;data &lt;&lt; <span class="string">&quot;的节点!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p_del;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYDBLLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblLinkList&lt;<span class="type">int</span>&gt; sdbllinkobj;</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转双链表前打印元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispListAndAddr</span>();</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListReverse</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转双链表后打印元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispListAndAddr</span>();</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/DeList.png" alt="DeList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 单链表</title>
      <link href="/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/"/>
      <url>/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>单链表的<code>C++</code>语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    Node&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型(和本类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(Node&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeletePriorNode</span><span class="params">(Node&lt;T&gt;* p_del)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在单链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出单链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取单链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">// 判断单链表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;<span class="comment">// 翻转单链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt;* <span class="title">GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* m_head;<span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点，则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 单链表当前长度(当前有几个元素),</span></span><br><span class="line">    <span class="comment">// 为了编写程序更方便和提高程序运行效率而引入，但不是必须引入。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对单链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 头结点的指针域指向空</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 头结点不计入单链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不带头结点的单链表 </span></span><br><span class="line"><span class="comment">m_head = mullptr;</span></span><br><span class="line"><span class="comment">m_length = 0;  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带头节点的单链表插入操作</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断插入位置是否合法，i的合法值应该时从 1 到 m_length + 1 之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法,合法的位置是:[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">// j从0开始，表示p_curr更开始指向的是第0个节点(头结点)</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;<span class="comment">// p_curr会找到当前要插入的位置，</span></span><br><span class="line">        <span class="comment">// 比如要在第2个位置插入,p_curr最终会指向第1个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">// ①   创建新节点</span></span><br><span class="line">    node-&gt;data = e;<span class="comment">// ②</span></span><br><span class="line">    node-&gt;next = p_curr-&gt;next;<span class="comment">// ③   让新节点链上后续链表，因为p_curr-&gt;next指向的是后续链表的节点</span></span><br><span class="line">    p_curr-&gt;next = node;<span class="comment">// ④   让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;<span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 不带头结点的单链表插入操作</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e  【【仅供参考】】</span></span><br><span class="line"><span class="comment">template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">bool LinkList&lt;T&gt;::ListInsert(int i, const T&amp; e)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">// 判断插入位置是否合法，i的合法值应该时从 1 到 m_length + 1 之间</span></span><br><span class="line"><span class="comment">if (i &lt; 1 || i &gt;(m_length + 1))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;元素:&quot; &lt;&lt; e &lt;&lt; &quot;插入位置:&quot; &lt;&lt; i &lt;&lt; &quot;不合法,合法的位置是:[1~&quot; &lt;&lt; m_length + 1 &lt;&lt; &quot;]!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (i == 1)  // 插入到第一个位置与插入到其他位置不同，需要单独处理</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* node = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">node-&gt;data = e;</span></span><br><span class="line"><span class="comment">node-&gt;next = m_head;   // m_head原来指向的啥，就让新创建的 node(新的头结点)指向m_head</span></span><br><span class="line"><span class="comment">m_head = node;   // 头指针指向新插入的第一个节点</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;成功在位置为:&quot; &lt;&lt; i &lt;&lt; &quot;处插入元素:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">++m_length;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 插入的不是第一个位置，测程序流程继续向下走</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* p_curr = m_head;</span></span><br><span class="line"><span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt; (i - 1); ++j)  // j从1开始，表示p_curr刚开始指向的是第1个节点</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">p_curr = p_curr-&gt;next;</span></span><br><span class="line"><span class="comment"> // p_curr会找到当前要插入的位置，比如要在第2个位置插入，p_curr会指向第1个节点</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* node = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">node-&gt;data = e;</span></span><br><span class="line"><span class="comment">node-&gt;next = p_curr-&gt;next;  // 让新节点链上后续链表,因为p_curr-&gt;next指向的就是后续链表节点</span></span><br><span class="line"><span class="comment">p_curr-&gt;next = node;  // 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;成功在位置为:&quot; &lt;&lt; i &lt;&lt; &quot;处插入元素:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">++m_length;  // 实际长度+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现向某个已知节点之前插入新节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">InsertPriorNode</span>(Node&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在节点p_curr之前插入新节点，新节点数据域元素值为e</span></span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next;</span><br><span class="line">    p_curr-&gt;next = node;</span><br><span class="line">    node-&gt;data = p_curr-&gt;data;</span><br><span class="line">    p_curr-&gt;data = e;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表为空，无法删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;  </span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头结点)</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// p_curr会找到当前要删除的位置所代表的节点的前一个节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">// 第i-1个节点的next指针指向了第i+1个节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">DeletePriorNode</span>(Node&lt;T&gt;* p_del)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 思想：把要删除的节点的下一个节点数据域拷贝到当前要删除的节点，</span></span><br><span class="line">    <span class="comment">// 当前要删除的节点的指针域指向下一个节点的指针域指向的节点。</span></span><br><span class="line">    <span class="comment">// 这样就相当于把待删除的节点的下一个节点数据拷贝到了需要待删除的节点上。</span></span><br><span class="line">    <span class="comment">// 然后真正删除的是待删除节点的下一个节点，从而实现时间复杂度为O(1)</span></span><br><span class="line">    <span class="comment">// 删除p_del所指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_del-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 待删除的节点正好是最后一个节点,不能用这种方法删除，只能常规删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ListDelete</span>(m_length);</span><br><span class="line">    &#125;</span><br><span class="line">    p_del-&gt;data = p_del-&gt;next-&gt;data;<span class="comment">// 把待删除的下一个节点的数据保存到当前的需要删除节点的数据域</span></span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_del-&gt;next;<span class="comment">// 待删除的节点的下一个节点(真正要删除的节点)</span></span><br><span class="line">    p_del-&gt;next = p_willdel-&gt;next;</span><br><span class="line">    --m_length;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除节点元素值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;的节点!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表为空，无法获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在单链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p_curr-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中第一次出现的位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中不存在!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出单链表中的所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始打印单链表的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head-&gt;next;<span class="comment">// 直接略过头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p_curr!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;单链表元素打印结束!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// O(1)</span></span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断单链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// O(1)</span></span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  带头节点的还可以这样判断</span></span><br><span class="line"><span class="comment">if (m_head-&gt;next == nullptr)</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转单链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123; <span class="comment">// 这个不是针对数据域的翻转，而是整个节点的翻转</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表中的元素不超过1个，不用做任何翻转操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 至少有2个节点才会走到这里</span></span><br><span class="line">    Node&lt;T&gt;* pothersjd = m_head-&gt;next-&gt;next;<span class="comment">// 指向从第二个节点开始的后续节点</span></span><br><span class="line">    m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 把第一个节点的指针域先置空</span></span><br><span class="line">    Node&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (pothersjd != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = pothersjd;<span class="comment">// 当前需要移动的元素</span></span><br><span class="line">        pothersjd = pothersjd-&gt;next;<span class="comment">// 指向下一个需要移动的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ListInsert(1, p_tmp);// 这样也可以</span></span><br><span class="line">        p_tmp-&gt;next = m_head-&gt;next;</span><br><span class="line">        m_head-&gt;next = p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放单链表-析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* p_node = m_head-&gt;next;</span><br><span class="line">    Node&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_node != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_node;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;<span class="comment">//非必须，但是是个好习惯</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 长度置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main 主函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);<span class="comment">// 删除第四个位置的节点</span></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval);</span><br><span class="line">    <span class="comment">// 如果GetElem返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">100</span>;<span class="comment">// 在单链表中要找的元素值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单链表的长度:&quot;</span> &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单链表是否为空:&quot;</span> &lt;&lt; slinkobj.<span class="built_in">Empty</span>() &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SinglyLinkedList.png" alt="SinglyLinkedList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序表</title>
      <link href="/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/"/>
      <url>/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>顺序表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySeqList.h 文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>(<span class="type">int</span> length = InitSize);<span class="comment">// 构造函数，参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">SeqList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">// 接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获取第i个位置的元素，值通过形参引用方式返回</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出顺序表中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取顺序表长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;<span class="comment">// 反转顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;<span class="comment">// 当顺序表满了，扩容函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;<span class="comment">// 存放顺序表中的元素</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 当前长度</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;<span class="comment">// 最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::<span class="built_in">SeqList</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 顺序表当前长度为0，表示还没有存储任何元素</span></span><br><span class="line">    m_maxsize = length;<span class="comment">// 顺序表最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">    m_maxsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表元素插入</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(n)，时间开销主要是缘于元素的移动</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 如果数组表已经存在，则不允许再插入数据，当前先这样，后续课程再完善</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">IncreaseSize</span>();<span class="comment">// 存满了，扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断插入位置i是否合法，i的和法治应该时从1到m_length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;].&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从最后一个元素开始向前遍历到要插入新元素的第i个位置，</span></span><br><span class="line">    <span class="comment">// 分别将这些位置中原有的元素向后移动一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m_length; j &gt;= i; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[j] = m_data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[i - <span class="number">1</span>] = e;<span class="comment">// 在指定位置i出插入元素e，因为数组下标从0开始，所以这里用i-1表示插入位置所对应的数组下标</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)<span class="comment">// 空的元素表</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;空列表，无法进行删除操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从数组中第i+1个位置开始向后遍历所有元素，分别将这些位置中原有的元素向前移动一个位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m_length; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[j - <span class="number">1</span>] = m_data[j];<span class="comment">// 依次往前移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)<span class="comment">// 参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)<span class="comment">// 空的元素表</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;空列表，无法获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[i - <span class="number">1</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)<span class="comment">// 参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中第一次出现的位置为&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;<span class="comment">// 返回位置应该用数组 下标值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里，在该顺序表中没有找到对应的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表元素的其他常用操作</span></span><br><span class="line"><span class="comment">// 输出顺序表中所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">DispList</span>()  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取顺序表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转顺序表reverse，时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T temp;<span class="comment">// 中间变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length / <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = m_data[i];</span><br><span class="line">        m_data[i] = m_data[m_length - i - <span class="number">1</span>];  </span><br><span class="line">        <span class="comment">// 第一个和最后一个交换，依次往后走 第二个和倒数第二交换...</span></span><br><span class="line">        m_data[m_length - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表的扩展操作</span></span><br><span class="line"><span class="comment">// 当顺序表存满数据后可以调用此函数为顺序表扩容,时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T* p = m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[m_maxsize + IncSize];</span><br><span class="line">    <span class="comment">// 重新为顺序表分配更大的内存空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = p[i];<span class="comment">// 将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_maxsize += IncSize;<span class="comment">// 顺序表最大长度郑家IncSize</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MYSEQLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqList.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m_data[<span class="number">10</span>];  <span class="comment">// 静态数组来保存顺序表中的元素</span></span><br><span class="line">        <span class="comment">// 最多能存储10个元素</span></span><br><span class="line">        <span class="type">int</span> m_length;  <span class="comment">// 顺序表中当前实际长度(已存在的元素个数)</span></span><br><span class="line">    &#125; SeqList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* m_data; <span class="comment">// 顺序表中的元素保存在m_data所指向的动态数组内存中</span></span><br><span class="line">        <span class="type">int</span> m_length;  <span class="comment">// 顺序表中当前实际长度(已存在的元素个数)</span></span><br><span class="line">        <span class="type">int</span> m_maxsize;   <span class="comment">// 动态数组最大容量，因为动态数组可以扩容，因此要记录该值</span></span><br><span class="line">    &#125; SeqList_Dync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SeqList&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">30</span>, <span class="number">8</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListDelete</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> get_res = seqobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval);</span><br><span class="line">    <span class="comment">// 如果get_res值为true，则eval中保存着获取到的元素值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">10</span>;  <span class="comment">// 在顺序表中要找的元素值</span></span><br><span class="line">    <span class="type">int</span> find_res = seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    findvalue = <span class="number">22</span>;  <span class="comment">// 这里改为了22，表示查找值22这个元素的下标</span></span><br><span class="line">    find_res = seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line"></span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前顺序表中存在元素个数:&quot;</span> &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; std::endl;</span><br><span class="line">    seqobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        seqobj.<span class="built_in">ListInsert</span>(i, i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前顺序表中存在元素个数:&quot;</span> &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; std::endl;</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqList.png" alt="SeqList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 导航栏</title>
      <link href="/2023/05/31/DataStructuresAndAlgorithms/000.DataStructersAndAlgorithmsIndex/"/>
      <url>/2023/05/31/DataStructuresAndAlgorithms/000.DataStructersAndAlgorithmsIndex/</url>
      
        <content type="html"><![CDATA[<p><strong>快速导航</strong></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/001.SeqList/">数据结构与算法 – 顺序表</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/002.SinglyLinkedList/">数据结构与算法 – 单链表</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/003.DeList/">数据结构与算法 – 双链表</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/004.LoopLinkedList/">数据结构与算法 – 循环链表</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/005.StaticLinkedList/">数据结构与算法 – 静态链表</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/006.SeqStack/">数据结构与算法 – 顺序栈</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/007.SharedStack/">数据结构与算法 – 共享栈</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/008.LinkedStack/">数据结构与算法 – 链式栈</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/009.SeqQueue/">数据结构与算法 – 顺序队列</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/010.LinkedQueue/">数据结构与算法 – 链式队列</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/011.LinkedDequeue/">数据结构与算法 – 双端队列</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/012.LoopQueue/">数据结构与算法 – 循环队列</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/">数据结构与算法 – 二叉树(顺序存储)</a></p><p><a href="https://brkzh.github.io/2024/01/01/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/">数据结构与算法 – 二叉树(链式存储)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏服务器与客户端</title>
      <link href="/2022/06/22/Adventure_Road/"/>
      <url>/2022/06/22/Adventure_Road/</url>
      
        <content type="html"><![CDATA[<p>卡牌游戏Demo</p><span id="more"></span><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>说明：服务器使用C++语言开发，使用到了epoll高并发通讯技术，线程池处理业务逻辑，MySQL存储用户数据，定时心跳包检测，服务器安全（畸形数据包识别并处理、恶意客户端识别并处理）等等。<br>服务器使用 “主服务器+游戏服务器”的程序架构。<br>主服务器负责一些基本的业务逻辑，如账号注册、账号登录验证1、修改密码、忘记密码功能。<br>游戏服务器负责一些游戏相关的业务，账号登录验证2、游戏逻辑等。</p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/serverRun.png" alt="服务器运行"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/mainServerSpLogicFunc.png" alt="主服务器业务逻辑相关函数"></p><p>后期如果需要扩展业务逻辑，只需要在statusHandler数组里面添加相应的函数，同时约定好对应的消息码，然后实现相应函数即可完成对业务逻辑的扩充。</p><p>游戏服务器的相关业务逻辑就不展示了。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端使用Unity-3D开发引擎，搭配C#语言，开发一个2D战棋游戏。<br>客户端（C#）和服务器（C++）的通讯，是使用自己封装的Dll库来实现的。<br>下面的图片是客户端的部分界面的截图。</p><h3 id="账号登录"><a href="#账号登录" class="headerlink" title="账号登录"></a>账号登录</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/clientLoginPage.png" alt="客户端登录界面"></p><h3 id="账号注册"><a href="#账号注册" class="headerlink" title="账号注册"></a>账号注册</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage1.png" alt="注册界面1"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage2.png" alt="注册界面2"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage3.png" alt="注册界面3"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage4.png" alt="注册界面4"><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emailVerify.jpg" alt="邮箱验证码 (2)"></p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager1.png" alt="密码管理-1"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager_forget.png" alt="密码管理-忘记密码"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager_Modify.png" alt="密码管理-修改密码"></p><h3 id="登录后主界面"><a href="#登录后主界面" class="headerlink" title="登录后主界面"></a>登录后主界面</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/loginedMainPage.png" alt="登录后的主界面"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/clientMain_SettingPage.png" alt="客户端登录界面-设置菜单"></p><h2 id=""><a href="#" class="headerlink" title="."></a>.</h2><p>游戏还不是很完善，游戏的玩法正在开发中。</p><p>敬请期待…</p><h3 id="客户端下载链接"><a href="#客户端下载链接" class="headerlink" title="客户端下载链接"></a>客户端下载链接</h3><p>客户端配置文件<code>Adventure_Road.conf</code>，在程序的根目录</p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/Adventure_Road_conf.png" alt="image-20230918225002524"></p><p>给配置文件配置主服务器的<code>ip</code>地址和端口号。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器IP地址</span></span><br><span class="line"><span class="attr">MasterServerAddr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># 服务器端口</span></span><br><span class="line"><span class="attr">MasterServerPort</span> = <span class="number">35300</span></span><br></pre></td></tr></table></figure><p>百度网盘链接：</p><p>链接：<a href="https://pan.baidu.com/s/1Fl9mRH0gFj3PmATxoGVZDA">https://pan.baidu.com/s/1Fl9mRH0gFj3PmATxoGVZDA</a><br>提取码：mxzl</p><p>115网盘链接：</p><p><a href="https://115.com/s/sw6c6sv36eu?password=mxzl&#">https://115.com/s/sw6c6sv36eu?password=mxzl&amp;#</a><br>Adventure_Road_Client.0906.R.zip<br>访问码:mxzl</p><p>夸克网盘：<br>链接：<a href="https://pan.quark.cn/s/e868fc0d4e38">https://pan.quark.cn/s/e868fc0d4e38</a><br>提取码：XmHH</p><h3 id="服务器下载链接"><a href="#服务器下载链接" class="headerlink" title="服务器下载链接"></a>服务器下载链接</h3><p>服务器，笔者制作了<code>docker</code>镜像，下载后导入镜像，创建容器后就可以使用了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">导入镜像</span><br><span class="line">docker import - mxzl_demo_image &lt; mxzlDemoImage.tar </span><br><span class="line">这样就把，mxzlDemoImage.tar导入了，镜像名字为mxzl_demo_image</span><br><span class="line"></span><br><span class="line">创建容器</span><br><span class="line">docker run --name mxzl_demo_env -itd -p 35300:35300 -p 39300:39300 mxzl_demo_image  /bin/bash</span><br><span class="line">这样就创建了容器mxzl_demo_env</span><br><span class="line"></span><br><span class="line">启动容器</span><br><span class="line">docker start mxzl_demo_env</span><br><span class="line"></span><br><span class="line">进入已启动的容器</span><br><span class="line">docker <span class="built_in">exec</span> -it mxzl_demo_env /bin/bash</span><br><span class="line"></span><br><span class="line">启动脚本，启动数据库、启动游戏服务器</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">./startDemo.sh </span><br><span class="line"></span><br><span class="line">数据库已经有了测试账号，服务器运行起来后可以直接登录使用</span><br><span class="line">账号：brkzh</span><br><span class="line">密码：brkzh</span><br><span class="line"></span><br><span class="line">如果需要注册账号等，需要启用验证码功能，那么就需要改主服务器的配置文件：</span><br><span class="line">vim /home/mxzl/MasterServer.conf</span><br><span class="line">需要更改 [E-Mail]节点的 sendUser、sendPass等配置项</span><br></pre></td></tr></table></figure><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/vim_config.png" alt="image-20230918222156628"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emainConfig.png" alt="image-20230918222222613"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emainConfig2.png" alt="image-20230918222233795"></p><p>百度网盘链接：</p><p>链接：<a href="https://pan.baidu.com/s/1wLpDleYBLlprs58rPv-ZFA">https://pan.baidu.com/s/1wLpDleYBLlprs58rPv-ZFA</a><br>提取码：mxzl</p><p>夸克网盘：<br>链接：<a href="https://pan.quark.cn/s/a914ea04c026">https://pan.quark.cn/s/a914ea04c026</a><br>提取码：7GNC</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
