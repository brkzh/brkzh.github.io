<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>获取当前时间戳 -- 【Demo】</title>
      <link href="/2024/05/01/C_CPlusPlus/GetCurrentTimeDemo/"/>
      <url>/2024/05/01/C_CPlusPlus/GetCurrentTimeDemo/</url>
      
        <content type="html"><![CDATA[<h1 id="获取时间戳例子"><a href="#获取时间戳例子" class="headerlink" title="获取时间戳例子"></a>获取时间戳例子</h1><p><code>C++11</code>及以上版本使用。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> CInt64;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">eTimeType</span> &#123;</span><br><span class="line">eHours = <span class="number">0</span>,</span><br><span class="line">eMinutes = <span class="number">1</span>,</span><br><span class="line">eSecond = <span class="number">2</span>,</span><br><span class="line">eMilliseconds = <span class="number">3</span>, <span class="comment">//毫秒</span></span><br><span class="line">eMicroseconds = <span class="number">4</span>, <span class="comment">//微秒</span></span><br><span class="line">eNanoseconds = <span class="number">5</span>   <span class="comment">//纳秒</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">DemoTest_GetTimeStampString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CInt64 <span class="title">DemoTest_GetTimeStamp</span><span class="params">(eTimeType eType<span class="comment">/* = eMilliseconds*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout&lt;&lt;<span class="built_in">DemoTest_GetTimeStampString</span>()&lt;&lt;std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">DemoTest_GetTimeStamp</span>(eMilliseconds) &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CInt64 <span class="title">DemoTest_GetTimeStamp</span><span class="params">(eTimeType eType<span class="comment">/* = eMilliseconds*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CInt64 nRet = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (eType == eHours)</span><br><span class="line">nRet = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::hours&gt;(std::chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eType == eMinutes)</span><br><span class="line">nRet = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(std::chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eType == eSecond)</span><br><span class="line">nRet = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(std::chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eType == eMilliseconds)</span><br><span class="line">nRet = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eType == eMicroseconds)</span><br><span class="line">nRet = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(std::chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eType == eNanoseconds)</span><br><span class="line">nRet = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(std::chrono::system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">return</span> nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">DemoTest_GetTimeStampString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取当前时间点</span></span><br><span class="line"><span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为time_t以便进一步转换为tm结构</span></span><br><span class="line">std::<span class="type">time_t</span> now_time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为tm结构</span></span><br><span class="line">std::tm* now_tm = std::<span class="built_in">localtime</span>(&amp;now_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用std::chrono::duration来获取微秒</span></span><br><span class="line"><span class="keyword">auto</span> microseconds = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(now.<span class="built_in">time_since_epoch</span>()) % std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出日期和时间，包括微秒</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; std::put_time(now_tm, &quot;%Y-%m-%d %X&quot;) &lt;&lt; &quot;.&quot; &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; std::setw(6) &lt;&lt; microseconds.count() &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//2024-07-12 09:44:24.694814</span></span><br><span class="line">std::ostringstream oss;</span><br><span class="line">oss &lt;&lt; std::<span class="built_in">put_time</span>(now_tm, <span class="string">&quot;%Y-%m-%d %X&quot;</span>) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; microseconds.<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ostringstream进行格式化</span></span><br><span class="line"><span class="comment">/*std::ostringstream oss;</span></span><br><span class="line"><span class="comment">oss &lt;&lt; (now_tm-&gt;tm_year + 1900) &lt;&lt; &#x27;-&#x27;</span></span><br><span class="line"><span class="comment">&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; (now_tm-&gt;tm_mon + 1) &lt;&lt; &#x27;-&#x27;</span></span><br><span class="line"><span class="comment">&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; now_tm-&gt;tm_mday &lt;&lt; &#x27; &#x27;</span></span><br><span class="line"><span class="comment">&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; now_tm-&gt;tm_hour &lt;&lt; &#x27;:&#x27;</span></span><br><span class="line"><span class="comment">&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; now_tm-&gt;tm_min &lt;&lt; &#x27;:&#x27;</span></span><br><span class="line"><span class="comment">&lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; now_tm-&gt;tm_sec;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tcp服务器客户端 -- 【Demo】</title>
      <link href="/2024/05/01/C_CPlusPlus/TcpServerClientDemo/"/>
      <url>/2024/05/01/C_CPlusPlus/TcpServerClientDemo/</url>
      
        <content type="html"><![CDATA[<p><a href="#Tcp%E6%9C%8D%E5%8A%A1%E5%99%A8">Tcp服务器</a></p><p><a href="#Tcp%E5%AE%A2%E6%88%B7%E7%AB%AF">Tcp客户端</a></p><span id="more"></span><h1 id="Tcp服务器"><a href="#Tcp服务器" class="headerlink" title="Tcp服务器"></a>Tcp服务器</h1><h2 id="Win系统"><a href="#Win系统" class="headerlink" title="Win系统"></a>Win系统</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;WS2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 54000</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Usage</span><span class="params">(<span class="type">char</span>* proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; proc &lt;&lt; <span class="string">&quot; Port&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitAndListern</span><span class="params">(SOCKET&amp; sListen, u_short sPort = PORT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    sockaddr_in local;</span><br><span class="line">    WORD version = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">WSAStartup</span>(version, &amp;wsaData);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;WSAStarup failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local.sin_family = AF_INET;</span><br><span class="line">    local.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    local.sin_port = <span class="built_in">htons</span>((u_short)sPort);</span><br><span class="line"></span><br><span class="line">    sListen = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sListen == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Initial socket failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(sListen, (sockaddr*)&amp;local, <span class="built_in">sizeof</span>(local)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bind socket failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(sListen, <span class="number">10</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listen socket failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_short sPort = PORT;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;IF USE DEFAULT PORT:&quot;</span> &lt;&lt; PORT &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\tYes: 1\n\tNo: 0\n\tExit: Other\n\tPlease Input You Choode:&gt;&gt;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> nChoose = <span class="number">0</span>;</span><br><span class="line">        std::cin &gt;&gt; nChoose;</span><br><span class="line">        <span class="keyword">if</span> (nChoose != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sPort = (u_short)<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    SOCKET sListen;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">InitAndListern</span>(sListen, sPort) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server wait for client connect...\n&quot;</span>);</span><br><span class="line">    fd_set fdSocket;</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;fdSocket);</span><br><span class="line">    <span class="built_in">FD_SET</span>(sListen, &amp;fdSocket);<span class="comment">//将sListen添加进该集合</span></span><br><span class="line">    <span class="type">int</span> nBuffSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[nBuffSize];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set fdRead = fdSocket;</span><br><span class="line">        <span class="type">int</span> nRet = <span class="built_in">select</span>(<span class="literal">NULL</span>, &amp;fdRead, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nRet &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)fdSocket.fd_count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fdSocket.fd_array[i], &amp;fdRead))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fdSocket.fd_array[i] == sListen)</span><br><span class="line">                &#123;</span><br><span class="line">                    sockaddr_in addrRemote;</span><br><span class="line">                    <span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(addrRemote);</span><br><span class="line">                    SOCKET sNew = ::<span class="built_in">accept</span>(sListen, (sockaddr*)&amp;addrRemote, &amp;nAddrLen);</span><br><span class="line">                    <span class="built_in">FD_SET</span>(sNew, &amp;fdSocket);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Clietn %s fd:%u connected\n\n&quot;</span>, <span class="built_in">inet_ntoa</span>(addrRemote.sin_addr), sNew);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//memset(buffer, 0, nBuffSize);</span></span><br><span class="line">                    <span class="type">int</span> nRecev = <span class="built_in">recv</span>(fdSocket.fd_array[i], buffer, nBuffSize, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nRecev &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//printf(&quot;Received Client Msg:%s\n&quot;, buffer);</span></span><br><span class="line">                        <span class="comment">//send(fdSocket.fd_array[i], buffer, strlen(buffer), 0);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nRecev == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Client fd:%u Close Connection\n\n&quot;</span>, fdSocket.fd_array[i]);</span><br><span class="line">                        <span class="built_in">closesocket</span>(fdSocket.fd_array[i]);</span><br><span class="line">                        <span class="built_in">FD_CLR</span>(fdSocket.fd_array[i], &amp;fdSocket);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Error fd:%u Close Connection\n\n&quot;</span>, fdSocket.fd_array[i]);</span><br><span class="line">                        <span class="built_in">closesocket</span>(fdSocket.fd_array[i]);</span><br><span class="line">                        <span class="built_in">FD_CLR</span>(fdSocket.fd_array[i], &amp;fdSocket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h2><p><strong>MySocket.hpp头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSOCKET_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSOCKET_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> ns_Sock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Sock</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Socket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (sock &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cerr &lt;&lt; <span class="string">&quot;创建套接字失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> sock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Listen</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">listen</span>(sock, <span class="number">5</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cerr &lt;&lt; <span class="string">&quot;listen error&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Accept</span><span class="params">(<span class="type">int</span> sock)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> peer;</span><br><span class="line">            <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line">            <span class="type">int</span> fd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;peer, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> fd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">int</span> sock, <span class="type">uint16_t</span> port)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            sockaddr_in local;</span><br><span class="line">            local.sin_family = AF_INET;</span><br><span class="line">            local.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">            local.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;local, <span class="built_in">sizeof</span>(local)) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cerr &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">int</span> sock, string ip, <span class="type">uint16_t</span> port)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="built_in">sizeof</span>(server));</span><br><span class="line">            server.sin_family = AF_INET;</span><br><span class="line">            server.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">            server.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;server, <span class="built_in">sizeof</span>(server)) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;connect success!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;connect fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSOCKET_HPP__</span></span></span><br></pre></td></tr></table></figure><p><strong>Main.cpp源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySocket.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns_Sock;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM (sizeof(fd_set) * 8)</span></span><br><span class="line"><span class="type">int</span> fd_array[NUM]; <span class="comment">//全局，如果是-1则没有fd</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Usage</span><span class="params">(<span class="type">char</span>* proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; proc &lt;&lt; <span class="string">&quot;Port&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Usage</span>(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint16_t</span> port = (<span class="type">uint16_t</span>)<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> listen_sock = Sock::<span class="built_in">Socket</span>();</span><br><span class="line">    Sock::<span class="built_in">Bind</span>(listen_sock, port);</span><br><span class="line">    Sock::<span class="built_in">Listen</span>(listen_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_array[i] = <span class="number">-1</span>; <span class="comment">//将存放fd的数组进行初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    fd_array[<span class="number">0</span>] = listen_sock;</span><br><span class="line">    <span class="type">int</span> max_fd = fd_array[<span class="number">0</span>];</span><br><span class="line">    fd_set rfds;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;rfds);</span><br><span class="line">        <span class="comment">//找出最大的fd作为select的参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd_array[i] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//说明不是用户关心的文件描述符</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">FD_SET</span>(fd_array[i], &amp;rfds); <span class="comment">//要关心的fd添加到rfds中</span></span><br><span class="line">            <span class="keyword">if</span> (max_fd &lt; fd_array[i])</span><br><span class="line">            &#123;</span><br><span class="line">                max_fd = fd_array[i]; <span class="comment">//更新最大的fd</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">timeval</span> timeout = &#123; <span class="number">5</span>, <span class="number">0</span> &#125;;                              <span class="comment">//设为5s超时</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">select</span>(max_fd + <span class="number">1</span>, &amp;rfds, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>); <span class="comment">//进行阻塞等待</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;select error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;select timeout&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;有fd对应的事件就绪了&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd_array[i] == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//下面的是合法的但不一定就绪</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(fd_array[i], &amp;rfds)) <span class="comment">//判读文件描述符是否被设置了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fd_array[i] == listen_sock)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;有新链接链接上来&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="type">int</span> sock = Sock::<span class="built_in">Accept</span>(listen_sock);</span><br><span class="line">                        <span class="keyword">if</span> (sock &gt;= <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            cout &lt;&lt; <span class="string">&quot;新链接创建成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">                            <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (pos = <span class="number">1</span>; pos &lt; NUM; pos++)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> (fd_array[pos] == <span class="number">-1</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//找到了一个位置还没有被使用</span></span><br><span class="line">                            <span class="keyword">if</span> (pos &lt; NUM)</span><br><span class="line">                            &#123;</span><br><span class="line">                                cout &lt;&lt; <span class="string">&quot;新链接&quot;</span> &lt;&lt; sock &lt;&lt; <span class="string">&quot;已经被填到了数组[&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;]的位置&quot;</span> &lt;&lt; endl;</span><br><span class="line">                                fd_array[pos] = sock;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                cout &lt;&lt; <span class="string">&quot;服务器满载了&quot;</span> &lt;&lt; endl;</span><br><span class="line">                                <span class="built_in">close</span>(sock);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//普通文件描述符</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;sock:&quot;</span> &lt;&lt; fd_array[i] &lt;&lt; <span class="string">&quot;上面有普通的读取&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="type">char</span> recv_buffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                        <span class="type">ssize_t</span> s = <span class="built_in">recv</span>(fd_array[i], recv_buffer, <span class="built_in">sizeof</span>(recv_buffer) - <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//虽然这里设为1但是不会发生阻塞，因为select已经阻塞完了</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            recv_buffer[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                            cout &lt;&lt; <span class="string">&quot;client[&quot;</span> &lt;&lt; fd_array[i] &lt;&lt; <span class="string">&quot;]#&quot;</span> &lt;&lt; recv_buffer &lt;&lt; endl;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)<span class="comment">//说明对端关闭了</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            cout &lt;&lt; <span class="string">&quot;sock&quot;</span> &lt;&lt; fd_array[i] &lt;&lt; <span class="string">&quot;客户端关闭了&quot;</span> &lt;&lt; endl;</span><br><span class="line">                            <span class="built_in">close</span>(fd_array[i]);</span><br><span class="line">                            fd_array[i] = <span class="number">-1</span>;</span><br><span class="line">                            cout &lt;&lt; <span class="string">&quot;已经在fd_array[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]中去掉了&quot;</span> &lt;&lt; fd_array[i] &lt;&lt; endl;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//读取失败</span></span><br><span class="line">                            <span class="built_in">close</span>(fd_array[i]);</span><br><span class="line">                            std::cout &lt;&lt; <span class="string">&quot;已经在数组下标fd_array[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;中,去掉了sock: &quot;</span> &lt;&lt; fd_array[i] &lt;&lt; std::endl;</span><br><span class="line">                            fd_array[i] = <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tcp客户端"><a href="#Tcp客户端" class="headerlink" title="Tcp客户端"></a>Tcp客户端</h1><p><strong>Main.cpp源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PORT 55559</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IP_ADDRESS <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WSADATA  Ws;</span><br><span class="line">SOCKET CientSocket;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> ServerAddr;</span><br><span class="line"><span class="type">int</span> Ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> AddrLen = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span> SendBuffer[MAX_PATH];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Init Windows Socket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;Ws) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Init Windows Socket Failed::&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create Socket</span></span><br><span class="line">CientSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (CientSocket == INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Create Socket Failed::&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerAddr.sin_family = AF_INET;</span><br><span class="line">ServerAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(IP_ADDRESS);</span><br><span class="line">ServerAddr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line"><span class="built_in">memset</span>(ServerAddr.sin_zero, <span class="number">0x00</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">Ret = <span class="built_in">connect</span>(CientSocket, (<span class="keyword">struct</span> sockaddr*)&amp;ServerAddr, <span class="built_in">sizeof</span>(ServerAddr));</span><br><span class="line"><span class="keyword">if</span> (Ret == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Connect Error::&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;连接成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin.<span class="built_in">getline</span>(SendBuffer, <span class="built_in">sizeof</span>(SendBuffer));</span><br><span class="line">Ret = <span class="built_in">send</span>(CientSocket, SendBuffer, (<span class="type">int</span>)<span class="built_in">strlen</span>(SendBuffer), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (Ret == SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Send Info Error::&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">closesocket</span>(CientSocket);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置文件加载 -- C++</title>
      <link href="/2024/01/01/C_CPlusPlus/ConfigurationFileLoading_Demo/"/>
      <url>/2024/01/01/C_CPlusPlus/ConfigurationFileLoading_Demo/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h1><p>单例类实现配置文件的加载。<code>Linux</code>下环境能直接运行，如果要在<code>Win</code>平台运行，部分地方需要做点小调整。</p><span id="more"></span><h1 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是注释行，</span></span><br><span class="line"><span class="comment">#每个有效配置项用 等号 处理，等号前不超过40个字符，等号后不超过400个字符；</span></span><br><span class="line"><span class="comment">#I love Cina，中华民族是世界上最伟大的民族！加油啊，兄弟们。</span></span><br><span class="line"><span class="comment">#感谢。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[开头的表示组信息，也等价于注释行</span></span><br><span class="line"><span class="comment">#[Socket]</span></span><br><span class="line"><span class="comment">#ListenPort = 5678    </span></span><br><span class="line"><span class="comment">#DBInfo = 127.0.0.1;1234;myr;123456;mxdb_g</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Server]</span></span><br><span class="line"><span class="comment">#ServerID代表本服务器ID，以标识自己</span></span><br><span class="line"><span class="attr">ServerName</span>=</span><br><span class="line">Name=</span><br><span class="line"></span><br><span class="line"><span class="comment">#日志相关</span></span><br><span class="line"><span class="section">[Log]</span></span><br><span class="line"><span class="comment">#日志文件输出目录和文件名</span></span><br><span class="line"><span class="comment">#Log=logs/error.log</span></span><br><span class="line"><span class="attr">Log</span>=error.log</span><br><span class="line"><span class="comment">#开开心心学习，顺其自然。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#只打印日志等级&lt;= 数字 的日志到日志文件中 ，日志等级0-8,0级</span></span><br><span class="line"><span class="attr">Csdn</span>=Chinese_Style</span><br><span class="line"></span><br><span class="line"><span class="comment">#进程相关</span></span><br><span class="line"><span class="section">[Proc]</span></span><br><span class="line"><span class="comment">#处理接收到的消息的线程池中线程数量，不建议超过300</span></span><br><span class="line"><span class="attr">ProcMsgRecvWorkThreadCount</span> = <span class="number">185</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#和网络相关</span></span><br><span class="line"><span class="section">[Net]</span></span><br><span class="line"><span class="comment">#监听的端口数量，一般都是1个，当然如果支持多于一个也是可以的</span></span><br><span class="line"><span class="attr">ListenPortCount</span> =<span class="number">185</span></span><br><span class="line"><span class="comment">#ListenPort+数字【数字从0开始】，这种ListenPort开头的项有几个，取决于ListenPortCount的数量，</span></span><br><span class="line"><span class="comment">#ListenPort 0==80</span></span><br><span class="line"><span class="attr">ListenPort1</span> == <span class="number">443</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#epoll连接的最大数【是每个worker进程允许连接的客户端数00000001】，实际其中有一些连接要被监听socket使用，实际允许的客户端连接数会比这个数小一些</span></span><br><span class="line"><span class="attr">worker_connections</span> = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Sock_RecyConnectionWaitTime:为确保系统稳定socket关闭后资源不会立即收回，而要等一定的秒数，在这个秒数之后，才进行资源/连接的回收</span></span><br><span class="line"><span class="attr">Sock_RecyConnectionWaitTime</span> = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Sock_WaitTimeEnable：是否开启踢人时钟，1：开启   0：不开启</span></span><br><span class="line"><span class="attr">Sock_WaitTimeEnable</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#多少秒检测一次是否 心跳超时，只有当Sock_WaitTimeEnable = 1时，本项才有用</span></span><br><span class="line"><span class="attr">Sock_MaxWaitTime</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">#当时间到达Sock_MaxWaitTime指定的时间时，直接把客户端踢出去，只有当Sock_WaitTimeEnable = 1时，本项才有用</span></span><br><span class="line"><span class="comment">#因为gameserver也要连接到本服务器，所以不能轻易踢人哦。</span></span><br><span class="line"><span class="attr">Sock_TimeOutKick</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[GameServerInfo]</span></span><br><span class="line"><span class="comment">#所有要连入到本服务器的GameServer信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一共允许这些个GameServer连入</span></span><br><span class="line"><span class="attr">AllowConnInGameServerCount</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#格式为：GameServer的唯一编号;对应的ip地址，域名（之所以引进域名是因为ipv6的getaddrinfo解析ipv4地址时不管是不是ipv6网络都返回ipv4网络）</span></span><br><span class="line"><span class="comment">#AllowConnInGameServer1=1000;192.168.1.126;192.168.1.126</span></span><br><span class="line"><span class="attr">AllowConnInGameServer1</span>=<span class="number">1000</span><span class="comment">;127.0.0.1;127.0.0.1</span></span><br><span class="line"><span class="comment">#AllowConnInGameServer3=1200;192.168.5.6;192.168.5.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#和网络安全相关</span></span><br><span class="line"><span class="section">[NetSecurity]</span></span><br><span class="line"><span class="comment">#flood检测</span></span><br><span class="line"><span class="comment">#Flood攻击检测是否开启,1：开启   0：不开启</span></span><br><span class="line"><span class="attr">Sock_FloodAttackKickEnable</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#Sock_FloodTimeInterval表示每次收到数据包的时间间隔是100(单位：毫秒)</span></span><br><span class="line"><span class="attr">Sock_FloodTimeInterval</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">#Sock_FloodKickCounter表示计算到连续10次，每次100毫秒时间间隔内发包，就算恶意入侵，把他kick出去</span></span><br><span class="line"><span class="attr">Sock_FloodKickCounter</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#和数据库相关</span></span><br><span class="line"><span class="section">[Database]</span></span><br><span class="line"><span class="comment"># 数据库连接信息,格式为:&quot;IP;端口;帐号;密码;数据库名&quot;</span></span><br><span class="line"><span class="comment">#DatabaseLoginInfo = 192.168.1.126;3306;root;123456;mxzl_masterv3</span></span><br><span class="line"><span class="attr">DatabaseLoginInfo</span> = <span class="number">127.0</span>.<span class="number">0.1</span><span class="comment">;3306;brkzh;brkzh;brkzh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DatabasePoolSize:数据库连接池大小,大点还是应该,有些复杂查询是要消耗近1秒的时间</span></span><br><span class="line"><span class="comment"># 另外本服务器数据库确实连的人不多，所以多几个连接没问题；</span></span><br><span class="line"><span class="attr">DatabasePoolSize</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><h1 id="CMakeLists文件"><a href="#CMakeLists文件" class="headerlink" title="CMakeLists文件"></a>CMakeLists文件</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake --version 查看 cmake版本</span></span><br><span class="line"><span class="comment"># 指定CMake的最小版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工程名称</span></span><br><span class="line"><span class="keyword">project</span>(configSingleDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前编译选项后追加新编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -O2 -Wall -lmysqlclient -std=c++11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件搜索路径，类似g++里的-i参数</span></span><br><span class="line"><span class="keyword">include_directories</span>(./)</span><br><span class="line"><span class="comment">#include_directories(/usr/include/mysql/plugin)</span></span><br><span class="line"><span class="comment">#include_directories(/usr/include/mysql)</span></span><br><span class="line"><span class="comment">#link_libraries(&quot;libmysqlclient.so&quot;)</span></span><br><span class="line"><span class="comment">#link_directories(&quot;usr/lib/x86_64-linux-gnu&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set(MYSQL_LIBS</span></span><br><span class="line"><span class="comment">#     mysqlclient pthread z m rt atomic ssl crypto dl</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH ../)</span><br><span class="line"><span class="comment"># 生成可执行文件（这里可执行文件名叫做main_cmake），其他的是工程里包含的文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(main_cmake main.cpp config.cpp string_my.cpp)</span><br><span class="line"><span class="comment">#target_link_libraries(main_cmake $&#123;MYSQL_LIBS&#125;)</span></span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>公共函数头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:func.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FUNC_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FUNC_H__</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rtrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ltrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>公共函数源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名: string_my.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rtrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str_in == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(str_in);</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span> &amp;&amp; str_in[len<span class="number">-1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str_in[--len] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ltrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str_in == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span> *p_curr = str_in;</span><br><span class="line">    <span class="keyword">if</span>(*p_curr != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>((*p_curr) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*p_curr) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ++p_curr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*p_curr) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *str_in = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *p_new = str_in;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">         *p_new = *p_curr;</span><br><span class="line">         ++p_new;</span><br><span class="line">         ++p_curr;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((*p_curr) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    *p_new = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例类头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:config.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CONFIG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CONFIG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CConfItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ItemName[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> ItemContent[<span class="number">500</span>];</span><br><span class="line">&#125;CConfItem, *LPCConfItem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CConfig</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CConfig</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CConfig</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CConfig* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CGarhuishou</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGarhuishou</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(CConfig::m_instance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> CConfig::m_instance;</span><br><span class="line">                CConfig::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pconfName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p_itemname)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> CConfig* m_instance;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt; m_ConfigItemList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>单例配置类源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:config.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成语变量定义</span></span><br><span class="line">CConfig* CConfig::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m_mutex;   <span class="comment">// 定义一个互斥量</span></span><br><span class="line"></span><br><span class="line">CConfig::<span class="built_in">CConfig</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CConfig::~<span class="built_in">CConfig</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt;::iterator pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = m_ConfigItemList.<span class="built_in">begin</span>(); pos != m_ConfigItemList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">delete</span>(*pos);</span><br><span class="line">    &#125;</span><br><span class="line">    m_ConfigItemList.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CConfig* <span class="title">CConfig::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CConfig::m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">if</span>(CConfig::m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">CConfig</span>();</span><br><span class="line">            <span class="type">static</span> CGarhuishou cl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CConfig::Load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p_confName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(p_confName, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> lineBuf[<span class="number">501</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fgets</span>(lineBuf, <span class="built_in">sizeof</span>(lineBuf) - <span class="number">1</span>, fp) == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(lineBuf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(*lineBuf == <span class="string">&#x27;*&#x27;</span> || *lineBuf == <span class="string">&#x27;#&#x27;</span> || *lineBuf == <span class="string">&#x27;;&#x27;</span> || *lineBuf==<span class="string">&#x27;\n&#x27;</span> || *lineBuf==<span class="string">&#x27;\r&#x27;</span> || *lineBuf==<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">    lblprocstring:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(lineBuf) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lineBuf[<span class="built_in">strlen</span>(lineBuf) - <span class="number">1</span>] == <span class="number">10</span> || </span><br><span class="line">                lineBuf[<span class="built_in">strlen</span>(lineBuf) - <span class="number">1</span>] == <span class="number">13</span> || </span><br><span class="line">                lineBuf[<span class="built_in">strlen</span>(lineBuf) - <span class="number">1</span>] == <span class="number">32</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    lineBuf[<span class="built_in">strlen</span>(lineBuf)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> lblprocstring;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lineBuf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(*lineBuf == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *ptmp = <span class="built_in">strchr</span>(lineBuf, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptmp != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LPCConfItem p_confitem = <span class="keyword">new</span> CConfItem;</span><br><span class="line">            <span class="built_in">memset</span>(p_confitem, <span class="number">0</span>, <span class="built_in">sizeof</span>(CConfItem));</span><br><span class="line">            <span class="built_in">strncpy</span>(p_confitem-&gt;ItemName, lineBuf, (<span class="type">int</span>)(ptmp - lineBuf));</span><br><span class="line">            <span class="built_in">strcpy</span>(p_confitem-&gt;ItemContent, ptmp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Rtrim</span>(p_confitem-&gt;ItemName);</span><br><span class="line">            <span class="built_in">Rtrim</span>(p_confitem-&gt;ItemContent);</span><br><span class="line">            <span class="built_in">Ltrim</span>(p_confitem-&gt;ItemName);</span><br><span class="line">            <span class="built_in">Ltrim</span>(p_confitem-&gt;ItemContent);</span><br><span class="line"></span><br><span class="line">            m_ConfigItemList.<span class="built_in">push_back</span>(p_confitem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">CConfig::GetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p_itemname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt;::iterator pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = m_ConfigItemList.<span class="built_in">begin</span>(); pos != m_ConfigItemList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>((*pos)-&gt;ItemName, p_itemname) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>(*pos)-&gt;ItemContent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CConfig::GetIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt;::iterator pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = m_ConfigItemList.<span class="built_in">begin</span>(); pos != m_ConfigItemList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>((*pos)-&gt;ItemName, p_itemname) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">atoi</span>((*pos)-&gt;ItemContent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> def;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PATH <span class="string">&quot;/home/brkzh/demo/1.ConfigLoad/MsSrv_V2.conf&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CConfig* p_config = CConfig::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">if</span>(p_config-&gt;<span class="built_in">Load</span>(CONFIG_PATH) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;配置文件[&quot;</span>&lt;&lt;CONFIG_PATH&lt;&lt;<span class="string">&quot;]载入失败，退出!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *data_info = <span class="literal">nullptr</span>;</span><br><span class="line">    data_info = (<span class="type">char</span>*)p_config-&gt;<span class="built_in">GetString</span>(<span class="string">&quot;DatabaseLoginInfo&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(data_info)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;DatabaseLoginInfo=&quot;</span>&lt;&lt;data_info&lt;&lt;std::endl;</span><br><span class="line">        <span class="type">char</span> db_ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> db_user[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> db_passwd[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> db_database[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> db_port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *cur_tmp;</span><br><span class="line">        <span class="type">int</span> reg_ind = <span class="number">0</span>;</span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(db_ip, data_info, (<span class="type">int</span>)(cur_tmp - data_info));</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(db_ip) <span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info+reg_ind, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="type">char</span> tmp_port[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strncpy</span>(tmp_port, data_info+reg_ind, (<span class="type">int</span>)(cur_tmp - (data_info+reg_ind)));</span><br><span class="line">        db_port = <span class="built_in">atoi</span>(tmp_port);</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(tmp_port) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info+reg_ind, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(db_user, data_info+reg_ind, (<span class="type">int</span>)(cur_tmp - (data_info+reg_ind)));</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(db_user) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info+reg_ind, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(db_passwd, data_info+reg_ind, (<span class="type">int</span>)(cur_tmp - (data_info+reg_ind)));</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(db_passwd) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(db_database, data_info+reg_ind);</span><br><span class="line">        </span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_ip=&quot;</span>&lt;&lt;db_ip&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_port=&quot;</span>&lt;&lt;db_port&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_user=&quot;</span>&lt;&lt;db_user&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_passwd=&quot;</span>&lt;&lt;db_passwd&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_database=&quot;</span>&lt;&lt;db_database&lt;&lt;std::endl;     </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;DatabasePoolSize=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;DatabasePoolSize&quot;</span>, <span class="number">1</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Csdn=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetString</span>(<span class="string">&quot;Csdn&quot;</span>)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;worker_connections=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;worker_connections&quot;</span>, <span class="number">1</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Log=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetString</span>(<span class="string">&quot;Log&quot;</span>)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;DatabasePoolSize=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;DatabasePoolSize&quot;</span>, <span class="number">1</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进入当前代码所在的目录</span></span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br><span class="line">cd ..</span><br><span class="line">./main_cmake</span><br></pre></td></tr></table></figure><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoading_Demo/ConfigurationFileLoading_Demo_1.png" alt="ConfigurationFileLoading_Demo_1"></p><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoading_Demo/ConfigurationFileLoading_Demo_2.png" alt="ConfigurationFileLoading_Demo_2"></p><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoading_Demo/ConfigurationFileLoading_Demo_3.png" alt="ConfigurationFileLoading_Demo_3"></p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux C++ 发送验证码邮件</title>
      <link href="/2024/01/01/C_CPlusPlus/SendEMail_LinuxCPlusPlus/"/>
      <url>/2024/01/01/C_CPlusPlus/SendEMail_LinuxCPlusPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-C-发送验证码邮件"><a href="#Linux-C-发送验证码邮件" class="headerlink" title="Linux C++ 发送验证码邮件"></a>Linux C++ 发送验证码邮件</h1><p><code>Linux</code>下环境能直接运行。</p><span id="more"></span><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:my_smtp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY_SMTP_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_SMTP_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SMTP_MAXLEN = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C_MY_SMTP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C_MY_SMTP</span>(<span class="type">void</span>);</span><br><span class="line">    <span class="built_in">C_MY_SMTP</span>(</span><br><span class="line">        <span class="type">int</span> port,</span><br><span class="line">        std::string srvDomain,              <span class="comment">// smtp服务器域名  smtp@163.com 等</span></span><br><span class="line">        std::string userName,               <span class="comment">// 用户名 邮箱账号</span></span><br><span class="line">        std::string passWord,               <span class="comment">// 密码 邮箱 SMTP授权码</span></span><br><span class="line">        std::string targetEmail,            <span class="comment">// 目标邮箱 账号</span></span><br><span class="line">        std::string emailTitle,             <span class="comment">// 邮件主题</span></span><br><span class="line">        std::string content                <span class="comment">// 邮件内容</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">C_MY_SMTP</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_port;                               <span class="comment">// 端口号，一般是25</span></span><br><span class="line">    std::string m_domain;</span><br><span class="line">    std::string m_user;</span><br><span class="line">    std::string m_pass;</span><br><span class="line">    std::string m_targetUser;</span><br><span class="line">    std::string m_title;</span><br><span class="line">    std::string m_content;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_buff[SMTP_MAXLEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> m_buffLen;</span><br><span class="line">    <span class="type">int</span> m_sockClient;                        <span class="comment">// 客户端套接字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreateConn</span><span class="params">()</span></span>;                      <span class="comment">// 创建连接</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Send</span><span class="params">(std::string &amp;message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recv</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FormatEmailHead</span><span class="params">(std::string &amp;email)</span></span>;               <span class="comment">// 格式化要发送的邮件头部</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Login</span><span class="params">()</span></span>;                                            <span class="comment">// 登录邮箱账号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SendEmailHead</span><span class="params">()</span></span>;                                   <span class="comment">// 发送邮件头部信息</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SendTextBody</span><span class="params">()</span></span>;                                    <span class="comment">// 发送邮件正文（文本信息）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SendEnd</span><span class="params">()</span></span>;                                         <span class="comment">// 发送邮件尾部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetSrvDomain</span><span class="params">(std::string domain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_domain = domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetSrvDomain</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_domain; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetUserName</span><span class="params">(std::string user)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetUserName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_user; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPass</span><span class="params">(std::string pass)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pass = pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPass</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_pass; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTargetEmail</span><span class="params">(std::string targetAddr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_targetUser = targetAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetTargetEmail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_targetUser; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetEmailTitle</span><span class="params">(std::string title)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetEmailTitle</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_title; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetContent</span><span class="params">(std::string content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetContent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_content; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPort</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_port; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SendEmail_Ex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关于错误码的说明：1.网络错误导致的错误，2.用户名错误，3.密码错误 0.成功</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">base64Encode</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* origSigned, <span class="type">unsigned</span> origLength)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MY_SMTP_H__</span></span></span><br></pre></td></tr></table></figure><p><strong>源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:my_smtp.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_smtp.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> SMTP_base64Char[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">C_MY_SMTP::base64Encode</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* origSigned, <span class="type">unsigned</span> origLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span>* orig = (<span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span>*)origSigned; <span class="comment">// in case any input bytes have the MSB set</span></span><br><span class="line"><span class="keyword">if</span> (orig == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">const</span> numOrig24BitValues = origLength / <span class="number">3</span>;</span><br><span class="line"><span class="type">bool</span> havePadding = origLength &gt; numOrig24BitValues * <span class="number">3</span>;</span><br><span class="line"><span class="type">bool</span> havePadding2 = origLength == numOrig24BitValues * <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">const</span> numResultBytes = <span class="number">4</span> * (numOrig24BitValues + havePadding);</span><br><span class="line"><span class="type">char</span>* result = <span class="keyword">new</span> <span class="type">char</span>[numResultBytes + <span class="number">3</span>]; <span class="comment">// allow for trailing &#x27;/0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map each full group of 3 input bytes into 4 output base-64 characters:</span></span><br><span class="line"><span class="type">unsigned</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numOrig24BitValues; ++i)</span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">0</span>] = SMTP_base64Char[(orig[<span class="number">3</span> * i] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">1</span>] = SMTP_base64Char[(((orig[<span class="number">3</span> * i] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (orig[<span class="number">3</span> * i + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">2</span>] = SMTP_base64Char[((orig[<span class="number">3</span> * i + <span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (orig[<span class="number">3</span> * i + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">3</span>] = SMTP_base64Char[orig[<span class="number">3</span> * i + <span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, take padding into account.  (Note: i == numOrig24BitValues)</span></span><br><span class="line"><span class="keyword">if</span> (havePadding)</span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">0</span>] = SMTP_base64Char[(orig[<span class="number">3</span> * i] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line"><span class="keyword">if</span> (havePadding2)</span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">1</span>] = SMTP_base64Char[(((orig[<span class="number">3</span> * i] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (orig[<span class="number">3</span> * i + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">2</span>] = SMTP_base64Char[(orig[<span class="number">3</span> * i + <span class="number">1</span>] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">1</span>] = SMTP_base64Char[((orig[<span class="number">3</span> * i] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">3</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result[numResultBytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">C_MY_SMTP::<span class="built_in">C_MY_SMTP</span>(<span class="type">void</span>):<span class="built_in">m_port</span>(<span class="number">25</span>),<span class="built_in">m_domain</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_user</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_pass</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_targetUser</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_title</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_content</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_sockClient = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">C_MY_SMTP::~<span class="built_in">C_MY_SMTP</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_sockClient != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_sockClient);</span><br><span class="line">        m_sockClient = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的构造函数</span></span><br><span class="line">C_MY_SMTP::<span class="built_in">C_MY_SMTP</span>(</span><br><span class="line">        <span class="type">int</span> port,</span><br><span class="line">        std::string srvDomain,              <span class="comment">// smtp服务器域名  smtp@163.com 等</span></span><br><span class="line">        std::string userName,               <span class="comment">// 用户名 邮箱账号</span></span><br><span class="line">        std::string passWord,               <span class="comment">// 密码 邮箱 SMTP授权码</span></span><br><span class="line">        std::string targetEmail,            <span class="comment">// 目标邮箱 账号</span></span><br><span class="line">        std::string emailTitle,             <span class="comment">// 邮件主题</span></span><br><span class="line">        std::string content                <span class="comment">// 邮件内容</span></span><br><span class="line">    ): <span class="built_in">m_port</span>(port), <span class="built_in">m_domain</span>(srvDomain), <span class="built_in">m_user</span>(userName), <span class="built_in">m_pass</span>(passWord), <span class="built_in">m_targetUser</span>(targetEmail), <span class="built_in">m_title</span>(emailTitle), <span class="built_in">m_content</span>(content)</span><br><span class="line">&#123;</span><br><span class="line">    m_sockClient = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建创建socket并连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::CreateConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    m_sockClient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_sockClient &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addrSrv;</span><br><span class="line">    hostent * pHostent = <span class="built_in">gethostbyname</span>(m_domain.<span class="built_in">c_str</span>());               <span class="comment">// 得到有关的域名的信息</span></span><br><span class="line">    <span class="keyword">if</span>(pHostent == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addrSrv.sin_addr.s_addr = *((<span class="type">uint32_t</span>*)pHostent-&gt;h_addr);</span><br><span class="line">    addrSrv.sin_family = AF_INET;</span><br><span class="line">    addrSrv.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(m_sockClient, (<span class="keyword">struct</span> sockaddr*)&amp;addrSrv, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::Send</span><span class="params">(std::string&amp; message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> need_send = message.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">char</span>* tmp_send = (<span class="type">char</span>*)message.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">int</span> curr_send = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        curr_send = <span class="built_in">send</span>(m_sockClient, tmp_send, need_send, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(curr_send &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        need_send -= curr_send;</span><br><span class="line">        tmp_send += curr_send;</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_send &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::Recv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(m_buff, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_buff));</span><br><span class="line">    <span class="type">int</span> reco = <span class="built_in">recv</span>(m_sockClient, m_buff, SMTP_MAXLEN, <span class="number">0</span>);      <span class="comment">// 收数据</span></span><br><span class="line">    <span class="keyword">if</span>(reco == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 这里需要注意一下，越界问题</span></span><br><span class="line">    m_buff[reco] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C_MY_SMTP::Login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以改为 char数组，提高效率</span></span><br><span class="line">    std::string sendBuff;</span><br><span class="line">    sendBuff = <span class="string">&quot;EHLO &quot;</span>;</span><br><span class="line">    sendBuff += m_user;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 既要接收 也要发送</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">// 表示发送失败由于网络</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = <span class="string">&quot;AUTH LOGIN\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 请求登录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">// 表示发送失败由于网络</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = m_user;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* ecode;</span><br><span class="line">    <span class="comment">/*在这里顺带扯一句，关于string类的length函数与C语言中的strlen函数的区别,strlen计算出来的长度，只到&#x27;\0&#x27;字符为止,而string::length()函数实际上返回的是string类中字符数组的大小,你自己可以测试一下，这也是为什么我下面不使用string::length()的原因*/</span></span><br><span class="line"></span><br><span class="line">    ecode = <span class="built_in">base64Encode</span>(sendBuff.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(sendBuff.<span class="built_in">c_str</span>()));</span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = ecode;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] ecode;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 发送用户名，并接收服务器的返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    ecode = <span class="built_in">base64Encode</span>(m_pass.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(m_pass.<span class="built_in">c_str</span>()));</span><br><span class="line">    sendBuff = ecode;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] ecode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 发送用户密码，并接收服务器的返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> != <span class="built_in">strstr</span>(m_buff, <span class="string">&quot;550&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;               <span class="comment">// 错误码2表示用户名错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> != <span class="built_in">strstr</span>(m_buff, <span class="string">&quot;535&quot;</span>))            <span class="comment">// 535是认证失败的返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;               <span class="comment">// 错误码3表示密码错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                   <span class="comment">// 返回0 表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::SendEmailHead</span><span class="params">()</span>                 <span class="comment">// 发送邮件头部信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sendBuff;</span><br><span class="line">    sendBuff = <span class="string">&quot;MAIL From: &lt;&quot;</span> + m_user + <span class="string">&quot;&gt;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">// 网络错误导致失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::istringstream <span class="title">is_tmp</span><span class="params">(m_targetUser)</span></span>;</span><br><span class="line">    std::string tmpadd;</span><br><span class="line">    <span class="keyword">while</span>(is_tmp &gt;&gt; tmpadd)</span><br><span class="line">    &#123;</span><br><span class="line">        sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">        sendBuff = <span class="string">&quot;RCPT TO: &lt;&quot;</span> + tmpadd + <span class="string">&quot;&gt;\r\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = <span class="string">&quot;DATA\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    <span class="built_in">FormatEmailHead</span>(sendBuff);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff))</span><br><span class="line">    <span class="comment">// 发送完头部之后不必调用接收函数，因为没有\r\n</span></span><br><span class="line">    <span class="comment">// 没有\r\n 结尾，服务器认为你没有发完数据，所以不会返回什么值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化要发送的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C_MY_SMTP::FormatEmailHead</span><span class="params">(std::string&amp; email)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    email = <span class="string">&quot;From: &quot;</span>;</span><br><span class="line">    email += m_user;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;To: &quot;</span>;</span><br><span class="line">    email += m_targetUser;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;Subject: &quot;</span>;</span><br><span class="line">    email += m_title;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;MIME_Version: 1.0&quot;</span>;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;Content-Type: multipart/mixed;boundary=qwertyuiop&quot;</span>;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件正文（文本）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::SendTextBody</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sendBuff;</span><br><span class="line">    sendBuff = <span class="string">&quot;--qwertyuiop\r\n&quot;</span>;</span><br><span class="line">    sendBuff += <span class="string">&quot;Content-Type: text/plain;&quot;</span>;</span><br><span class="line">    sendBuff += <span class="string">&quot;charset=\&quot;utf-8\&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    sendBuff += m_content;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Send</span>(sendBuff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送结尾信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::SendEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sendBuf;</span><br><span class="line">    sendBuf = <span class="string">&quot;--qwertyuiop--&quot;</span>;</span><br><span class="line">    sendBuf += <span class="string">&quot;\r\n.\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuf) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sendBuf.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuf = <span class="string">&quot;QUIT\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Send</span>(sendBuf) &amp;&amp; <span class="built_in">Recv</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C_MY_SMTP::SendEmail_Ex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">CreateConn</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recv()</span></span><br><span class="line">    <span class="type">int</span> err = <span class="built_in">Login</span>();          <span class="comment">// 登录</span></span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> err;             <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">SendEmailHead</span>())        <span class="comment">// 发送EMAIL头部信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">SendTextBody</span>())         <span class="comment">// 发送邮件正文（文本）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">SendEnd</span>())              <span class="comment">// 发送邮件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">// 发送成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_smtp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试通过SMTP发送邮件到指定邮箱。&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">time_t</span> start_time1 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function">C_MY_SMTP <span class="title">smtp_cli</span><span class="params">(<span class="number">25</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// smtp服务 端口 25固定的</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;smtp.163.com&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">//因为我发送的邮箱是163邮箱,所以这里是163邮箱的smtp服务域名</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;你的邮箱账号@163.com&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 发送邮件的邮箱</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;1234567891352465&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 发送邮件的邮箱的授权码</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;你的需要接收的邮箱账号@m.scnu.edu.cn&quot;</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 接收邮件的邮箱</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;Linux SMTP Client Test!&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 邮件的主题</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;这是一个测试我的程序的邮件，若成功收到了我的邮件，说明我的程序是OK的。&quot;</span>           </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 邮件的正文</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    )</span></span>;</span><br><span class="line">    <span class="type">time_t</span> start_time2 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    smtp_cli.<span class="built_in">SendEmail_Ex</span>();                                                                    <span class="comment">// 发送邮件</span></span><br><span class="line">    <span class="type">time_t</span> start_time3 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time3=&quot;</span>&lt;&lt;start_time3&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time2=&quot;</span>&lt;&lt;start_time2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time1=&quot;</span>&lt;&lt;start_time1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;构造对象使用的时间:&quot;</span>&lt;&lt;start_time2 - start_time1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;发送邮件使用的时间:&quot;</span>&lt;&lt;start_time3 - start_time2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/SendEMail_LinuxCPlusPlus/SendEMail_LinuxCPlusPlus.png" alt="SendEMail_LinuxCPlusPlus"></p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win10安装WSL-Ubuntu18.04</title>
      <link href="/2023/12/01/Notes/WSL_Ubuntu_Win_InstallDocs/"/>
      <url>/2023/12/01/Notes/WSL_Ubuntu_Win_InstallDocs/</url>
      
        <content type="html"><![CDATA[<h1 id="Win10安装WSL-Ubuntu18-04"><a href="#Win10安装WSL-Ubuntu18-04" class="headerlink" title="Win10安装WSL-Ubuntu18.04"></a>Win10安装WSL-Ubuntu18.04</h1><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_01.png" alt="WSL_Ubuntu_Win_InstallDocs_01"></p><span id="more"></span><h2 id="一：安装前准备"><a href="#一：安装前准备" class="headerlink" title="一：安装前准备"></a>一：安装前准备</h2><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_02.png" alt="WSL_Ubuntu_Win_InstallDocs_02"></p><p><strong>适用于Linux的Windows子系统</strong> 这个勾选上，确定，安装后重启电脑。</p><h2 id="二：win应用商店安装-Ubuntu18-04-LTS"><a href="#二：win应用商店安装-Ubuntu18-04-LTS" class="headerlink" title="二：win应用商店安装 Ubuntu18.04 LTS"></a>二：win应用商店安装 Ubuntu18.04 LTS</h2><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_03.png" alt="WSL_Ubuntu_Win_InstallDocs_03"></p><p>到 Microsoft Store 下载安装 Ubuntu 18.04 LTS</p><p>下载安装完成后，打开 <strong>开始</strong> 菜单，能看到<img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_04.png" alt="WSL_Ubuntu_Win_InstallDocs_04"></p><p>直接打开这个， 会让你设置用户名，设置密码。 设置完成后，到此 可以说是已经安装完成成了。</p><h2 id="三：设置apt源为国内源"><a href="#三：设置apt源为国内源" class="headerlink" title="三：设置apt源为国内源"></a>三：设置apt源为国内源</h2><p><code>/etc/apt/sources.list</code> 这个文件，先备份一份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/apt</span><br><span class="line">cp sources.list sources.list.bk</span><br></pre></td></tr></table></figure><p>然后清空 原来的 <code>source.list</code> 文件</p><p>清空命令： <code>sudo echo &quot;&quot; &gt; sources.list</code></p><p>然后使用vm编辑该文件 <code>sudo vi sources.list</code> ，添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>添加上面内容后，保存，退出。</p><p>然后更新源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure><p>到此，Ubuntu源就切换为国内源了，使用 <code>apt-get</code> 安装时就会快很多。</p><h2 id="四：迁移WSL到非系统盘"><a href="#四：迁移WSL到非系统盘" class="headerlink" title="四：迁移WSL到非系统盘"></a>四：迁移WSL到非系统盘</h2><p>WSL默认是安装到C判断，当Ubuntu系统安装东西多了，占用的空间就多了，c盘可用空间就小了。接下来看看如何迁移到非系统盘吧。</p><h3 id="1）先查看wsl子系统版本，随便打开个cmd，输入如下命令"><a href="#1）先查看wsl子系统版本，随便打开个cmd，输入如下命令" class="headerlink" title="1）先查看wsl子系统版本，随便打开个cmd，输入如下命令"></a>1）先查看wsl子系统版本，随便打开个cmd，输入如下命令</h3><p> <code>wsl -l -v</code></p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_05.png" alt="WSL_Ubuntu_Win_InstallDocs_05"></p><p>如图所示，我的 WSL子系统是 Ubuntu-18.04 版本的，注意后面的 VERSION，我这里是2，是因为我使用的是WSL2这个版本，你们的很大可能是1，从应用商店安装的，默认就是WSL1。这个不用担心，接下来会说明如何升级到 WSL2的，因为我的也是从1升级到2的。</p><h3 id="2）导出系统"><a href="#2）导出系统" class="headerlink" title="2）导出系统"></a>2）导出系统</h3><p>打开cmd，输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export Ubuntu-18.04 d:\ubuntu18.04.tar</span><br></pre></td></tr></table></figure><p>命令解释： Ubuntu-18.04 是通过 <code>wsl -l -v</code> 查看到的，分发版本号</p><p><code>d:\ubuntu18.04.tar</code> 是要保存导出的系统文件的路径，这个路径你随意，想要导出到其他盘，使用其他名称也可以，如 <code>E:\my_ubuntu_18.04_LTS.tar</code> 这也是可以的。</p><h3 id="3）-注销当前分发版本"><a href="#3）-注销当前分发版本" class="headerlink" title="3） 注销当前分发版本"></a>3） 注销当前分发版本</h3><p>还是在cmd中指向如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister Ubuntu-18.04</span><br></pre></td></tr></table></figure><h3 id="4）重新导入并安装分发版本"><a href="#4）重新导入并安装分发版本" class="headerlink" title="4）重新导入并安装分发版本"></a>4）重新导入并安装分发版本</h3><p>在重新导入之前，如果你的 WSL版本是1，则需要先升级下WSL版本。</p><p>如果不升级，在导入安装时，会报 <code>WSL 2 需要更新其内核组件。</code> 这个错误</p><p>下载 <code>wsl_update</code> 更新文件</p><p>x64版本下载地址： <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">wsl_update_x64.msi</a></p><p>下载后，直接打开安装，一路点击 <code>next</code> 即可。</p><p>安装后，重启电脑。</p><p>此时，导入系统还不行，可能会报 <code>请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化</code> ，如何解决请看下面</p><p>打开<strong>控制面板-程序-启用或关闭Windows功能</strong></p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_06.png" alt="WSL_Ubuntu_Win_InstallDocs_06"></p><p>这里要 勾选 <strong>Hyper-V</strong> ，点确定安装后，在执行下面一条指令</p><p>使用 管理员方式打开 <code>PowerShell</code></p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_07.png" alt="WSL_Ubuntu_Win_InstallDocs_07"></p><p>输入命令 <code>bcdedit /set hypervisorlaunchtype auto</code> 回车，然后重启电脑。</p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_08.png" alt="WSL_Ubuntu_Win_InstallDocs_08"></p><p><strong>重启电脑后，现在来开始重新导入并安装分发版本</strong></p><p>在cmd中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import Ubuntu-18.04 d:\ubuntu_18.04 d:\ubuntu18.04.tar --version 2</span><br></pre></td></tr></table></figure><p>命令解释： 把 之前导出的 ubuntu18.04.tar 导入到 路径 <code>d:\ubuntu_18.04 </code>这个文件夹(这个文件夹先创建好，在执行上述命令)</p><p><strong>设置默认登陆用户为安装时用户名</strong></p><p>还是在cmd中执行下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu1804 config --default-user 你的用户名</span><br></pre></td></tr></table></figure><p>解释：<code>你的用户名</code> 是在第二：安装这里设置的用户名。</p><p>如：我这里安装是设置了用户名为 <code>zhangsan</code> 则，我这里的命令就是 <code>ubuntu1804 config --default-user zhangsan</code> 即可。</p><p>最后，导出的tar文件，删不删出自己决定呗。我就留着，作为备份。</p><p>到此，WSL子系统Ubuntu18.04就迁移完成了。</p><h2 id="五：WSL安装openssh，配置远程登录"><a href="#五：WSL安装openssh，配置远程登录" class="headerlink" title="五：WSL安装openssh，配置远程登录"></a>五：WSL安装openssh，配置远程登录</h2><p>系统会默认安装 <code>openssh-server</code> 服务。但是这个不好用，把它删了，重新下载</p><p>登录Ubuntu18.04，在终端输入命令 <code>sudo apt-get remove openssh-server</code> 删除掉，然后重新安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>安装后，修改配置文件 <code>/etc/ssh/sshd_config</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">Port 23333    # 端口号改掉，不要用22，因为怕和主机冲突</span><br><span class="line">PasswordAuthentication yes   # 允许用户名密码方式登录</span><br></pre></td></tr></table></figure><p>然后重启服务： <code>sudo service ssh --full-restart</code></p><h2 id="六：安装MySQL-5-7-36"><a href="#六：安装MySQL-5-7-36" class="headerlink" title="六：安装MySQL 5.7.36"></a>六：安装MySQL 5.7.36</h2><p>下载MySQL5.7.36安装包。</p><p>登录Ubuntu18.04，使用<code>wget</code>命令下载 MySQL.tar安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.mysql.com/archives/mysql-5.7/mysql-server_5.7.36-1ubuntu18.04_amd64.deb-bundle.tar</span><br></pre></td></tr></table></figure><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_09.png" alt="WSL_Ubuntu_Win_InstallDocs_09"></p><p>下载完后，直接解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf mysql-server_5.7.36-1ubuntu18.04_amd64.deb-bundle.tar</span><br></pre></td></tr></table></figure><p>解压后有很多个.deb包，如下图所示 ，其中蓝色方块圈起来的是 之前下载的 tar包。</p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_10.png" alt="WSL_Ubuntu_Win_InstallDocs_10"></p><p>开始安装MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ./*</span><br></pre></td></tr></table></figure><p>apt是可以直接安装deb包的。</p><p>注意，在安装过程中，会提示要求设置 MySQL登录用户名和密码</p><p>我这里直接设置 <code>root</code> 用户 密码为 <code>123456</code></p><p>安装后，启动MySQL， 命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/rc5.d</span><br><span class="line"></span><br><span class="line">sudo ./S01mysql start</span><br></pre></td></tr></table></figure><p>登录MySQL。</p><p><code>mysql -u root -p</code> 回车，然后输入密码 <code>123456</code> 即可。</p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_11.png" alt="WSL_Ubuntu_Win_InstallDocs_11"></p><h2 id="七：额外说明"><a href="#七：额外说明" class="headerlink" title="七：额外说明"></a>七：额外说明</h2><p>openssh-server好像不会自动启动，尝试过几种方式，都不行，等以后可行方法再说。</p><p>现在每次启动Ubuntu，都需要手动开启 ssh服务， 执行命令：<code>sudo service --full-restart</code> 或者 <code>sudo service start</code></p><p>同样，MySQL服务好像也是没有自动启动。手动启动命令: <code>sudo /etc/rc5.d/S01mysql start</code></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- weak_ptr智能指针</title>
      <link href="/2023/08/21/CPlusPlus11/021.AboutWeak_Ptr/"/>
      <url>/2023/08/21/CPlusPlus11/021.AboutWeak_Ptr/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 weak_ptr智能指针</p><span id="more"></span><h1 id="C-11-weak-ptr智能指针"><a href="#C-11-weak-ptr智能指针" class="headerlink" title="C++11 weak_ptr智能指针"></a>C++11 weak_ptr智能指针</h1><p>和 <code>shared_ptr</code>、<code>unique_ptr</code> 类型指针一样，<code>weak_ptr</code> 智能指针也是以模板类的方式实现的。<code>weak_ptr&lt;T&gt;</code>（ <code>T</code> 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 <code>std</code> 命名空间中。</p><p>注意，<code>c++11</code>标准虽然将<code>weak_ptr</code>定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和<code>shared_ptr</code>类型指针搭配使用。甚至于，可以将<code>weak_ptr</code>类型指针视为<code>shared_ptr</code>指针的一种辅助工具，借助<code>weak_ptr</code>类型指针，可以获取<code>shared_ptr</code>指针的一些状态信息，比如有多少指向相同的<code>shared_ptr</code>指针、<code>shared_ptr</code>指针指向的堆内存是否已经被释放等等。</p><p>注意，当<code>weak_ptr</code>类型指针的指向和某一<code>shared_ptr</code>指针相同时，<code>weak_ptr</code>指针并不会使所指堆内存的引用计数+1，同样，当<code>weak_ptr</code>指针被释放时，之前所指堆内存的引用计数也不会因此减1.即，<code>weak_ptr</code>类型指针并不会影响所指堆内存空间的引用计数。</p><p>除此之外，<code>weak_ptr&lt;T&gt;</code>模板类中没有重载<code>*</code>和<code>-&gt;</code>运算符，这就意味着，<code>weak_ptr</code>类型指针只能访问所指的堆内存，而无法修改它。</p><p><strong>1、<code>weak_ptr</code>指针的创建</strong></p><p>创建一个<code>weak_ptr</code>指针，有以下3中方式</p><p><strong>1）</strong>可以创建一个空<code>weak_ptr</code>指针，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br></pre></td></tr></table></figure><p><strong>2）</strong>凭借已有的<code>weak_ptr</code>指针，可以创建一个新的<code>weak_ptr</code>指针，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br></pre></td></tr></table></figure><p>若<code>wp1</code>为空指针，则<code>wp2</code>也为空指针，反之，如果<code>wp1</code>指向某一<code>shared_ptr</code>指针拥有的堆内存，则<code>wp2</code>也指向该块存储空间（可以访问，但无所有权）。</p><p><strong>3）</strong><code>weak_ptr</code>指针更常用于指向某一<code>shared_ptr</code>指针拥有的堆内存，因为在构建<code>weak_ptr</code>指针对象时，可以利用已有的<code>shared_ptr</code>指针为其初始化，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure><p>由此，<code>wp3</code>指针和<code>sp</code>指针有相同的指针。再次强调，<code>weak_ptr</code>类型指针不会导致堆内存空间的引用计数增加或减少。</p><p><strong>2、<code>weak_ptr</code>模板类提供的成员方法</strong></p><p>和<code>shared_ptr&lt;T&gt;</code>、<code>unique_ptr&lt;T&gt;</code>相比，<code>weak_ptr&lt;T&gt;</code>模板类提供的成员方法不多，以下是常用的</p><table><thead><tr><th>成员方式</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载<code>=</code>赋值运算符，<code>weak_ptr</code>指针可以直接被<code>weak_ptr</code>或者<code>shared_ptr</code>类型指针赋值</td></tr><tr><td><code>swap(x)</code></td><td>其中<code>x</code>表示一个同类型的<code>weak_ptr</code>类型指针，该函数可以互换2个同类型<code>weak_ptr</code>指针的内容</td></tr><tr><td><code>reset()</code></td><td>将当前<code>weak_ptr</code>指针置为空指针</td></tr><tr><td><code>use_count()</code></td><td>查看指向和当前<code>weak_ptr</code>指针相同的<code>shared_ptr</code>指针的数量</td></tr><tr><td><code>expired()</code></td><td>判断当前<code>weak_ptr</code>指针是否过期（指针为空，或者指向的堆内存已经被释放）</td></tr><tr><td><code>lock()</code></td><td>如果当前<code>weak_ptr</code>已经过期，则该函数会返回一个空的<code>shared_ptr</code>指针；反之，该函数会返回一个和当前<code>weak_ptr</code>指向相同的<code>shared_ptr</code>指针</td></tr></tbody></table><p>再次强调，<code>weak_ptr&lt;T&gt; </code>模板类没有重载<code> *</code> 和<code>-&gt;</code>运算符，因此 <code>weak_ptr </code>类型指针只能访问某一 <code>shared_ptr</code> 指针指向的堆内存空间，无法对其进行修改。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">weak_ptr_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp2)</span></span>;</span><br><span class="line">    <span class="comment">//输出和 wp同指向的 shared_ptr类型指针的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp.use_count()=&quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//释放sp2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count()=&quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp2.use_count()=&quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After sp2.reset()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count()=&quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp2.use_count()=&quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp.use_count()=&quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//借助lock()函数，返回一个和wp同指向的shared_ptr类型指针，获取其存储的数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*(wp.lock())=&quot;</span> &lt;&lt; * (wp.<span class="built_in">lock</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Call cout *(wp.lock())&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count()=&quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp.use_count()=&quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Call auto at = wp.lock()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> at = wp.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count()=&quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp.use_count()=&quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">wp.use_count()=2</span></span><br><span class="line"><span class="comment">sp1.use_count()=2</span></span><br><span class="line"><span class="comment">sp2.use_count()=2</span></span><br><span class="line"><span class="comment">After sp2.reset()</span></span><br><span class="line"><span class="comment">sp1.use_count()=1</span></span><br><span class="line"><span class="comment">sp2.use_count()=0</span></span><br><span class="line"><span class="comment">wp.use_count()=1</span></span><br><span class="line"><span class="comment">*(wp.lock())=10</span></span><br><span class="line"><span class="comment">After Call cout *(wp.lock())</span></span><br><span class="line"><span class="comment">sp1.use_count()=1</span></span><br><span class="line"><span class="comment">wp.use_count()=1</span></span><br><span class="line"><span class="comment">After Call auto at = wp.lock()</span></span><br><span class="line"><span class="comment">sp1.use_count()=2</span></span><br><span class="line"><span class="comment">wp.use_count()=2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- unique_ptr智能指针</title>
      <link href="/2023/08/20/CPlusPlus11/020.AboutUnique_Ptr/"/>
      <url>/2023/08/20/CPlusPlus11/020.AboutUnique_Ptr/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 unique_ptr智能指针</p><span id="more"></span><h1 id="C-11-unique-ptr智能指针"><a href="#C-11-unique-ptr智能指针" class="headerlink" title="C++11 unique_ptr智能指针"></a>C++11 unique_ptr智能指针</h1><p>作为智能指针的一种，<code>unique_ptr</code>指针自然也具备”在适当时机自动释放堆内存空间“的能力。和<code>shared_ptr</code>指针最大的区别是，<code>unique_ptr</code>指针指向的堆内存无法同其他<code>unique_ptr</code>共享，也就是说，每个<code>unique_ptr</code>指针都独自拥有对其所指堆内存空间的所有权。</p><p>也就意味着，每个<code>unique_ptr</code>指针指向的堆内存空间的引用计数，都只能为1，一旦该<code>unique_ptr</code>指针放弃对所指堆内存空间的所有权，则该空间会立即被释放回收。</p><p><code>unique_ptr</code>智能指针是以模板的形式提供的，<code>unique_ptr&lt;T&gt;</code>（<code>T</code>为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件中，并位于<code>std</code>命名空间。</p><p><strong><code>unique_ptr</code>智能指针的创建</strong></p><p>考虑到不同实际场景的需要，<code>unique_ptr&lt;T&gt;</code>模板类提供了多个实用的构造函数：</p><p><strong>1）</strong>通过以下两种方式，可以创建出空的<code>unique_ptr</code>指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>2）</strong>创建<code>unique_ptr</code>指针的同时，也可以明确其指向，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>由此就创建出了一个<code>p3</code>智能指针，其指向的是可容纳1个整数的堆存储空间</p><p>和可以利用<code>make_shard&lt;T&gt;()</code>模板函数初始化<code>shared_ptr</code>指针不同，<code>c++11</code>中并没有为<code>unique_ptr</code>类型指针添加类似的模板函数。</p><p><strong>3）</strong>基于<code>unique_ptr</code>类型指针不共享各自拥有的堆内存，因此<code>c++11</code>标准中的<code>unique_ptr</code>模板类没有提供拷贝构造函数，只提供了移动构造函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int&gt; p5(p4);  //这样是错误的，编译不通过</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure><p>对于调用移动构造函数的<code>p4</code>和<code>p5</code>来说，<code>p5</code>将获取<code>p4</code>所指对空间的所有权，而<code>p4</code>将变成空指针<code>nullptr</code>。</p><p><strong>4）</strong>默认情况下，<code>unique_ptr</code>指针采用<code>std::default_delete&lt;T&gt;</code>方法释放堆内存。当然，也可以自定义符合实际场景的释放规则。但是，和<code>shared_ptr</code>指针不同，为<code>unique_ptr</code>自定义释放规则，智能采用函数对象的方式，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;<span class="comment">//重载了()运算发,是一个可调用对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Call myDel.operator()(int*p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique_ptr_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>, myDel&gt;<span class="built_in">p2</span> (<span class="keyword">new</span> <span class="type">int</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>, myDel&gt;<span class="built_in">p3</span> (<span class="keyword">new</span> <span class="type">int</span>, <span class="built_in">myDel</span>());</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">Call myDel.operator()(int*p)</span></span><br><span class="line"><span class="comment">Call myDel.operator()(int*p)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>unique_ptr&lt;T&gt;</code>模板类提供的成员方法</strong></p><table><thead><tr><th>成员函数名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator*()</code></td><td>获取当前<code>unique_ptr</code>指针指向的数据</td></tr><tr><td><code>operator-&gt;()</code></td><td>重载<code>-&gt;</code>号，当智能指针指向的数据类型为自定义的结构体时，通过<code>-&gt;</code>运算符可以获取其内部的指定成员</td></tr><tr><td><code>operator=()</code></td><td>重载了<code>=</code>赋值号，从而可以将<code>nullptr</code>或者一个右值<code>unique_ptr</code>指针直接赋值给当前同类型的<code>unique_ptr</code>指针</td></tr><tr><td><code>operator[]()</code></td><td>重载了<code>[]</code>运算符，当<code>unique_ptr</code>指针指向一个数组时，可以直接通过<code>[]</code>获取指定下标位置处的数据</td></tr><tr><td><code>get()</code></td><td>获取当前<code>unique_ptr</code>指针内部包含的普通指针</td></tr><tr><td><code>get_deleter()</code></td><td>获取当前<code>unique_ptr</code>指针释放堆内存空间所用的规则</td></tr><tr><td><code>operator bool()</code></td><td><code>unique_ptr</code>指针可直接作为<code>if</code>语句的判断条件，以判断该指针是否为空，如果为空，则为<code>false</code>，反之为<code>true</code></td></tr><tr><td><code>release()</code></td><td>释放当前<code>unique_ptr</code>指针对所指堆内存的所有权，但该存储空间不会被销毁</td></tr><tr><td><code>reset(p)</code></td><td>其中<code>p</code>表示一个普通指针，如果<code>p</code>为<code>nullptr</code>，则当前<code>unique_ptr</code>也变成空指针；反之，则该函数会释放当前<code>unique_ptr</code>指针指向的堆内存（如果有），然后获取<code>p</code>所指堆内存的所有权</td></tr><tr><td><code>swap(x)</code></td><td>交换当前<code>unique_ptr</code>指针和同类型的<code>x</code>指针</td></tr></tbody></table><p>除此之外，<code>C++11</code>标准还支持同类型的 <code>unique_ptr </code>指针之间，以及 <code>unique_ptr</code> 和 <code>nullptr</code> 之间，做<code> ==</code>，<code>!=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code>，<code>&gt;=</code> 运算。</p><p>演示程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unique_ptr_test_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p5 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//p接收p5释放的堆内存</span></span><br><span class="line">    <span class="type">int</span>* p = p<span class="number">5.</span><span class="built_in">release</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断p5是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (p5)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is not nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p6;</span><br><span class="line">    <span class="comment">//p6获取p的所有权</span></span><br><span class="line">    p<span class="number">6.</span><span class="built_in">reset</span>(p);</span><br><span class="line">    cout &lt;&lt; *p6 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">p5 is nullptr</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- shared_ptr智能指针</title>
      <link href="/2023/08/19/CPlusPlus11/019.AboutShared_Ptr/"/>
      <url>/2023/08/19/CPlusPlus11/019.AboutShared_Ptr/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 shared_ptr智能指针</p><span id="more"></span><h1 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h1><p>在实际的<code>c++</code>开发中，经常会用到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.有些内存资源已经被释放，但指向它的指针并没有改变指向（野指针），并且后续还在使用；</span><br><span class="line">2.有些内存资源已经被释放，但后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</span><br><span class="line">3.没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</span><br></pre></td></tr></table></figure><p><code>c++11</code>标准废弃了<code>auto_ptr</code>的同时，增添了<code>unique_ptr</code>、<code>shared_ptr</code>、<code>weak_ptr</code>这3个智能指针来实现堆内存的自动回收。</p><p>所谓智能指针，可以从字面上理解为”智能“的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免”忘记释放内存而导致内存泄漏“问题出现。</p><p><code>C++</code>智能指针底层是采用<strong>引用计数</strong>地方式实现的。智能指针在申请堆内存空间的同时，会为其配备一个整型值（初始值为1），每当有新对象使用此堆内存时，该整型值+1，反之，每当使用此堆内存的对象被释放时，该整型值减1。当堆空间对应的整型值为0时，即表明不再有对象使用它，该堆空间就会被释放掉。</p><p><strong><code>C++11 shared_ptr</code>智能指针</strong></p><p>实际上，每种智能指针都是以类模板的方式实现的，<code>shared_ptr</code>也不例外。<code>shared_ptr&lt;T&gt;</code>（其中<code>T</code>表示指针指向的具体数据类型）的定义位于<code>&lt;memory&gt;</code>头文件，并位于<code>std</code>命令空间中。</p><p>指的一提的是，和<code>unique_ptr</code>、<code>weak_ptr</code>不同之处在于，<strong>多个<code>shared_ptr</code>智能指针可以共同使用同一块内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个<code>shared_ptr</code>指针放弃了堆内存的”使用权“(引用计数减1)，也不会影响其他指向同一块堆内存的<code>shared_ptr</code>指针(只有引用计数为0时，堆内存才会被自动释放)。</strong></p><p><strong>1、<code>shared_ptr</code>智能指针的创建</strong></p><p><code>shared_ptr&lt;T&gt;</code>类模板中，提供了多种实用的构造函数。</p><p><strong>1）</strong>通过如下2中方式，可以构造出<code>shared_ptr&lt;T&gt;</code>类型的空智能指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1; <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>; <span class="comment">//传入空指针nullptr</span></span><br></pre></td></tr></table></figure><p>注意，空的<code>shared_ptr</code>指针，其初始引用计数为0，而不是1。</p><p><strong>2）</strong>在构建<code>shared_ptr</code>智能指针，也可以明确其指向，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;nt&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>由此，就成功构建了一个<code>shared_ptr</code>智能指针，其指向一块存有10这个<code>int</code>类型数据的堆内存空间。</p><p>同时，<code>c++11</code>标准中还提供了<code>std::make_shared&lt;T&gt;</code>模板函数，其可以用于初始化<code>shared_ptr</code>智能指针，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>以上2种方法创建的<code>p3</code>是完全相同的。</p><p><strong>3）</strong>除此之外，<code>shared_ptr&lt;T&gt;</code>模板还提供有相应的拷贝构造函数和移动构造函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>; </span><br><span class="line"><span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; </span><br><span class="line"><span class="comment">//或者 std::shared_ptr&lt;int&gt;p5 = std::move(p4);</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>p3</code>和<code>p4</code>都是<code>shared_ptr</code>类型的智能指针，因此可以用<code>p3</code>来初始化<code>p4</code>，由于<code>p3</code>是左值，因此会调用拷贝构造函数。需要注意的是，如果<code>p3</code>为空指针，则<code>p4</code>也为空指针，其引用计数初始值为0，反之，则表明<code>p4</code>和<code>p3</code>指向同一块内存，同时该堆空间的引用计数会加1。</p><p>而对于<code>std::move(p4)</code>来说，该函数会强制将<code>p4</code>转换成对应的右值，因此初始化<code>p5</code>调用的是移动构造函数。另外和调用拷贝构造函数不同，用<code>std::move(p4)</code>初始化<code>p5</code>，会使得<code>p5</code>拥有了<code>p4</code>的堆内存，而<code>p4</code>则变成了空智能指针。</p><p>注意，同一普通指针不能同时为多个<code>shared_ptr</code>对象赋值，否则会导致发生异常。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p><strong>4）</strong>在初始化<code>shared_ptr</code>智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为0时，会优先调用我们自定义的释放规则</p><p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，<code>shared_ptr</code>指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p><p>对于申请的动态数组，释放规则可以使用<code>c++11</code>标准中提供的<code>default_delete&lt;T&gt;</code>模板类，也可以自定义释放规则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定default_delete作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化只能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br></pre></td></tr></table></figure><p>实际上借助<code>lambda</code>表达式，我们还可以像如下这样初始化<code>p7</code>，他们是完全相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p><code>shared_ptr&lt;T&gt;</code>模板类还提供有其它一些初始化智能指针的方法。</p><p><strong>2、<code>shared_ptr&lt;T&gt;</code>模板类提供的成员方法</strong></p><p>为了方便用户使用<code>shared_ptr</code>智能指针，<code>shared_ptr&lt;T&gt;</code>模板类还提供有一些使用的成员方法，它们自个的功能如下所示：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td><code>operator=()</code></td><td>重载赋值号，使得同一类型的<code>shared_ptr</code>智能指针可以相互赋值</td></tr><tr><td><code>operator*()</code></td><td>重载<code>*</code>号，获取当前<code>shared_ptr</code>智能指针对象指向的数据</td></tr><tr><td><code>operator-&gt;()</code></td><td>重载<code>-&gt;</code>号，当智能指针指向的数据类型为自定义的结构体时，通过<code>-&gt;</code>运算符可以获取其内部的指定成员</td></tr><tr><td><code>swap()</code></td><td>交换2个相同类型<code>shared_ptr</code>智能指针的内容</td></tr><tr><td><code>reset()</code></td><td>当函数没有实参时，该函数会使当前<code>shared_ptr</code>所指堆内存的引用计数减1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的<code>shared_ptr</code>对象会获得该存储空间的所有权，并且引用计数的初始值为1</td></tr><tr><td><code>get()</code></td><td>获得<code>shared_ptr</code>对象内部包含的普通指针</td></tr><tr><td><code>use_count()</code></td><td>返回当前<code>shared_ptr</code>对象（包括它）指向相同的所有<code>shared_ptr</code>对象的数量</td></tr><tr><td><code>unique()</code></td><td>判断当前<code>shared_ptr</code>对象指向的堆内存，如果是空指针，返回<code>false</code>，反之，返回<code>ture</code></td></tr><tr><td><code>operator bool()</code></td><td>判断当前<code>shared_ptr</code>对象是否为空智能指针，如果是空指针，返回<code>false</code>；反之返回<code>true</code></td></tr></tbody></table><p>除此之外，<code>c++11</code>标准还支持同一类型的<code>shared_ptr</code>对象，或者<code>shared_ptr</code>和<code>nullptr</code>之间，进行<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>运算。</p><p>演示代码，<code>shared_ptr</code>智能指针的基本用法，以及该模板提供了一些成员方法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shared_ptr_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建2个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出p2指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">reset</span>(); <span class="comment">//引用计数-1，p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和p2同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">p1为空</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- nullptr：初始化空指针</title>
      <link href="/2023/08/18/CPlusPlus11/018.AboutNullptr/"/>
      <url>/2023/08/18/CPlusPlus11/018.AboutNullptr/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 nullptr：初始化空指针</p><span id="more"></span><h1 id="C-11-nullptr：初始化空指针"><a href="#C-11-nullptr：初始化空指针" class="headerlink" title="C++11 nullptr：初始化空指针"></a>C++11 nullptr：初始化空指针</h1><p>在实际开发中，避免产生”野指针“最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。</p><p>所谓”野指针“，又称”悬挂指针“，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针(例如&amp;p)，极可能会导致程序发生异常。</p><p><code>c++98/03</code>标准中，将一个指针初始化为空指针的方式有2中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure><p>可以看到，可以将指针明确指向0<code>(0x00000000)</code>这个内存空间。一方面，明确指针的指向可以避免其称为野指针；另一方面，大多数操作系统都不允许用户对地址为0的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。</p><p><code>c++</code>中将<code>NULL</code>定义为字面常量0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符合，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_null</span><span class="params">(<span class="type">void</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void is_null(void* c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_null</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void is_null(int n)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_null_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">is_null</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">is_null</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">is_null</span>(p);</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">void is_null(int n)</span></span><br><span class="line"><span class="comment">void is_null(int n)</span></span><br><span class="line"><span class="comment">void is_null(void* c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>is_null(0)</code>来说，显然它真正调用的是参数为整型的<code>is_null()</code>函数，而对于<code>is_null(NULL)</code>来说，我们期望它实际调用的是参数为<code>void*</code>的<code>is_null()</code>函数，但是观察程序的执行结果，并不符合我们的预期。</p><p><code>c++98/03</code>标准中，如果我们想令<code>is_null(NULL)</code>实际调用的是<code>is_null(void*)</code>，就需要对<code>NULL</code>或者0进行强制类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">is_null</span>((<span class="type">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">is_null</span>((<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">void is_null(void* c)</span></span><br><span class="line"><span class="comment">void is_null(void* c)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如此，才会成功调用我们预期的函数。</p><p>由于<code>c++98</code>标准使用期间，<code>NULL</code>已经得到了广泛的应用，出于兼容性的考虑，<code>c++11</code>标准并没有对<code>NULL</code>的宏定义做任何修改。为了修正<code>c++</code>存在的这一问题，<code>c++</code>标准委员会最终决定在<code>c++11</code>标准中引入一个新关键字，即<code>nullptr</code>.</p><p>在使用<code>nullptr</code>之前，需要保证编译器支持该关键字。<code>g++</code>编译器至少需要升级到<code>4.6.1</code>，同时在编译时开启 <code>-std=c++0x</code>编译选项。</p><p><strong><code>nullptr</code>是<code>nullptr_t</code>类型的右值常量，专用于初始化空类型指针。</strong><code>nullptr_t</code>是<code>c++11</code>新增加的数据类型，可称为”指针空值类型“。<code>nullptr</code>仅是该类型的一个实例对象（已经定义好，可以直接使用）。</p><p><code>nullptr</code>可以被隐式转换成任意的指针类型，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span>* a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">float</span>* a3 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span>* a4 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>显然，不同类型的指针变量都可以使用<code>nullptr</code>来初始化，编译器分别将<code>nullptr</code>隐式转换成<code>int*</code>、<code>char*</code>、<code>float*</code>、<code>double*</code>指针类型。</p><p>另外，通过将指针初始化为<code>nullptr</code>，可以很好地解决<code>NULL</code>遗留的问题，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_nullptr</span><span class="params">(<span class="type">void</span>* c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void is_nullptr(void* c)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_nullptr</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void is_nullptr(int n)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_nullptr_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">is_nullptr</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">is_nullptr</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">void is_nullptr(int n)</span></span><br><span class="line"><span class="comment">void is_nullptr(void* c)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，由于<code>nullptr</code>无法隐式转换为整型，而可以隐式匹配指针类型，因此执行结果和我们预期的一致。</p><p>总之在<code>c++11</code>标准下，相比<code>NULL</code>和0，使用<code>nullptr</code>初始化空指针可以令我们编写的代码更加健壮。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 完美转发及其实现</title>
      <link href="/2023/08/17/CPlusPlus11/017.PerfectForwarding/"/>
      <url>/2023/08/17/CPlusPlus11/017.PerfectForwarding/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 完美转发及其实现</p><span id="more"></span><h1 id="C-11-完美转发及其实现"><a href="#C-11-完美转发及其实现" class="headerlink" title="C++11 完美转发及其实现"></a>C++11 完美转发及其实现</h1><p><code>C++11</code>标准为<code>C++</code>引入右值引用的语法的同时，还解决了一个<code>c++98/03</code>标准长期存在的短板，即使用简单的方式即可在函数模板中实现参数的完美转发。</p><p><strong>什么是完美转发？</strong>指的是函数模板可以将自己的参数”完美“地转发给内部调用的其他函数。所谓完美，即不能能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。</p><p>在<code>c++</code>中，一个表达式不是左值就是右值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，<code>function()</code>函数模板中调用了<code>otherdef()</code>函数。在此基础上，完美转发指的是：如果<code>function()</code>函数接收到参数<code>t</code>为左值，那么该函数传递给<code>otherdef()</code>的参数<code>t</code>也是左值；反之如果<code>function()</code>函数接收到的参数<code>t</code>为右值，那么传递给<code>otherdef()</code>的参数<code>t</code>也必须为右值。</p><p>显然，<code>function()</code>函数模板并没有实现完美转发，一方面，参数<code>t</code>为非引用类型，这意味着在调用<code>function()</code>函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用<code>function()</code>函数模板时传递给参数<code>t</code>的时左值还是右值，对于函数内部的参数<code>t</code>来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给<code>otherdef()</code>函数的参数<code>t</code>永远都是左值。总之，无论从哪个角度来看，<code>function()</code>函数的定义都不”完美“。</p><p>完美转发这种参数传递机制，很常用吗？在<code>c++98/03</code>标准中几乎不会用到，但是<code>c++11</code>标准中引入了右值引用和移动语义，因此很多场景中是否实现完美转发，直接决定了该参数的传递过程使用的是拷贝语义（调用拷贝构造函数）还是移动语义（调用移动构造函数）。</p><p>事实上，<code>c++98/03</code>标准下<code>c++</code>也可以实现完美转发，只是实现方式比较笨拙。<code>c++98/03</code>标准中只有左值引用，并且可以细分为<code>const</code>引用和非<code>const</code>引用。其中，使用非<code>const</code>引用作为函数模板参数时，只能接收左值，无法接收右值；而<code>const</code>左值引用既可以接收左值，也可以接收右值，但考虑到其<code>const</code>属性，除非被调用函数的参数也是<code>const</code>属性，否则将无法直接传递。</p><p>这也就意味着，单独使用任何一种引用形式，可以实现转发，但无法保证完美，因此如果使用<code>c++98/03</code>标准下的<code>c++</code>语言，可以采用函数模板重载的方式实现完美转发，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名：22.c++11_perfect_forword.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++98/03标准的C++</span></span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span>&amp; t)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载函数模板，分别接收左值和右值</span></span><br><span class="line"><span class="comment">//接收右值参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void function(const T&amp; t)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收左值参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void function(T&amp; t)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpp_98_03_forword_demo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//文件名：22.c++11_perfect_forword.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;22.c++11_perfect_forword.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++98/03标准的C++</span></span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span>&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void otherdef(int&amp; t) -&gt;&gt; lvalue&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void otherdef(const int&amp; t) --&gt; rvalue&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpp_98_03_forword_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>); <span class="comment">//5是右值</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x); <span class="comment">//x是左值</span></span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">void function(const T&amp; t)</span></span><br><span class="line"><span class="comment">void otherdef(const int&amp; t) --&gt; rvalue</span></span><br><span class="line"><span class="comment">void function(T&amp; t)</span></span><br><span class="line"><span class="comment">void otherdef(int&amp; t) -&gt;&gt; lvalue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出结果可以i看到，对于右值5来说，它实际调用的参数类型为<code>const T&amp;</code>的函数模板，由于<code>t</code>为<code>const</code>类型，所以<code>otherdef()</code>函数实际调用的也是参数用<code>const</code>修饰的函数，所以输出<code>rvalue</code>；对于左值<code>x</code>来说，2个重载模板函数都适用，<code>c++</code>编译器会选择最适合的参数类型为<code>t&amp;</code>的函数模板，进而<code>otherdef()</code>函数实际调用的是参数类型为非<code>const</code>的函数，输出<code>lvalue</code>。</p><p>显然，使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就要编写大量的重载函数模板，造成代码的冗余。为了方便用户更快速地实现完美转发，<code>c++11</code>标准中允许在函数模板中使用右值引用来实现完美转发。</p><p><code>c++11</code>标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为”万能引用“）。</p><p>仍以<code>function()</code>函数为例，在<code>c++11</code>标准中实现完美转发，只需要编写如下一个模板函数即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此模板函数的参数<code>t</code>既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题需要解决，即如果调用<code>function()</code>函数时为其传递一个左值引用或者右值引用的实参，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; num = n;</span><br><span class="line"><span class="built_in">function</span>(num); <span class="comment">//T为int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp;&amp; num2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">function</span>(num2); <span class="comment">//T为int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>其中，由<code>function(num)</code>实例化的函数底层就变成了<code>function(int&amp; &amp;&amp; t)</code>,同样由<code>function(num2)</code>实例化的函数底层则变成了<code>function(int&amp;&amp; &amp;&amp;t)</code>。要知道，<code>c++98/03</code>标准时不支持这种用法的，而<code>c++11</code>标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用<code>A</code>表示实际传递的类型）：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当实参为左值或者左值引用(A<span class="built_in">&amp;</span>)时，函数模板中T<span class="built_in">&amp;</span><span class="built_in">&amp;</span>将转变为A<span class="built_in">&amp;</span>(A<span class="built_in">&amp;</span> <span class="built_in">&amp;</span><span class="built_in">&amp;</span> = A<span class="built_in">&amp;</span>)；</span><br><span class="line">2.当实参为右值或者右值引用(A<span class="built_in">&amp;</span><span class="built_in">&amp;</span>)时，函数模板中T<span class="built_in">&amp;</span><span class="built_in">&amp;</span>将转变为A<span class="built_in">&amp;</span><span class="built_in">&amp;</span>(A<span class="built_in">&amp;</span><span class="built_in">&amp;</span> <span class="built_in">&amp;</span><span class="built_in">&amp;</span> = A<span class="built_in">&amp;</span><span class="built_in">&amp;</span>);</span><br></pre></td></tr></table></figure><p>在实现完美转发时，只要函数模板的参数类型为<code>T&amp;&amp;</code>，则<code>C++</code>可以自行准确地判定出实际传入的实参时左值还是右值。</p><p>通过将函数模板的形参类型设置为<code>T&amp;&amp;</code>，可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？</p><p><code>c++11</code>标准还引入了一个模板函数<code>forword&lt;T&gt;()</code>，只需要调用该函数，就可以很方便地解决此问题。仍以<code>function</code>模板函数为例子，看看如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现完美转发地函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpp_11_forword_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function_2</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function_2</span>(x);</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">void otherdef(const int&amp; t) --&gt; rvalue</span></span><br><span class="line"><span class="comment">void otherdef(int&amp; t) -&gt;&gt; lvalue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述程序中，此<code>function()</code>模板函数才是实现完美转发的最终版本。可以看到，<code>forward()</code>函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数。</p><p>在定义模板函数时，采用右值引用的语法定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值；其次，还需要使用<code>c++11</code>标准库提供的<code>forward()</code>模板函数修饰被调用函数中需要维持左、右值属性的参数。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 引用限定符</title>
      <link href="/2023/08/16/CPlusPlus11/016.ReferenceQualifier/"/>
      <url>/2023/08/16/CPlusPlus11/016.ReferenceQualifier/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 引用限定符</p><span id="more"></span><h1 id="C-11-引用限定符"><a href="#C-11-引用限定符" class="headerlink" title="C++11 引用限定符"></a>C++11 引用限定符</h1><p>左值和右值的区分同样适用于类对象。</p><p>默认情况下，对于类中用<code>public</code>修饰的成员函数，既可以被左值的类对象调用，也可以被右值的类对象调用。举例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名：21.c++11_ref_cnst.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num) :<span class="built_in">m_num</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_ref_cnst_demo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//********************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;21.c++11_ref_cnst.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_ref_cnst_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>demo</code>类中<code>get_num()</code>成员函数既可以被<code>a</code>左值都西昂调用，也可以被<code>move(a)</code>生成的右值<code>demo</code>对象调用，运行程序会输出两个10。</p><p>某些场景中，可能需要限制调用成员函数的对象的类型（左值类对象还是右值类对象），为此<code>c++11</code>新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加<code>&amp;</code>或者<code>&amp;&amp;</code>，从而限制调用者的类型（左值类对象还是右值类对象）。</p><p>调整上述代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo2</span>(<span class="type">int</span> num) :<span class="built_in">m_num</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is get_num()&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is get_num()&amp;&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_ref_cnst_demo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">demo2 <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">This is get_num()&amp;</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">This is get_num()&amp;&amp;</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析结果知道，仅在<code>get_num()</code>成员函数后面添加了<code>&amp;</code>，它可以限定调用该函数的对象必须是左值对应。</p><p>在<code>get_num()</code>成员函数添加了<code>&amp;&amp;</code>，它可以限定调用该函数的对象必须是右值对象。</p><p><strong>注意，引用限定符不适用于静态成员函数和友元函数。</strong></p><p><strong>const和引用限定符</strong></p><p><code>const</code>也可以用于修饰类的成员函数，习惯称为常成员函数。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>get_num()</code>就是一个常成员函数。</p><p><code>const</code>和引用限定符修饰类的成员函数时，都位于函数的末尾。<code>c++11</code>标准规定，当引用限定符和<code>const</code>修饰同一个类的成员函数时，<code>const</code>必须位于引用限定符前面。</p><p>需要注意，当<code>const &amp;&amp;</code>修饰类的成员函数时，调用它的对象只能是右值对象；当<code>const &amp;</code>修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是<code>const &amp;&amp;</code>还是<code>const &amp;</code>限定修饰的成员函数，内部都不允许大队当前对象做修改操作。看看例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo3</span>(<span class="type">int</span> num, <span class="type">int</span> num2) :<span class="built_in">m_num</span>(num), <span class="built_in">m_num2</span>(num2)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span>&amp; </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is get_num() const&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="type">const</span>&amp;&amp;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is get_num2() const&amp;&amp;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">    <span class="type">int</span> m_num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_ref_demo3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">demo3 <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl; <span class="comment">//正确</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl; //错误</span></span><br><span class="line">    <span class="comment">//error C2662: “int demo3::get_num2(void) const &amp;&amp;”: 不能将“this”指针从“demo3”转换为“const demo3 &amp;&amp;”</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num2</span>() &lt;&lt; endl; <span class="comment">//正确</span></span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">This is get_num() const&amp;</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">This is get_num() const&amp;</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">This is get_num2() const&amp;&amp;</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- move()函数</title>
      <link href="/2023/08/15/CPlusPlus11/015.StdMoveFunc/"/>
      <url>/2023/08/15/CPlusPlus11/015.StdMoveFunc/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 move()函数</p><span id="more"></span><h1 id="C-11-move-函数"><a href="#C-11-move-函数" class="headerlink" title="C++11 move()函数"></a>C++11 move()函数</h1><p><code>c++11</code>标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p><p>注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，<code>c++11</code>标准中已经给出了解决方案，即调用<code>move()</code>函数。</p><p><code>move</code>本意为”移动“，但该函数不能移动任何数据，它的功能很简单，就是将某个左值转化为具有可移动的能力。</p><p>基于<code>move()</code>函数特殊的功能，其常用于实现移动语义，<code>move()</code>函数的用法也很简单，语法格式如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move(arg);</span><br><span class="line">其中arg表示指定的左值对象，该函数会返回arg对象的右值形式，从而使arg具有可可移动的能力</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名：20.c++11_move.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">movedemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">movedemo</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(<span class="type">const</span> movedemo&amp; md) :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*md.num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(movedemo&amp;&amp; d) :<span class="built_in">num</span>(d.num)</span><br><span class="line">    &#123;</span><br><span class="line">        d.num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: <span class="comment">//定义为public,方便外部直接访问</span></span><br><span class="line">    <span class="type">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_move_demo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***********************</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;20.c++11_move.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_move_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo2:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt;&quot; *demo.num &lt;&lt; endl; //可以执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo3:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    movedemo demo3 = std::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时demo.num = nullptr; 因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">construct!</span></span><br><span class="line"><span class="comment">demo2:</span></span><br><span class="line"><span class="comment">copy construct!</span></span><br><span class="line"><span class="comment">demo3:</span></span><br><span class="line"><span class="comment">move construct!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察程序的输出结果，以及对比<code>demo2</code>和<code>demo3</code>初始化操作不难得到，<code>demo</code>对象作为左值，直接用于初始化<code>demo2</code>对象，其底层调用的是拷贝构造函数；而通过调用<code>move()</code>函数可以得到<code>demo</code>对象的右值形式，用其初始化<code>demo3</code>对象，编译器会优先调用移动构造函数。</p><p>注意：调用拷贝构造函数，并不影响<code>demo</code>对象，但如果调用移动构造函数，由于函数内部会重置<code>demo.num</code>指针的指向为<code>nullptr</code>。</p><p>例子2，灵活使用<code>move()</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">first</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first&amp;&amp; dm) : <span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*dm.num))</span><br><span class="line">    &#123;</span><br><span class="line">        dm.num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">second</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">second</span>() :<span class="built_in">fir</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用first类的移动构造函数初始化fir</span></span><br><span class="line">    <span class="built_in">second</span>(second&amp;&amp; sec) :<span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_move_demo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl; //程序报运行时错误</span></span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">first construct!</span></span><br><span class="line"><span class="comment">second construct!</span></span><br><span class="line"><span class="comment">first move construct!</span></span><br><span class="line"><span class="comment">second move construct</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中分别构建了<code>first</code>和<code>second</code>这2个类，其中<code>second</code>类中包含一个<code>first</code>类对象。</p><p>程序中使用了2次<code>move()</code>函数：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.move(oth);由于oth为左值，如果想调用移动构造函数为oth2初始化，需要利用move()函数生成一个oth的右值版本；</span><br><span class="line">2.fir(move(sec.fir))，oth对象内部还包含一个first类都西昂，对于oth.fir类说，其也是一个左值，所以在初始化oth.fir是，还需要再一次调用move()函数。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 移动构造函数的功能和用法</title>
      <link href="/2023/08/14/CPlusPlus11/014.MoveConstructorsFunc/"/>
      <url>/2023/08/14/CPlusPlus11/014.MoveConstructorsFunc/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 移动构造函数的功能和用法</p><span id="more"></span><h1 id="C-11-移动构造函数的功能和用法"><a href="#C-11-移动构造函数的功能和用法" class="headerlink" title="C++11 移动构造函数的功能和用法"></a>C++11 移动构造函数的功能和用法</h1><p><code>C++11</code>移动语义是什么？</p><p>在<code>c++11</code>标准之前，如果想用其他对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。拷贝构造函数的实现原理很简单，就是为新对象复制一份和其他对象一摸一样的数据。</p><p>需要注意，当类中拥有<strong>指针类型</strong>的成员变量时，拷贝构造函数中需要以<strong>深拷贝</strong>（而非浅拷贝）的方式复制该指针成员。看看例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMoveConstruct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMoveConstruct</span>() :<span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CMoveConstruct</span>(<span class="type">const</span> CMoveConstruct&amp; mc) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*mc.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CMoveConstruct</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_num)</span><br><span class="line">            <span class="keyword">delete</span> m_num;</span><br><span class="line">        m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class destruct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CMoveConstruct <span class="title">get_demo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_construct_test_demo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CMoveConstruct <span class="title">get_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CMoveConstruct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_construct_test_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMoveConstruct dm = <span class="built_in">get_demo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，类<code>CMoveConstruct</code>自定义了一个拷贝构造函数，该函数在拷贝<code>mc.m_num</code>指针成员时，必须采用深拷贝方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。</p><p>可以看到，程序中，定义了一个可返回<code>CMoveConstruct</code>对象的<code>get_demo()</code>函数，用于在其他函数中初始化对象<code>dm</code>，其整个初始化的流程包含以下介个阶段：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.执行get<span class="built_in">_</span>demo()函数内部的CMoveConstruct()语句，即调用CMoveConstruct类的默认构造函数生成一个匿名对象；</span><br><span class="line">2.执行return CMoveConstruct()语句，会调用CMoveConstruct类的拷贝构造函数复制一份之前生成的匿名对象，并将其作为get<span class="built_in">_</span>demo()函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</span><br><span class="line">3.执行dm = get<span class="built_in">_</span>demo()语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给dm（此行代码执行完毕，get<span class="built_in">_</span>demo()函数返回的对象会被析构）；</span><br><span class="line">4.程序执行结束前，或自行调用demo类的析构函数销毁dm。</span><br></pre></td></tr></table></figure><p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，优化后的结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">class destruct!</span><br></pre></td></tr></table></figure><p>而同样的程序，如果在<code>Linux</code>上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令行进行编译，就可以看到完整的输出结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!                &lt;-- 执行 CMoveConstruct()</span><br><span class="line">copy construct!       &lt;-- 执行 return CMoveConstruct()</span><br><span class="line">class destruct!         &lt;-- 销毁 CMoveConstruct() 产生的匿名对象</span><br><span class="line">copy construct!       &lt;-- 执行 dm = get<span class="built_in">_</span>demo()</span><br><span class="line">class destruct!         &lt;-- 销毁 get<span class="built_in">_</span>demo() 返回的临时对象</span><br><span class="line">class destruct!         &lt;-- 销毁 dm</span><br></pre></td></tr></table></figure><p>如上所述，利用拷贝构造函数实现对<code>dm</code>对象的初始化，底层实际上进行了2此拷贝（而且还是深拷贝）操作，当然，进对于申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么2此深拷贝操作势必会影响<code>dm</code>对象初始化的执行效率。</p><p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？</p><p><code>C++11</code>标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p><p><strong>C++移动构造函数（移动语义的具体实现）</strong></p><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源”移为己用“。</p><p>以前面的程序为例，该类的成员都包含一个整型的指针成员，其默认指向的是容纳一个整型变量的堆空间。当使用<code>get_demo()</code>函数返回的临时对象初始化<code>dm</code>时，只需要将临时对象的<code>m_num</code>指针直接浅拷贝给<code>dm.m_num</code>,然后修改该临时对象中<code>m_num</code>指针的指向（通常让其指向<code>nullptr</code>），这样就完成了<code>dm.m_num</code>的初始化。</p><p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其他的用处），并且会很快被销毁，因此在使用临时对象初始化新对象时，可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMoveConstruct_2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMoveConstruct_2</span>() :<span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CMoveConstruct_2</span>(<span class="type">const</span> CMoveConstruct_2&amp; mc) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*mc.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">CMoveConstruct_2</span>(CMoveConstruct_2&amp;&amp; mc) : <span class="built_in">m_num</span>(mc.m_num)</span><br><span class="line">    &#123;</span><br><span class="line">        mc.m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CMoveConstruct_2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_num)</span><br><span class="line">            <span class="keyword">delete</span> m_num;</span><br><span class="line">        m_num = <span class="literal">nullptr</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class destruct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">CMoveConstruct_2 <span class="title">get_demo2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_construct_test_demo2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CMoveConstruct_2 <span class="title">get_demo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CMoveConstruct_2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_construct_test_demo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMoveConstruct_2 dm = <span class="built_in">get_demo2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，再之前的类的基础上，添加了一个构造函数，和其他构造函数不同，此构造函数使用<strong>右值引用</strong>形式的参数，又称为<strong>移动构造函数</strong>。并且在此构造函数中，<code>m_num</code>指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了<code>mc.m_num</code>，有效避免了”同一块内存被释放多次“情况的发生。</p><p>在<code>Linux</code>系统中使用<code>g++ demo.cpp -o demo -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">move construct!</span><br><span class="line">class destruct!</span><br><span class="line">move construct!</span><br><span class="line">class destruct!</span><br><span class="line">class destruct!</span><br></pre></td></tr></table></figure><p>通过执行结果分析，当<code>CMoveConstruct_2</code>类添加移动构造函数后，使用临时对象初始化<code>dm</code>对象过程中产生的2此拷贝操作，都转为有移动构造函数完成。</p><p>非<code>const</code>右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、<code>lambda</code>表达式等）既无名称也无法获取其存储地址，所以属于右值。<strong>当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</strong></p><p>在实际的开发中，通常在类中自定义移动构造函数时，会再为其定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p><p>如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现？</p><p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，必须使用右值进行初始化。<code>c++11</code>标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了<code>std::move()</code>函数，它可以将左值弄成具有可移动的能力，由此便可以使用移动构造函数。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 右值引用</title>
      <link href="/2023/08/13/CPlusPlus11/013.RvalueReference/"/>
      <url>/2023/08/13/CPlusPlus11/013.RvalueReference/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 右值引用</p><span id="more"></span><h1 id="C-11-右值引用"><a href="#C-11-右值引用" class="headerlink" title="C++11 右值引用"></a>C++11 右值引用</h1><p>右值引用是<code>c++11</code>的新语法，理解并不难，真正有难度的是基于右值引用引申出来的2中<code>c++</code>编程技巧，分别是<strong>移动语义</strong>和<strong>完美转发</strong>。</p><p><strong>C++左值和右值</strong></p><p>右值引用可以从字节意思理解，指的是以引用传递（而非值传递）的方式使用<code>C++</code>右值。</p><p>在<code>c++</code>或者<code>c</code>语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说<code>c++</code>中左值和右值的概念是从<code>C</code>语言继承过来的。</p><p>指的一提的是，左值的英文简写为<code>lvalue</code>，右值的英文简写为<code>rvalue</code>。很多人认为它们分别是<code>left value</code>和<code>right value</code>的缩写，其实不然。<code>lvalue</code>是<code>locator value</code>的缩写，为存储在内存中、有明确存储地址（可寻址）的数据，而<code>rvalue</code>是<code>read value</code>的缩写，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储与寄存器中的数据）。</p><p>通常情况下，判断某个表达式是左值还是右值，最常用的有以下两种方法：</p><p><strong>1）可位于赋值好（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">//错误，5不能为左值</span></span><br></pre></td></tr></table></figure><p>其中变量<code>a</code>就是一个左值，而字面量5就是一个右值。值得一提，<code>c++</code>中的左值也可以当右值使用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>; <span class="comment">//b是一个左值</span></span><br><span class="line">a = b; <span class="comment">//a、b都是左值，只不过将b可以当作右值使用</span></span><br></pre></td></tr></table></figure><p><strong>2）有名称的、可以获取到存储地址的表达式即为左值；反之则是右值</strong></p><p>上述例子中，变量<code>a、b</code>为例，<code>a</code>和<code>b</code>都是变量名，且通过<code>&amp;a</code>和<code>&amp;b</code>可以获得他们的存储地址，因此<code>a</code>和<code>b</code>都是左值；反之字面量<code>5、10</code>，他们呢既没有名称，也无法获取其存储地址（字面量通常存储在寄存器当中，或者和代码存储在一起），因此5和10都是右值。</p><p>注意，以上2中方法只适用于大部分场景。</p><p><strong>C++右值引用</strong></p><p>其实在<code>c++98/03</code>标准中就有引用，使用<code>&amp;</code>表示，但此种引用方式有一个缺陷，即正常情况下只能操作<code>c++</code>中的左值，无法对右值添加引用，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>编译器允许为<code>num</code>左值建立一个引用，但不可以为10这个右值建立引用，因此，<code>c++98/03</code>标准中的引用又称为<strong>左值引用</strong>。</p><p>注意，虽然<code>c++98/03</code>标准中不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值，也就是说，常量左值引用既可以操作左值，也可以操作右值，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>右值往往是没有名称的，因此要使用它们只能借助引用的方式。这就产生一个问题，实际开发中可能需要对右值进行修改(实现移动语义是就需要)，显然左值引用的方式是行不通的。</p><p>为此，<code>c++11</code>标准新引入了另一种方式，称为右值引用，用<code>&amp;&amp;</code>表示。</p><p>需要注意，<strong>和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化</strong>，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp;a = num; //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>和常量左值引用不同的是，右值引用还可以对右值进行修改，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;a  = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;  <span class="comment">//输出结果：100</span></span><br></pre></td></tr></table></figure><p>另外，<code>c++</code>语法上是支持定义常量右值引用的，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; a = <span class="number">10</span>; <span class="comment">//编译器不会报错</span></span><br></pre></td></tr></table></figure><p>但这种定义出来的右值引用并无实际用处。另一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p><table><thead><tr><th>引用类型</th><th>可以</th><th>引用</th><th>的值</th><th>类型</th><th>使用场景</th></tr></thead><tbody><tr><td></td><td>非常量左值</td><td>常量左值</td><td>非常量右值</td><td>常量右值</td><td></td></tr><tr><td>非常量左值引用</td><td>支持</td><td>不支持</td><td>不支持</td><td>不支持</td><td>无</td></tr><tr><td>常量左值引用</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td>常用于类中构建拷贝构造函数</td></tr><tr><td>非常量右值引用</td><td>不支持</td><td>不支持</td><td>支持</td><td>不支持</td><td>移动语义、完美转发</td></tr><tr><td>常量右值引用</td><td>不支持</td><td>不支持</td><td>支持</td><td>支持</td><td>无实际用途</td></tr></tbody></table><p>其实，<code>c++11</code>标准中对右值做了更细致的划分，分别称为纯右值<code>Pure value,简称pvalue</code>和将亡值<code>eXpiring value,简称xvalue</code>。其中纯右值就是<code>c++98/03</code>标准中的右值，而将亡值则指的是和右值引用相关的表达式（比如某函数返回的<code>T&amp;&amp;</code>类型的表达式）。对于纯右值和将亡值，都属于右值。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- long long超长整形详解</title>
      <link href="/2023/08/12/CPlusPlus11/012.AboutLongLongDesc/"/>
      <url>/2023/08/12/CPlusPlus11/012.AboutLongLongDesc/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 long long超长整形详解</p><span id="more"></span><h1 id="C-11-long-long超长整形详解"><a href="#C-11-long-long超长整形详解" class="headerlink" title="C++11 long long超长整形详解"></a>C++11 long long超长整形详解</h1><p><code>c++11</code>标准中，基于整数大小的考虑，提供了如下表数据类型，同时，标准中还明确的限定了各个数据类型最少占用的位数。</p><table><thead><tr><th>整数类型</th><th>等价类型</th><th>c++11标准中规定占用最少位数</th></tr></thead><tbody><tr><td>short</td><td>short int(有符号短整型)</td><td>至少16位(2个字节)</td></tr><tr><td>signed short</td><td>short int(有符号短整型)</td><td>至少16位(2个字节)</td></tr><tr><td>signed short int</td><td>short int(有符号短整型)</td><td>至少16位(2个字节)</td></tr><tr><td>unsigned short</td><td>unsigned short int(无符号短整型)</td><td>至少16位(2个字节)</td></tr><tr><td>unsigned short int</td><td>unsigned short int(无符号短整型)</td><td>至少16位(2个字节)</td></tr><tr><td></td><td></td><td></td></tr><tr><td>int</td><td>int(有符号整型)</td><td>至少16位(2个字节)</td></tr><tr><td>signed</td><td>int(有符号整型)</td><td>至少16位(2个字节)</td></tr><tr><td>signed int</td><td>int(有符号整型)</td><td>至少16位(2个字节)</td></tr><tr><td>unsigned</td><td>unsigned int(无符号整型)</td><td>至少16位(2个字节)</td></tr><tr><td>unsigned int</td><td>unsigned int(无符号整型)</td><td>至少16位(2个字节)</td></tr><tr><td></td><td></td><td></td></tr><tr><td>long</td><td>long int(有符号长整型)</td><td>至少32位(4字节)</td></tr><tr><td>long int</td><td>long int(有符号长整型)</td><td>至少32位(4字节)</td></tr><tr><td>signed long</td><td>long int(有符号长整型)</td><td>至少32位(4字节)</td></tr><tr><td>signed long int</td><td>long int(有符号长整型)</td><td>至少32位(4字节)</td></tr><tr><td>unsigned long</td><td>unsigned long int(无符号长整型)</td><td>至少32位(4字节)</td></tr><tr><td>unsigned long int</td><td>unsigned long int(无符号长整型)</td><td>至少32位(4字节)</td></tr><tr><td></td><td></td><td></td></tr><tr><td>以下是C++11标准新增的</td><td>long long int(有符号超长整型)</td><td>至少64位(8字节)</td></tr><tr><td>long long</td><td>long long int(有符号超长整型)</td><td>至少64位(8字节)</td></tr><tr><td>long long int</td><td>long long int(有符号超长整型)</td><td>至少64位(8字节)</td></tr><tr><td>signed long long</td><td>long long int(有符号超长整型)</td><td>至少64位(8字节)</td></tr><tr><td>signed long long int</td><td>long long int(有符号超长整型)</td><td>至少64位(8字节)</td></tr><tr><td>unsigned long long</td><td>unsigned long long int(无符号超长整型)</td><td>至少64位(8字节)</td></tr><tr><td>unsigned long long int</td><td>unsigned long long int(无符号超长整型)</td><td>至少64位(8字节)</td></tr></tbody></table><p><code>c++11</code>标准规定，每种整数类型必须同时具备有符号<code>signed</code>和无符号<code>unsigned</code>两种类型，且每种具体的有符号整形和无符号整型所占用的存储空间(也就是位数)必须相同。</p><p>注意，<code>c++11</code>标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不用的存储空间。</p><p>在上表中，<code>long long</code>超长整型是<code>c++11</code>标准新添加的。</p><p><code>long long</code>整型被<code>c99</code>标准采纳，并逐渐被很多编译器支持，<code>c++</code>标准委员会决定将<code>long long</code>整型写入<code>c++11</code>标准中。</p><p>如同<code>long</code>类型整数需要明确标注”<code>L</code>“或者”<code>l</code>“后缀一样，要使用<code>long long</code>类型的整数，也必须标注对应的后缀；</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对于有符号long long整型，后缀用&quot;LL&quot;或者&quot;ll&quot;标识，例如：10LL就标识有符号超长整数10；</span><br><span class="line">2.对于无符号long long整型，后缀用&quot;ULL&quot;、&quot;ull&quot;、&quot;uLL&quot;标识，例如：10ULL。</span><br></pre></td></tr></table></figure><p>如果不添加任何标识，则所有的整数都会默认为<code>int</code>类型。</p><p>对于任意一种数据类型，更关心的是此类型的取值范围。对于<code>long long</code>类型来说，如果想了解当前平台上<code>long long</code>整型的取值范围，可以使用<code>&lt;climits&gt;</code>头文件中于<code>long long</code>整型相关的3个宏，分别为<code>LLONG_MIN、LLONG_MAX、ULLONG_MAN</code>：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.LLONG<span class="built_in">_</span>MIN:代表当前平台上最小的long long类型整数；</span><br><span class="line">2.LLONG<span class="built_in">_</span>MAX:代表当前平台上最大的long long类型整数；</span><br><span class="line">3.LLONG<span class="built_in">_</span>MAX:代表当前平台上最大的unsigned long long类型整数(最小值为0)。</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_long_long_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;          long long最大值:&quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">&quot;\t十六进制值为:&quot;</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dec;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;          long long最小值:&quot;</span> &lt;&lt; LLONG_MIN &lt;&lt; <span class="string">&quot;\t十六进制值为:&quot;</span> &lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dec;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;unsigned long long最大值:&quot;</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="string">&quot;\t十六进制值为:&quot;</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX &lt;&lt; endl;</span><br><span class="line"><span class="comment">/* win x86 输出</span></span><br><span class="line"><span class="comment">      long long最大值:9223372036854775807      十六进制值为:7fffffffffffffff</span></span><br><span class="line"><span class="comment">          long long最小值:-9223372036854775808     十六进制值为:8000000000000000</span></span><br><span class="line"><span class="comment">unsigned long long最大值:18446744073709551615  十六进制值为:ffffffffffffffff</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- constexpr常量表达式相关</title>
      <link href="/2023/08/11/CPlusPlus11/011.AbountConstexprAndConst/"/>
      <url>/2023/08/11/CPlusPlus11/011.AbountConstexprAndConst/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>[C++11 constexpr：验证是否为常量表达式](#C++11 constexpr：验证是否为常量表达式)</p><p>[C++11 constexpr和const的区别](#C++11 constexpr和const的区别)</p><span id="more"></span><h1 id="C-11-constexpr：验证是否为常量表达式"><a href="#C-11-constexpr：验证是否为常量表达式" class="headerlink" title="C++11 constexpr：验证是否为常量表达式"></a>C++11 constexpr：验证是否为常量表达式</h1><p><code>constexpr</code>是<code>c++11</code>标准新引入的。</p><p>常量表达式，指的就是由多个(<code>&gt;=1</code>)常量组成的表达式。也就是说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。也就意味着，常量表达式一旦确定，其值将无法修改。</p><p>实际开发中，经常会使用到常量表达式，如，数组的长度就必须是一个常量表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> url[<span class="number">10</span>];  <span class="comment">//没问题</span></span><br><span class="line"><span class="type">int</span> url2[<span class="number">6</span><span class="number">+4</span>]; <span class="comment">//也没问题</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> url3[length]; <span class="comment">//这里有问题，length是变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> clength = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> url4[clength]; <span class="comment">//这样就没问题</span></span><br></pre></td></tr></table></figure><p>常量表达式的应用场景还有很多，比如匿名枚举、<code>switch-case</code>结构中的<code>case</code>表达式等。</p><p><code>c++</code>程序的执行过程大致需要经历<strong>编译、链接、运行</strong>这3个阶段，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>对于用<code>c++</code>编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的”特权“呢？除了认为判定外，<code>c++11</code>标准中还提供有<code>constexpr</code>关键字。</p><p><code>constexpr</code>关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。<code>c++11</code>标准中，<code>constexpr</code>可用于修饰普通变量、函数(包括模板函数)以及类的构造函数。</p><p>注意，获得在编译阶段计算出结果的能力，并不代表<code>constexpr</code>修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算的。</p><p><strong>constexpr修饰普通变量</strong></p><p><code>c++11</code>标准中，定义变量时可以用<code>constexpr</code>修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p><p>使用<code>constexpr</code>修饰普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span><span class="number">+2</span><span class="number">+3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    cout&lt;&lt;url[<span class="number">1</span>]&lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>constexpr</code>修饰<code>num</code>变量，同时将<code>&quot;1+2+3&quot;</code>这个常量表达式赋值给<code>num</code>，编译器就可以在编译时期对<code>num</code>这个表达式进行计算，因为<code>num</code>可以作为定义数组时的长度。</p><p>将上述代码中的<code>constexpr</code>用<code>const</code>关键字替换也可以正常执行，这是因为<code>num</code>的定义同时满足<code>num</code>是<code>const</code>常量且使用常量表达式为其初始化，这两个条件，由此编译器会认定<code>num</code>是一个常量表达式。</p><p>注意：当常量表达式中包含浮点数时，考虑到程序编译和运行时所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度可能会受到影响，因此<code>c++11</code>标准规定，浮点常量表达式在编译阶段计算的经度至少要等于(或者高于)运行阶段计算出的精度。</p><p><strong>constexpr修饰函数</strong></p><p><code>constexpr</code>还可以用于修饰函数的返回值，这样的函数又称为”常量表达式函数“。</p><p>注意，<code>constexpr</code>并非可以修饰任意函数的返回值，也就是说，一个函数想要成为常量表达式函数，就必须要满足以下4个条件：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1)整个函数的函数体中，除了可以包含using指令、typedef语句以及static<span class="built_in">_</span>assert断言外，只能包含一条return返回语句。</span><br><span class="line">constexpr int display(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 1 + 2 + x;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述这个函数是无法通过编译的，因为该函数的返回值用<code>constexpr</code>修饰，但函数内部包含多条语句。</p><p>修正定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using执行、typedef语句以及static_assert断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>display()</code>函数的返回值是用<code>constexpr</code>修饰的<code>int</code>类型值，且该函数的函数体中只包含一个<code>return</code>语句。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2)该函数必须有返回值，即函数的返回值类型不能是void</span><br><span class="line">constexpr void display()</span><br><span class="line">&#123;</span><br><span class="line">    //函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义的返回值类型为<code>void</code>的函数，不属于常量表达式函数，因为通过类似的函数根本无法获得一个常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>)函数在使用之前，必须有对应的定义语句。函数的使用分为”声明<span class="string">&quot;和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其他文件中），但常量表达式函数在使用前，必须要有该函数的定义。</span></span><br><span class="line"><span class="string">//普通函数的声明</span></span><br><span class="line"><span class="string">int noconst_dis(int x);</span></span><br><span class="line"><span class="string">//常量表达式函数的声明</span></span><br><span class="line"><span class="string">constexpr int display(int x);</span></span><br><span class="line"><span class="string">void constexpr_demo1();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">constexpr int display(int x)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">return 1 + 2 + x;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void constexpr_demo1()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">//调用常量表达式函数</span></span><br><span class="line"><span class="string">int arr[display(3)] = &#123; 1,2,3,4 &#125;;</span></span><br><span class="line"><span class="string">cout &lt;&lt; arr[2] &lt;&lt; endl;</span></span><br><span class="line"><span class="string">//调用普通函数</span></span><br><span class="line"><span class="string">cout &lt;&lt; noconst_dis(3) &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int noconst_dis(int x)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">return 1 + 2 + x;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数不同，调用位置之前必须有该函数的定义，否则会导致程序编译失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>)<span class="keyword">return</span>返回的表达式必须是常量表达式</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="built_in">display</span>()] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述程序无法编译通过，报错信息为：<code>display(3)表达式的计算结果不是常数</code></p><p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想要在程序编译阶段获得某个函数的返回的常量，则该函数的<code>return</code>语句中就不能包含程序运行阶段才确定值的变量。</p><p>注意，在常量表达式函数的<code>return</code>语句中，不能包含赋值的操作，例如<code>return x=1;</code>在常量表达式函数中不允许的。另外，用<code>constexpr</code>修饰函数时，函数本身也是支持递归的。</p><p><strong>constexpr修饰类的构造函数</strong></p><p>对于<code>c++</code>内置类型的数据，可以直接调用<code>constexpr</code>修饰，但如果是自定义的数据类型(用<code>struct</code>或者<code>class</code>实现)，直接用<code>constexpr</code>修饰是不行的。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其他的结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> my &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; mty.name &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; my.age&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序是无法通过编译的，编译器会抛出”<code>constexpr不能修饰自定义类型</code>“的异常。</p><p>如果想要自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span>* name, <span class="type">int</span> age)</span>:m_name(name),m_age(age)&#123;</span>&#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_name;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    cout&lt;&lt; mt.name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;mt.age&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，在<code>myType</code>结构体中自定义有一个构造函数，借助此构造函数，用<code>constexpr</code>修饰的<code>myType</code>类型的<code>mt</code>常量即可通过编译。</p><p>注意，<code>constexpr</code>修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p><p>前面提到，<code>constexpr</code>可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中函数”，所以<code>constexpr</code>也可以修饰类中的成员函数，只不过此函数必须满足前面提到的4个条件。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * name = mt.<span class="built_in">getname</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> age = mt.<span class="built_in">getage</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>c++11</code>标准中，不支持用<code>constexpr</code>修饰带有<code>virtual</code>的成员方法。</p><p><strong>constexpr修饰模板函数</strong></p><p><code>c++11</code>语法中，<code>constexpr</code>可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p><p>针对这种情况，<code>c++11</code>标准规定，如果<code>constexpr</code>修饰的模板函数实例化结果不满足常量表达式函数的要求，则<code>constexpr</code>会被自动忽略，即该函数就等同于一个普通函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType_2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">display_2</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">constexpr_test_template</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType_2</span> stu &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType_2</span> ret = <span class="built_in">display_2</span>(stu);</span><br><span class="line">cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line"><span class="comment">//常量表达式函数</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">display_2</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序中，定义了一个模板函数<code>display()</code>，但由于其返回值类型尚未确定，因此在实例化之前无法判断其是否符合常量表达式函数的要求。</p><p>当模板函数自定义结构体<code>myType_2</code>类型进行实例化时，由于该结构体中没有自定义常量表达式和构造函数，所以实例化后的函数不是常量表达式函数，此时<code>constexpr</code>是无效的。</p><p>当模板函数的类型<code>T</code>为<code>int</code>类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</p><h1 id="C-11-constexpr和const的区别"><a href="#C-11-constexpr和const的区别" class="headerlink" title="C++11 constexpr和const的区别"></a>C++11 constexpr和const的区别</h1><p>注意别把<code>const</code>和<code>constexpr</code>搞混，得知道什么时候用<code>const</code>，什么时候用<code>constexpr</code>。</p><p><code>constexpr</code>是<code>c++11</code>标准新增加的关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//错误,x是只读变量，无法修改</span></span><br><span class="line">    array&lt;<span class="type">int</span>, x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout&lt;&lt;myarr[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array&lt;<span class="type">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout&lt;&lt;myarr[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">display_1</span>();</span><br><span class="line">    <span class="built_in">display_2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>display_1()</code>和<code>display_2()</code>函数中都包含一个<code>const int x</code>，但<code>display_1()</code>函数中的<code>x</code>无法完成初始化<code>array</code>容器的任务，而<code>display_2()</code>函数中的<code>x</code>却可以。</p><p>这是因为<code>display_1()</code>函数中的<code>const int x</code>只是强调<code>x</code>是一个只读的变量，其本质仍未变量，无法用来初始化<code>array</code>容器，而<code>display_2()</code>函数中的<code>const int x</code>，表明<code>x</code>是一个只读变量的同时，<code>x</code>还是一个值为5的常量，所以可以哦你过来初始化<code>array</code>容器。</p><p><code>c++11</code>标准中，为了解决<code>const</code>关键字的双重语义问题，保留了<code>const</code>表示“只读”的语义，而将“常量”的预计划分给了新添加的<code>constexpr</code>关键字。因此<code>c++11</code>标准中，建议将<code>const</code>和<code>constexpr</code>的功能区分开，即凡是表达“只读”语义的长江都使用<code>const</code>，表达“常量”的语义场景都是用<code>constexpr</code>。</p><p>在上面的示例中，<code>display_2()</code>函数中使用<code>const int x</code>是不规范的，应使用<code>constexpr</code>关键字。</p><p>疑问？“只读”不就意味着不能被修改吗？答案是否定的。“只读”和“不允许修改”之间并没有必然联系，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; con_b = a;</span><br><span class="line">    cout&lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">    20</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序中用<code>const</code>修饰了<code>con_b</code>变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着<code>con_b</code>的值不能借助其他变量间接改变，通过改变a的值就可以使<code>const_b</code>的值发生改变。</p><p>在大部分实际场景中，<code>const</code>和<code>constexpr</code>使可以混用的，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span><span class="number">+4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">5</span><span class="number">+4</span>;</span><br></pre></td></tr></table></figure><p>它们是无安全等价的，都可以在程序的编译阶段计算出结果，但是在某些场景下必须使用<code>constexpr</code>，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sql_demo1</span><span class="params">(<span class="type">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">sql_demo2</span><span class="params">(<span class="type">int</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, sql_demo1(10)&gt; my_arr1; <span class="comment">//这可以,因为sql_demo1是constexpr函数，编译时就已经确定了返回值</span></span><br><span class="line">    array&lt;<span class="type">int</span>, sql_demo2(10)&gt; my_arr2; <span class="comment">//这不可以，因为sql_demo2是普通函数，只不过是返回常量，返回值是在运行时确定，因此编译失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步解释：因为<code>sql_demo2()</code>函数的返回值仅有<code>const</code>修饰，而没有用更明确的<code>constexpr</code>修饰，导致其无法用于初始化<code>array</code>容器（只有常量才能初始化<code>array</code>容器）。</p><p>总的来说，<code>c++11</code>标准中，<code>const</code>用于为修饰的变量添加“只读”属性，而<code>constexpr</code>关键字则用于指明其后的一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- for循环</title>
      <link href="/2023/08/10/CPlusPlus11/010.AboutForLoop/"/>
      <url>/2023/08/10/CPlusPlus11/010.AboutForLoop/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>[C++11 for循环(基于范围的循环)详解](#C++11 for循环(基于范围的循环)详解)</p><p><a href="#%E4%BD%BF%E7%94%A8C++11%E6%A0%87%E5%87%86%E7%9A%84for%E5%BE%AA%E7%8E%AF%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%BF%99%E4%BA%9B%E5%9D%91">使用C++11标准的for循环，注意这些坑</a></p><span id="more"></span><h1 id="C-11-for循环-基于范围的循环-详解"><a href="#C-11-for循环-基于范围的循环-详解" class="headerlink" title="C++11 for循环(基于范围的循环)详解"></a>C++11 for循环(基于范围的循环)详解</h1><p><code>C++11</code>标准之前(<code>C++98/03</code>标准)，如果要用<code>for</code>循环语句遍历每一个数组或者容器，只能使用以下结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_demo_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line"><span class="type">int</span> iCir;</span><br><span class="line"><span class="comment">//for循环遍历普通数组</span></span><br><span class="line"><span class="keyword">for</span> (iCir = <span class="number">0</span>; iCir &lt; <span class="built_in">strlen</span>(arr); ++iCir)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[iCir];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;<span class="built_in">myVector</span>(arr, arr + <span class="number">11</span>);</span><br><span class="line">vector&lt;<span class="type">char</span>&gt;::iterator iter;</span><br><span class="line"><span class="comment">//for循环遍历vector容器</span></span><br><span class="line"><span class="keyword">for</span> (iter = myVector.<span class="built_in">begin</span>(); iter != myVector.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *iter;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>c++11</code>标准中，除了可以使用上述的用法外，还为<code>for</code>循环添加了一种全新的语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，两个参数各自的含义如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，c++11中，declaration参数处定义的变量可以使用auto关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</span><br><span class="line">2.expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用&#123;&#125;大括号初始化的序列。</span><br></pre></td></tr></table></figure><p>同<code>c++98/03</code>中的<code>for</code>循环的语法格式相比较，此格式并没有明确限定<code>for</code>循环的遍历范围，这是它们最大的区别，即旧格式的<code>for</code>循环可以指定循环的范围，而<code>c++11</code>标准增加的<code>for</code>循环，指挥逐个遍历<code>expression</code>参数处指定的每个元素。</p><p>示例：<code>c++11</code>中的<code>for</code>循环遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_for_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line"><span class="comment">//for循环遍历普通数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : arr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;<span class="built_in">myVector</span>(arr, arr + <span class="number">11</span>);</span><br><span class="line"><span class="comment">//for循环遍历vector容器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : myVector)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>1）程序中在遍历<code>myVector</code>容器是，定义了<code>auto</code>类型的<code>ch</code>变量，当编译器编译程序时，会通过<code>myVector</code>容器中存储的元素类型自动推导出<code>ch</code>为<code>char</code>类型。注意，这里<code>ch</code>不是迭代器类型，而表示的是<code>myVector</code>容器中存储的每个元素。</p><p>除此之外，新语法格式的<code>for</code>循环还支持遍历用<code>&#123;&#125;</code>大括号初始化的列表，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_for_demo_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在使用新语法<code>for</code>循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方法很简单，在<code>declaration</code>参数处定义引用形式的变量即可，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_fro_demo_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;qwert&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt;<span class="built_in">myVector</span>(arr, arr + <span class="number">5</span>);</span><br><span class="line"><span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : myVector)</span><br><span class="line">&#123;</span><br><span class="line">ch++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : myVector)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//rxfsu</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>declaration</code>参数既可以定义普通形式的变量，也可以定义引用形式的变量，该如何选择呢？</p><p>其实很简单，如果需要在遍历序列的过程中修改内部元素的值，就必须定义引用形式的变量；反之，建议定义<code>const &amp;</code>(常引用)形式的变量(避免了底层复制变量的过程，效率更高)，也可以定义普通变量。</p><h1 id="使用C-11标准的for循环，注意这些坑"><a href="#使用C-11标准的for循环，注意这些坑" class="headerlink" title="使用C++11标准的for循环，注意这些坑"></a>使用C++11标准的for循环，注意这些坑</h1><p><code>for</code>循环的使用注意事项，更准确高效地使用基于范围<code>for</code>循环。</p><p>1）当使用<code>for</code>循环遍历某个序列时，无论该序列是普通数组、容器还是用<code>&#123;&#125;</code>大括号包裹的初始化列表，遍历序列的变量都表示的是当前序列中的各个元素。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_for_tips_dm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ch : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : arr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;<span class="built_in">myVec</span>(arr, arr + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : myVec)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序使用了<code>for</code>循环遍历3中序列的过程，其中前两种情况较容易理解，但对于基于范围<code>for</code>循环遍历容器中的元素，很多人会将<code>ch</code>误认为是指向各个元素的迭代器，其实不是的，它表示的是容器中的各个元素。</p><p>加深对遍历容器的理解，看看下面以<code>map</code>容器的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_for_tips_dm2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;std::string, std::string&gt; myMap&#123;</span><br><span class="line">&#123;<span class="string">&quot;C++11&quot;</span>, <span class="string">&quot;C++11标准&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Python语言&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Java开发语言&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (std::pair&lt;std::string, std::string&gt; ch : myMap)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch.first &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; ch.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要知道，<code>map</code>容器中存储的不再是普通数据类型的数据，而是<code>pair</code>类型的数据，因此程序中在使用基于范围<code>for</code>循环遍历<code>map</code>容器时，定义的是<code>pair</code>类型的变量。</p><p>注意，基于范围<code>for</code>循环也可以直接遍历某个字符串，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">char</span> ch : <span class="string">&quot;https://brkzh.github.io/&quot;</span>) </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;ch;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>普通数组可以作为被遍历的序列。对于上述的字符串来说，其数据类型为<code>const char[23]</code>，即在编译器看来字符串就是一个普通数组，因此完全可以直接作为遍历的序列。</p><p>当然，基于范围<code>for</code>循环也可以遍历<code>string</code>类型的字符串，这种情况下冒号前定义<code>char</code>类型的变量即可。</p><p>2）基于范围的<code>for</code>循环可以遍历普通数组、<code>string</code>字符串、容器以及初始化列表。除此之外，<code>for</code>循环冒号后还可以放置返回<code>string</code>字符串以及容器对象的函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::string g_str = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g_myVec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">std::string <span class="title">retStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> g_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">retVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> g_myVec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_for_tips_dm3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : <span class="built_in">retVector</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，基于范围的<code>for</code>循环不支持遍历函数返回的以指针形式表示的数组，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">retStr</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> ch: <span class="built_in">retStr</span>()) <span class="comment">//直接报错</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因很简单，此格式的<code>for</code>循环只能遍历有明确范围的一组数据，上述程序中<code>retStr()</code>函数返回的是指针变量，范围遍历并未明确指明，所以编译失败。</p><p>3）当基于范围的<code>for</code>循环遍历的是某函数返回的<code>string</code>对象或者容器时，遍历整个过程中，函数只会执行一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::string g_myStr = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line"><span class="function">std::string <span class="title">getStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;g_myStr:&quot;</span> &lt;&lt; g_myStr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> g_myStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c11_for_tips_dm4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">getStr</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">/* 输出内容：</span></span><br><span class="line"><span class="comment">g_myStr:https://brkzh.github.io/</span></span><br><span class="line"><span class="comment">https://brkzh.github.io/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从程序执行结果看，整个<code>for</code>循环遍历<code>g_myStr</code>字符串对象的过程中，<code>getStr()</code>函数仅在遍历开始前执行了1次。</p><p>4）系统学习过<code>STL</code>标准库的都知道，基于关联式容器(包括哈希容器)底层存储机制的限制：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.不允许修改map、unordered<span class="built_in">_</span>map、multimap以及unordered<span class="built_in">_</span>multimap容器中存储的键的值；</span><br><span class="line">2.不允许修改set、unordered<span class="built_in">_</span>set、multiset以及unordered<span class="built_in">_</span>multiset容器中存储的元素的值。</span><br></pre></td></tr></table></figure><p>因此，当使用基于范围的<code>for</code>循环遍历此类容器时，切勿修改容器中不允许被修改的数据部分，否则会导致程序的执行中出现各种<code>Bug</code></p><p>另外，基于范围<code>for</code>循环完成对容器的遍历，其底层也是借助容器的迭代器实现的，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> val: vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">//向容器中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输出结果(结果不唯一)</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    -572662307</span></span><br><span class="line"><span class="comment">    -572662307</span></span><br><span class="line"><span class="comment">    -572662307</span></span><br><span class="line"><span class="comment">    -572662307</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序的执行结果并不是我们想要的，就是因为在<code>for</code>循环遍历<code>vec</code>容器的同时向该容器尾部添加了新的元素(对<code>vec</code>容器进行了扩容)，致使遍历容器所使用的迭代器失效，整个遍历过程出现错误。</p><p>在使用基于范围<code>for</code>循环遍历容器时，应避免在循环中修改容器存储元素的个数。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 非受限联合体(union)</title>
      <link href="/2023/08/09/CPlusPlus11/009.AboutUnion/"/>
      <url>/2023/08/09/CPlusPlus11/009.AboutUnion/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>非受限联合体(union)</p><span id="more"></span><h1 id="C-11-非受限联合体-union"><a href="#C-11-非受限联合体-union" class="headerlink" title="C++11 非受限联合体(union)"></a>C++11 非受限联合体(union)</h1><p>在<code>c/c++</code>中，联合体(<code>union</code>)时一种构造数据类型。在一个联合体内，可以定义多个不同类型的成员，这些成员将会共享这一块内存空间。老版本的<code>c++</code>为了和<code>c</code>语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在<code>c++11</code>中取消了。</p><p><code>C++11</code>标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">    Student s; <span class="comment">//含有非POD类型的成员，gcc-5.1.0 版本报错</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，因为<code>Student</code>类带有自定义的构造函数，所以是一个非<code>POD</code>类型的，这导致编译器报错，这种规定只是<code>c++</code>为了兼容<code>c</code>语言而制定的。随着发展，这种规定是没有必要的。</p><p><code>C++11</code>对<code>c++98</code>的改进：</p><p><strong>1）C++11允许非POD类型</strong></p><p><code>C++98</code>不允许联合体的成员是非<code>POD</code>类型，但是<code>C++11</code>中取消了这一规定。</p><p><code>POD</code>是<code>c++</code>中一个比较重要的概念，这里简单介绍下。<code>POD</code>是英文<code>Plain Old Data</code>的缩写，用来描述一个类型的属性。</p><p><code>POD</code>类型一般具有以下几种特征(包括<code>class</code>、<code>union</code>和<code>struct</code>等)：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数</span><br><span class="line">2.不能包含虚函数和虚基类</span><br><span class="line">3.非静态成员必须声明为public</span><br><span class="line">4.类中的第一个非静态成员的类型与基类不同，例如：</span><br><span class="line">class B1&#123;&#125;;</span><br><span class="line">class B2: B1 &#123; B1 b; &#125;;</span><br><span class="line">class B2的第一个非静态成员b是基类类型，所以它不是POD类型</span><br><span class="line">5.在类或者结构体继承时，满足以下两种情况之一：</span><br><span class="line">.派生类中有非静态成员，且只有一个仅包含境内太成员的基类</span><br><span class="line">.基类有非静态成员，而派生类没有非静态成员</span><br><span class="line">看看例子：</span><br><span class="line">class B1&#123; static int m; &#125;;</span><br><span class="line">class B2:B1 &#123; int n1; &#125;;</span><br><span class="line">class B3:B2 &#123; static int n2; &#125;;</span><br><span class="line">对于B2，派生类中有非静态成员，且只有一个仅包含静态成员的基类B1，所以它是POD类型</span><br><span class="line">对于B3，基类B2有非静态成员，而派生类B3没有非静态成员，所以它也是POD类型</span><br><span class="line">6.所有非静态数据成员均和其他基类也符合上述规则（递归定义），也就是说POD类型不能包含非POD类型数据</span><br><span class="line">7.此外，所有兼容C语言的数据类型都是POD类型（struct、union等不能违背上述规则）。</span><br></pre></td></tr></table></figure><p><strong>2）C++11允许联合体有静态成员</strong></p><p><code>C++11</code>删除了联合体不允许拥有静态成员的限制，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意，<strong>静态成员变量只能在联合体内定义</strong>，却不能在联合体外使用，这使得该规则很鸡肋、没有用。</p><p><strong>非寿险联合体的赋值注意事项</strong></p><p><code>C++11</code>规定，如果非受限制联合体内有一个非<code>POD</code>的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值运算符以及析构函数，也将被删除。</p><p>这条规则可能导致对象构造失败，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span></span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U u; <span class="comment">//构造失败，因为U的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，因为<code>string</code>类拥有自定义的构造函数，所以<code>U</code>的默认构造函数被删除；定义<code>U</code>的类型变量<code>u</code>需要调用默认构造函数，所以<code>u</code>也就无法定义成功。</p><p>解决上述问题，一般需要用到<code>placement new</code>定位<code>new</code>，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span></span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造时，采用<code>placement new</code>将<code>s</code>构造在其地址<code>&amp;s</code>上，这里<code>placement new</code>的唯一作用只是调用了一下<code>string</code>类的构造函数。注意，在析构时还需要调用<code>string</code>类的析构函数。</p><p><strong><code>placement new</code>是什么？</strong></p><p><code>palcement new</code>是<code>new</code>关键字的一种进阶用法，既可以在栈<code>stack</code>上生成对象，也可以在堆<code>heap</code>上生成对象。相对应地，常见的<code>new</code>的用法称为<code>operator new</code>，它只能在<code>heap</code>上生成对象。</p><p><code>placement new</code>的语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(address) <span class="built_in">ClassConstruct</span>(...)</span><br></pre></td></tr></table></figure><p><code>address</code>表示已有内存的地址，该内存可以在栈上，也可以在堆上；<code>ClassConstruct(...)</code>表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p><p><code>placement new</code>利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在<code>address</code>制定的内存中。上述例子中，<code>placement new</code>使用的是<code>s</code>的内存空间。</p><p><strong>非受限联合体的匿名声明和”枚举式类”</strong></p><p>匿名联合体是值不具名的联合体（也即没有名字的联合体），一般定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="type">int</span> x; &#125; <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，联合体<code>U</code>内定义了一个不具名的联合体，该联合体包含一个<code>int</code>类型的成员变量，称这个联合体为匿名联合体。</p><p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类时，这样的类被称为”枚举式类“。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a) : <span class="built_in">m_gender</span>(g), <span class="built_in">m_age</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> m_gender;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">bool</span> g, <span class="type">int</span> a) : <span class="built_in">m_s</span>(g, a) &#123; <span class="type">m_t</span> = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">int</span> i) : <span class="built_in">m_id</span>(i)&#123; <span class="type">m_t</span> = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">const</span> <span class="type">char</span>* n, <span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="type">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(m_name, n, size);</span><br><span class="line">        m_name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">m_t</span> = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Type <span class="type">m_t</span>;</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Student m_s;</span><br><span class="line">        <span class="type">int</span> m_id;</span><br><span class="line">        <span class="type">char</span> m_name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中使用了一个匿名非受限联合体，它作为类<code>Singer</code>的”变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是<code>c++98</code>标准中无法达到的(编译器会报错:<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>)。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- lambda匿名函数使用详解</title>
      <link href="/2023/08/08/CPlusPlus11/008.LambdaFunc/"/>
      <url>/2023/08/08/CPlusPlus11/008.LambdaFunc/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>lambda匿名函数使用详解</p><span id="more"></span><h1 id="C-11-lambda匿名函数使用详解"><a href="#C-11-lambda匿名函数使用详解" class="headerlink" title="C++11 lambda匿名函数使用详解"></a>C++11 lambda匿名函数使用详解</h1><p><code>lambda</code>用来表示一种匿名函数。简单地理解就是没有名称的函数，又称<code>lambda</code>表达式。</p><p><code>C++11</code>标准引入了<code>lambda</code>。</p><p><strong>lambda匿名函数的定义</strong></p><p>定义一个<code>lambda</code>匿名函数很简单，可以套用如下语法格式：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符] (参数) mutable noexcept/throw() -&gt; 返回值类型</span><br><span class="line">&#123;</span><br><span class="line">函数体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中各部分的含义如下：</p><p><strong>1）[外部变量访问方式说明符]</strong></p><p><code>[]</code>方括号用于向编译器表明当前是一个<code>lambda</code>表达式，其不能被省略。在方括号内部，可以注明当前<code>lambda</code>函数的函数体中可以使用哪些”外部变量“。</p><p>所谓外部变量，指的是和当前<code>lambda</code>表达式位于同一作用域内的所有局部变量。</p><p><strong>2）(参数)</strong></p><p>和普通函数的定义一样，<code>lambda</code>匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同<code>()</code>小括号一起省略。</p><p><strong>3）mutable</strong></p><p>此关键字可以省略，如果使用则之前的<code>()</code>小括号不能省略(参数个数可以为0)。默认情况下，对于以值传递方式引入的外部变量，不允许在<code>lambda</code>表达式内部修改它们的值(可以理解为这部分变量都是<code>const</code>常量)。而如果想修改它们，就必须使用<code>mutable</code>关键字。</p><p>注意：对于以值传递方式引入的外部变量，<code>lambda</code>表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p><p><strong>4）noexcept&#x2F;throw()</strong></p><p>可以省略，如果使用，在之前的<code>()</code>小括号不能省略。默认情况下，<code>lambda</code>函数的函数体中可以抛出任何类型的异常。而标注<code>noexcept</code>关键字，则表示函数体内不会抛出任何异常；使用<code>throw()</code>可以指定<code>lambda</code>函数内部可以抛出的异常类型。</p><p>指的一提的是，如果<code>lambda</code>函数标有<code>noexcept</code>而函数体内抛出了异常，又或者使用<code>throw()</code>限定了异常类型而函数体抛出了非指定类型的异常，这些异常无法使用<code>try-catch</code>捕获，会导致程序执行失败。</p><p><strong>5）-&gt;返回值类型</strong></p><p>指明<code>lambda</code>匿名函数的返回值类型。指的一提的是，如果<code>lambda</code>函数体内只有一个<code>return</code>语句，或者该函数返回<code>void</code>，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt;返回值类型</code>。</p><p><strong>6）函数体</strong></p><p>和普通函数一样，<code>lambda</code>匿名函数包含的内部代码都放在函数体中，该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p><p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。也就是说，在<code>lambda</code>表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p><p>最简单的<code>lambda</code>匿名函数：<code>[]&#123;&#125;</code></p><p>显然，此<code>lambda</code>匿名函数未引入任何外部变量<code>([]内为空)</code>，也没有传递任何参数，没有指定<code>mutable</code>、<code>noexcept</code>等关键字，没有返回值和函数体。所以，这是一个没有任何功能的<code>lambda</code>匿名函数。</p><p><strong>lambda匿名函数中的[外部变量]</strong></p><p>对于<code>lambda</code>匿名函数的使用，比较困惑的就是<code>[外部变量]</code>的使用了。如下表：</p><table><thead><tr><th>外部变量格式</th><th>功能</th></tr></thead><tbody><tr><td>[]</td><td>空方括号表示当前lambda匿名函数中不导入任何外部变量</td></tr><tr><td>[&#x3D;]</td><td>只有一个&#x3D;等号，表示以值传递的方式导入所有外部变量</td></tr><tr><td>[&amp;]</td><td>只有一个&amp;符号，表示以引用传递的方式导入所有外部变量</td></tr><tr><td>[val1, val2, …]</td><td>表示以值传递的方式导入val1、val2等指定的外部变量，同时多个变量之间没有先后次序</td></tr><tr><td>[&amp;val1, &amp;val2, …]</td><td>表示以引用传递的方式导入val1、val2等指定的外部变量，多个变量之间没有前后次序</td></tr><tr><td>[val, &amp;val2, …]</td><td>以上2中方式还可以混合使用，变量之间没有前后次序</td></tr><tr><td>[&#x3D;, &amp;val1, …]</td><td>表示除val1以引用传递的方式导入外，其他外部变量都以值传递的方式导入</td></tr><tr><td>[this]</td><td>表示以值传递的方式导入当前的this指针</td></tr></tbody></table><p><strong>注意：</strong>当个外部变量不允许以相同的传递方式导入多次。例如<code>[=, val1]</code>中，<code>val1</code>先后被以值的方式导入了2此，这是非法的。</p><p>【例1】<code>lambda</code>匿名函数的定义和使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;11.c++11_lambda.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//引入 sort函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_demo_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//对数组a中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num + <span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> x &lt; y; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : num)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出：1  2  3  4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序调用了<code>sort()</code>函数实现了对<code>num</code>数组中元素的升序排序，其中就用到了<code>lambda</code>匿名函数，而如果使用普通函数，需要实现如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sort_up</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_demo_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//对数组a的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num + <span class="number">4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> icir : num)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; icir &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序中，<code>sort_up()</code>函数的功能和上一个例子的<code>lambda</code>匿名函数完全相同。显然在类似的场景中，使用<code>lambda</code>匿名函数更有优势。</p><p>除此之外，虽然<code>lambda</code>匿名函数没有函数名称，但仍可以为其手动设置一个名称，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_demo_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display即为lambda匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">void</span> &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; b &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="comment">//调用lambda函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，程序中使用<code>auto</code>关键字为<code>lambda</code>匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p><p>【例子2】值传递和引用传递的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> gAllNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_demo_4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=] &#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in lambda1 print gAllNum:&quot;</span> &lt;&lt; gAllNum &lt;&lt; endl;</span><br><span class="line">        gAllNum = <span class="number">10</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in lambda1 After Modify print gAllNum:&quot;</span> &lt;&lt; gAllNum &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//函数提内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in lambda1 print num1 num2 num3:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After call lambda1, print gAllNum:&quot;</span> &lt;&lt; gAllNum &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">lambda1:</span></span><br><span class="line"><span class="comment">in lambda1 print gAllNum:0</span></span><br><span class="line"><span class="comment">in lambda1 After Modify print gAllNum:10</span></span><br><span class="line"><span class="comment">in lambda1 print num1 num2 num3:1 2 3</span></span><br><span class="line"><span class="comment">After call lambda1, print gAllNum:10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;] &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in lambda2 print gAllNum:&quot;</span> &lt;&lt; gAllNum &lt;&lt; endl;</span><br><span class="line">        gAllNum = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in lambda2 After Modify print gAllNum:&quot;</span> &lt;&lt; gAllNum &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in lambda2 print num1 num2 num3:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">        num1 = <span class="number">10</span>;</span><br><span class="line">        num2 = <span class="number">20</span>;</span><br><span class="line">        num3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;in lambda2 After Modify print num1 num2 num3:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After call lambda2, print gAllNum:&quot;</span> &lt;&lt; gAllNum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After call lambda2, print num1 num2 num3:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">lambda2:</span></span><br><span class="line"><span class="comment">in lambda2 print gAllNum:10</span></span><br><span class="line"><span class="comment">in lambda2 After Modify print gAllNum:100</span></span><br><span class="line"><span class="comment">in lambda2 print num1 num2 num3:1 2 3</span></span><br><span class="line"><span class="comment">in lambda2 After Modify print num1 num2 num3:10 20 30</span></span><br><span class="line"><span class="comment">After call lambda2, print gAllNum:100</span></span><br><span class="line"><span class="comment">After call lambda2, print num1 num2 num3:10 20 30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在创建<code>lambda1</code>和<code>lambda2</code>匿名函数的作用域中，有<code>num1</code>、<code>num2</code>和<code>num3</code>这3个局部变量，另外还有<code>gAllNum</code>全局变量。</p><p>其中，<code>lambda1</code>匿名函数是以<code>[=]</code>值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这3个局部变量的值，但全局变量<code>gAllNum</code>除外。相对地，<code>lambda2</code>匿名函数以<code>[&amp;]</code>引用传递的方式导入这3个局部变量，因此在该函数的内部就可以修改它们的值。</p><p>当然，如果想在<code>lambda1</code>匿名函数的基础上修改外部变量的值，可以借助<code>mutable</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;lambda3:\n&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda3 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in lambda3 use mutable print num1 num2 num3:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">    num1 = <span class="number">100</span>;</span><br><span class="line">    num2 = <span class="number">200</span>;</span><br><span class="line">    num3 = <span class="number">300</span>;</span><br><span class="line">    <span class="comment">//函数体内部只能使用外部变量，而无法对他们进行修改</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in lambda3 after modify print num1 num2 num3:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">lambda3</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After call lambda3, print num1 num2 num3:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">lambda3:</span></span><br><span class="line"><span class="comment">in lambda3 use mutable print num1 num2 num3:10 20 30</span></span><br><span class="line"><span class="comment">in lambda3 after modify print num1 num2 num3:100 200 300</span></span><br><span class="line"><span class="comment">After call lambda3, print num1 num2 num3:10 20 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意：在<code>lambda3</code>匿名函数中修改外部变量的值，但是需要注意，这里修改的仅仅是<code>num1、num2、num3</code>拷贝的那一份值，真正外部变量的值并不会发生改变。</p><p>【例子3】执行抛出异常类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_demo_5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="built_in">throw</span>(<span class="type">int</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">except</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>except</code>匿名函数中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助<code>try-catch</code>块成功捕获并处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_demo_6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> except2 = []() <span class="built_in">throw</span>(<span class="type">char</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">except1</span>();</span><br><span class="line">        <span class="built_in">except2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序运行会直接崩溃，原因很简单，<code>except1</code>匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；<code>except2</code>匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致<code>try-catch</code>无法捕获，最终程序运行崩溃。</p><p>如果不使用<code>noexcept</code>或者<code>throw()</code>，则<code>lambda</code>泥泞函数的函数体中允许发生任何类型的异常。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 列表初始化</title>
      <link href="/2023/08/07/CPlusPlus11/007.InitializationList/"/>
      <url>/2023/08/07/CPlusPlus11/007.InitializationList/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11列表初始化</p><span id="more"></span><h1 id="C-11列表初始化"><a href="#C-11列表初始化" class="headerlink" title="C++11列表初始化"></a>C++11列表初始化</h1><p>在<code>C++98/03</code>中的对象初始化方法有很多种，看看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> iArr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123;<span class="number">1</span>, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;; <span class="comment">//POD类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝初始化(copy-initialization)</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>; <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接初始化(direct-initialization)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p><p>为了同意初始化方式，并且让初始化行为具有确定的效果，<code>c++11</code>中提出了列表初始化<code>List-initialization</code>的概念。</p><p><code>POD</code>类型即<code>plain old data</code>类型，简单来说，是可以直接使用<code>memcpy</code>复制的对象。</p><p><strong>统一的初始化</strong></p><p>在上面已经看到，对于普通数组和<code>POD</code>类型，<code>C++98/03</code>可以使用初始化列表<code>initializer list</code>进行初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iArr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> lArr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。</p><p>在<code>c++11</code>中，初始化列表的适用性被大大增加了，它现在可以用于任何类型对象的初始化，看看下面代码：通过初始化列表初始化对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">al</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>; <span class="comment">//error: &#x27;Foo::Foo(const Foo&amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123;<span class="number">123</span>&#125;;</span><br><span class="line">    Foo a4 &#123;<span class="number">1234</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a5 = &#123;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a6 &#123;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，<code>a3、a4</code>使用了新的初始化方式来初始化对象，效果如同<code>a1</code>的直接初始化。</p><p><code>a5、a6</code>则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。</p><p>这里需要注意的是，<code>a3</code>虽然使用了等于号，但是它仍然是列表初始化，因此，私有的拷贝构造函数并不会影响它。</p><p><code>a4和a6</code>的写法，是<code>c++98/03</code>所不具备的。在<code>c++11</code>中，可以直接在变量后面跟上初始化列表，来进行对象的初始化。</p><p>这种变量名后跟上初始化列表方法同样适用于普通数组和<code>POD</code>类型的初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iArr[] &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;; <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure><p>在初始化时，<code>&#123;&#125;</code>前面的等于号是否书写对初始化行为没有影响。</p><p>另外，<code>new</code>操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">123</span>&#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123;<span class="number">12.12</span>&#125;;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>指针<code>a</code>指向了一个<code>new</code>操作符返回的内存，通过初始化列表方式在内存初始化时指定了值未<code>123</code>。</p><p><code>b</code>则是对匿名对象使用列表初始化后，再进行拷贝初始化。</p><p>注意<code>arr</code>的初始化方式，堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p><p>除了上述之外，列表初始化还可以直接使用在函数的返回值上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">123</span>, <span class="number">12.12</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>return</code>语句就如同返回了一个<code>Foo(123,12.12)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- tuple元组</title>
      <link href="/2023/08/06/CPlusPlus11/006.AboutTuple/"/>
      <url>/2023/08/06/CPlusPlus11/006.AboutTuple/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11 tuple元组</p><span id="more"></span><h1 id="C-11-tuple元组"><a href="#C-11-tuple元组" class="headerlink" title="C++11 tuple元组"></a>C++11 tuple元组</h1><p><code>c++11</code>标准新引入了一种类模板，命名为<code>tuple</code>（元组）。<code>tuple</code>最大的特点是：<strong>实例化的对象可以存储任意数量、任意类型的数据</strong>。</p><p><code>tuple</code>的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用<code>tuple</code>；当函数需要返回多个数据时，可以将这些数据存储在<code>tuple</code>中，函数只需要返回一个<code>tuple</code>对象即可。</p><p><strong>tuple对象的创建</strong></p><p><code>tuple</code>本质是一个以可变模板参数定义的类模板，它定义在<code>&lt;tuple&gt;</code>头文件并位于<code>std</code>命名空间中。因此想要使用<code>tuple</code>类模板，需要引入以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br></pre></td></tr></table></figure><p>实例化<code>tuple</code>模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助<code>make_tuple()</code>函数。</p><p><strong>1）类的构造函数</strong></p><p><code>tuple</code>模板类提供有很多构造函数，包括：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//2.拷贝构造函数</span></span><br><span class="line"><span class="built_in">tuple</span> (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="comment">//3.移动构造函数</span></span><br><span class="line"><span class="built_in">tuple</span> (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="comment">//4.隐式类型转换构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... UTypes&gt;</span></span><br><span class="line"><span class="function">    <span class="title">tuple</span><span class="params">(<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl)</span></span>; <span class="comment">//左值方式</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... UTypes&gt;</span></span><br><span class="line"><span class="function">    <span class="title">tuple</span><span class="params">(tuple&lt;UTypes...&gt;&amp;&amp; tpl)</span></span>; <span class="comment">//右值方式</span></span><br><span class="line"><span class="comment">//5.支持初始化列表的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>.. UTypes&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="type">const</span> UTypes&amp;... elmes)</span></span>; <span class="comment">//左值方式</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>.. UTypes&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(UTypes&amp;... elems)</span></span>; <span class="comment">//右值方式</span></span><br><span class="line"><span class="comment">//6.将pair对象转换为tuple对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">tuple</span> <span class="params">(<span class="type">const</span> pair&lt;U1,U2&gt;&amp; pr)</span></span>; <span class="comment">//左值方式</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">tuple</span> <span class="params">(pair&lt;U1,U2&gt;&amp;&amp; pr)</span></span>; <span class="comment">//右值方式</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span> <span class="comment">//std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;  <span class="comment">//1) first&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">second</span><span class="params">(first)</span></span>; <span class="comment">//2) second&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">third</span><span class="params">(std::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span></span>; <span class="comment">//3) third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>; <span class="comment">//4)的左值方式,fourth&#123;20, &#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">fifth</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>; <span class="comment">//5)的右值方式,fifth&#123;10,&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">sixth</span><span class="params">(std::make_pair(<span class="number">30</span>,<span class="string">&#x27;c&#x27;</span>))</span></span>; <span class="comment">//6)的右值方式,sizth&#123;30,&#x27;c&#x27;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）make_tuple()函数</strong></p><p>上面的程序中，已经用到了<code>make_tuple()</code>函数，它以模板的形式在<code>&lt;tuple&gt;</code>头文件中，功能是创建一个<code>tuple</code>右值对象(或者临时对象)。</p><p>对于<code>make_tuple()</code>函数创建了<code>tuple</code>对象，我们可以上面的程序中那样作为移动构造函数的参数，也可以这样使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">make_tuple</span>(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>); <span class="comment">//tuple&lt;int, char&gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = std::<span class="built_in">make_tuple</span>(a,b); <span class="comment">//tuple&lt;int, int*&gt;</span></span><br></pre></td></tr></table></figure><p>程序中分别创建了<code>first</code>和<code>second</code>两个<code>tuple</code>对象，它们的类型可以直接用<code>auto</code>表示。</p><p><strong>tuple常用函数</strong></p><p>为了方便在实际开发中使用<code>tuple</code>对象，<code>tuple</code>模板类提供了一个功能使用的成员函数，<code>&lt;tuple&gt;</code>头文件中也提供了一些和操作<code>tuple</code>对象相关的函数模板和类模板，如下表：</p><table><thead><tr><th>函数或类模板</th><th>描述</th></tr></thead><tbody><tr><td><code>tup1.swap(tup2)</code></td><td><code>tup1</code>和<code>tup2</code>表示类型相同的两个<code>tuple</code>对象，<code>tuple</code>模板类中定义有一个<code>swap()</code>成员函数，<code>&lt;tuple&gt;</code>头文件还提供了一个同名的<code>swap()</code>全局函数</td></tr><tr><td><code>swap(tup1, tup2)</code></td><td><code>swap()</code>函数的功能是交换两个<code>tuple</code>对象存储的内容</td></tr><tr><td><code>get&lt;num&gt;(tup)</code></td><td><code>tup</code>表示某个<code>tuple</code>对象，<code>num</code>是一个整数，<code>get()</code>是<code>&lt;tuple&gt;</code>头文件中提供的全局函数，功能是返回<code>tup</code>对象中第<code>num+1</code>个元素</td></tr><tr><td><code>tuple_size&lt;type&gt;::value</code></td><td><code>tuple_size</code>是定义在<code>&lt;tuple&gt;</code>头文件的类模板，它只有一个成员变量<code>value</code>，功能是获取某个<code>tuple</code>对象中元素的个数，<code>type</code>为该<code>tuple</code>对象的类型</td></tr><tr><td><code>tuple_element&lt;l, type&gt;::type</code></td><td><code>tuple_element</code>是定义在<code>&lt;tuple&gt;</code>头文件的类模板，它只有一个成员变量<code>type</code>，功能是获取某个<code>tuple</code>对象第<code>l+1</code>个元素的类型</td></tr><tr><td><code>forward_as_tuple&lt;args...&gt;</code></td><td><code>args...</code>表示<code>tuple</code>对象存储的多个元素，该函数的功能是创建一个<code>tuple</code>对象，内部存储的<code>args...</code>元素都是右值引用形式的</td></tr><tr><td><code>tie(args...) = tup</code></td><td><code>tup</code>表示某个<code>tuple</code>对象，<code>tie()</code>是<code>&lt;tuple&gt;</code>头文件提供的，功能是将<code>tup</code>内存存储的元素逐一赋值给<code>args...</code>指定的左值变量</td></tr><tr><td><code>tuple_cat(args...)</code></td><td><code>args...</code>表示多个<code>tuple</code>对象，该函数是<code>&lt;tuple&gt;</code>头文件提供的，功能是创建一个<code>tuple</code>对象，此对象包含<code>args...</code>指定的所有<code>tuple</code>对象内的元素</td></tr></tbody></table><p><code>tuple</code>模板类对赋值运算符<code>=</code>进行了重载，是的同类的<code>tuple</code>对象可以直接赋值，此外，<code>tuple</code>模板类还重载了<code>==、!=、&lt;、&gt;、&gt;=、&lt;=</code>这几个比较运算符，同类型的<code>tuple</code>对象可以相互比较(逐个比较各个元素)。</p><p>演示程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tuple_demo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="comment">//创建一个tuple对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//计算mytuple存储元素的个数</span></span><br><span class="line">size = std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line"><span class="comment">//size = std::tuple_size&lt;std::tuple&lt;int, char&gt;&gt;::value;  //与上行等价</span></span><br><span class="line"><span class="comment">//输出mytuple中存储的元素</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; std::endl; <span class="comment">//输出：10  x</span></span><br><span class="line"><span class="comment">//修改指定元素</span></span><br><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;<span class="comment">//输出：100</span></span><br><span class="line"><span class="comment">//使用make_tuple()创建一个tuple对象</span></span><br><span class="line"><span class="keyword">auto</span> bar = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line"><span class="comment">//拆解bar对象，分贝赋值给mystr、mydou、myint</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> mydou;</span><br><span class="line"><span class="type">int</span> myint;</span><br><span class="line"><span class="comment">//使用tie()是，如果不想接收某个元素的值，实参可以用std::ignore代替</span></span><br><span class="line">std::<span class="built_in">tie</span>(mystr, mydou, myint) = bar;</span><br><span class="line"><span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar; //只接收第3个整形值</span></span><br><span class="line"><span class="comment">//将mytuple和bar中的元素整合到1个tuple对象中</span></span><br><span class="line"><span class="keyword">auto</span> mycat = std::<span class="built_in">tuple_cat</span>(mytuple, bar);</span><br><span class="line">size = std::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line"><span class="comment">//size = std::tuple_size&lt;std::tuple&lt;int, char, char*, double, int&gt;&gt;::value;</span></span><br><span class="line">std::cout &lt;&lt; size &lt;&lt; std::endl;<span class="comment">//输出：5</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 支持函数模板的默认模板参数</title>
      <link href="/2023/08/05/CPlusPlus11/005.DefaultTemplateParamForFunctionTemplates/"/>
      <url>/2023/08/05/CPlusPlus11/005.DefaultTemplateParamForFunctionTemplates/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11支持函数模板的默认模板参数</p><span id="more"></span><h1 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h1><p>在<code>c++98/03</code>标准中，类模板可以有默认的模板参数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">int</span>, U N = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是却不支持函数的默认模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt; <span class="comment">//error in c++98/03: default template arguments</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这一限制在<code>C++11</code>中别解除了，上面的<code>func</code>函数在<code>c++11</code>中可以直接使用，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时模板参数<code>T</code>的类型就为默认的<code>int</code>。上述例子中，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后面跟队<code>&lt;&gt;</code>来实例化。</p><p>除了上面提到的部分外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数列表最后的限制。甚至于，根据实际场景中函数模板被调用的清醒，编译器还可以自行推导出部分模板参数的类型。</p><p>这意味着，当默认模板参数和编译器自定推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R </span>= <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">func</span><span class="params">(U val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>); <span class="comment">//R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>); <span class="comment">//R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>,<span class="type">int</span>&gt;(<span class="number">97</span>); <span class="comment">//R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>c++11</code>标准中，我么可以像<code>func(97)</code>这样调用模板函数，因为编译器可以根据实参97自行推导模板参数<code>U</code>的类型为<code>int</code>，并且根据返回值<code>val=97</code>推导出<code>R</code>的类型也为<code>int</code>，而<code>func&lt;char&gt;(97)</code>手动指定了模板参数<code>R</code>的类型为<code>char</code>(默认模板将无效化)，并通过实参97推导出了<code>U=int</code>，最后<code>func&lt;double,int&gt;(97)</code>手动指定了<code>R</code>和<code>U</code>的类型值，因此无需编译器自定推导。</p><p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会使用默认模板参数；如果模板参数无法推导出来，又未设置其默认值，则编译器直接报错，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U </span>= <span class="type">double</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>func(&#39;c&#39;)</code>的这种调用方式，编译器通过实参<code>&#39;c&#39;</code>可以推导出<code>T=char</code>，但由于未传递第2个实参，因此模板参数<code>U</code>使用的时默认参数<code>double</code>，但<code>func()</code>的调用方式是不行的，虽然<code>val1</code>设置有默认值，但是编译器无法通过该默认值推导出模板参数<code>T</code>的类型。</p><p>总的来说，<code>c++11</code>支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以尝试由编译器自行推导得到，还可以亲自指定各个模板参数的类型。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 使用using定义别名</title>
      <link href="/2023/08/04/CPlusPlus11/004.UsingDefineAliases/"/>
      <url>/2023/08/04/CPlusPlus11/004.UsingDefineAliases/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++11使用using定义别名。</p><span id="more"></span><h1 id="C-11使用using定义别名"><a href="#C-11使用using定义别名" class="headerlink" title="C++11使用using定义别名"></a>C++11使用using定义别名</h1><p>在<code>C++</code>中可以通过<code>typedef</code>重定义一个类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br></pre></td></tr></table></figure><p>被重定义的类型并不是一个新的类型，仅仅是原有的类型取了一个新的名字。因此，下面的函数重载是非法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">uint_t</span>)</span></span>;  <span class="comment">//error: redefinition</span></span><br></pre></td></tr></table></figure><p>使用<code>typedef</code>重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。</p><p>如下场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, std::string&gt; <span class="type">map_str_t</span>;</span><br></pre></td></tr></table></figure><p>我们需要的其实是一个固定以<code>std::string</code>为<code>key</code>的<code>map</code>，它可以映射到<code>int</code>或另一个<code>std::string</code>。然而这个简单的需求仅仅通过<code>typedef</code>却很难办到。</p><p>因此，在<code>c++98/03</code>中往往不得不这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type mapl;</span><br></pre></td></tr></table></figure><p>一个虽然简单但却略显繁琐的<code>str_map</code>外敷类是必要的。这明显让我们在复用某些泛型代码是非常难受。</p><p>现在，<code>c++11</code>中出现了可以重定义一个模板的语法，看看示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; mapl;</span><br></pre></td></tr></table></figure><p>这里使用新的<code>using</code>别名语法定义了<code>std::map</code>的模板别名<code>str_map_t</code>。比起前面使用外敷模板加<code>typedef</code>构建的<code>str_map</code>，它完全就像是一个新的<code>map</code>类模板，简洁多了。</p><p>实际上，<code>using</code>的别名语法覆盖了<code>typedef</code>的全部功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef`的定义方法和变量的声明类似；像声明一个变量一样，声明一个重定义类型，之后在声明之前加上`typedef`即可。这种写法凸显了`c/c++`中的语法一致性，但有时候会增加代码的阅读难度。比如重定义一个函数指针时: `typedef void(*func<span class="built_in">_</span>t) (int,int);</span><br></pre></td></tr></table></figure><p>与之相比，<code>using</code>后面总是立即跟随新标识符<code>identifier</code>，之后使用类似赋值的语法，把现有的类型<code>type-id</code>赋给新类型；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>从上面的对比中可以发现，<code>c++11</code>的<code>using</code>别名语法比<code>typedef</code>更加清晰。因为<code>typedef</code>的别名语法本质上类似一种解方程的思路。而<code>using</code>语法通过赋值类定义别名，和我们平时的思考方式一致。 看看下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* c++98/03 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span>  <span class="title">void</span><span class="params">(*type)</span> <span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用func_t模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* c++11 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span>(*)(T,T);</span><br><span class="line"><span class="comment">//使用func_t模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure><p>上述例子中，通过<code>using</code>定义模板别名的语法，只是在普通类型别名语法的基础上增加<code>template</code>的参数列表。使用<code>using</code>可以轻松地创建一个新的模板别名，而不需要像<code>c++98/03</code>那样使用繁琐的外敷模板。</p><p>注意，<code>using</code>语法和<code>typedef</code>一样，并不会创建新的类型。也就是说，上面例子中<code>c++11</code>的<code>using</code>写法只是<code>typedef</code>的等价物。虽然<code>using</code>重定义的<code>func_t</code>是一个模板，但<code>func_t&lt;int&gt;</code>定义的<code>xx_2</code>并不是一个由类模板实例化后的类，而是<code>void(*)(int,int)</code>的别名。因此下面函数重载是非法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>(*func_call)(<span class="type">int</span>,<span class="type">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">func_t</span>&lt;<span class="type">int</span>&gt; func_call)</span></span>; <span class="comment">//error: redefintion</span></span><br></pre></td></tr></table></figure><p>同样是无法实现重载的，<code>func_t&lt;int&gt;</code>只是<code>void(*)(int,int)</code>类型的等价物，</p><p><code>using</code>重定义的<code>func_t</code>是一个模板，但它既不是类模板也不是函数模板(函数模板实例化后是一个函数)，而是一种新的模板形式：<strong>别名模板</strong>(<code>alias template</code>)。</p><p>其实，通过<code>using</code>可以轻松定义任意类型的模板表达方式，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">type_t</span> = T;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="type">type_t</span>&lt;<span class="type">int</span>&gt; i;</span><br></pre></td></tr></table></figure><p><code>type_t</code>实例化后的类型和它的模板参数类型等价。这里<code>type_t&lt;int&gt;</code>将等价于<code>int</code>。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 对模板实例化中连续右尖括号&gt;&gt;的改进</title>
      <link href="/2023/08/03/CPlusPlus11/003.ImprovementRightAngleBracketsin/"/>
      <url>/2023/08/03/CPlusPlus11/003.ImprovementRightAngleBracketsin/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>对模板实例化中连续右尖括号&gt;&gt;的改进</p><span id="more"></span><h1 id="C-11对模板实例化中连续右尖括号-的改进"><a href="#C-11对模板实例化中连续右尖括号-的改进" class="headerlink" title="C++11对模板实例化中连续右尖括号&gt;&gt;的改进"></a>C++11对模板实例化中连续右尖括号&gt;&gt;的改进</h1><p>在<code>C++98/03</code>的泛型编程中，模板实例化有一个很繁琐的地方，那就是连续两个右尖括号<code>&gt;&gt;</code>会被编译器解释成右移操作符，而不是模板参数表的结束。</p><p><strong>在C++98&#x2F;03中不支持连续两个右尖括号的示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo&lt;A&lt;<span class="type">int</span>&gt;&gt;::type xx; <span class="comment">//编译出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>gcc</code>编译时，会得到如下错误提示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: &#x27;&gt;&gt;&#x27; should be &#x27;&gt;&gt;&#x27; within a nested template argument list Foo&lt;A&lt;int&gt;&gt;::type xx;</span><br></pre></td></tr></table></figure><p>意思就是，<code>Foo&lt;A&lt;int&gt;&gt;</code>这种写法是不被支持的，要写成这样<code>Foo&lt;A&lt;int&gt; &gt;</code>，注意有空格。</p><p>这种限制无疑是很没有必要的，在<code>C++</code>的各种成对括号中，目前只有右尖括号连续两个会出现这种二义性。<code>static_cast、reinterpret_cast</code>等<code>c++</code>标准转换运算符，都是使用<code>&lt;&gt;</code>来获得转换类型<code>(type-id)</code>的，若这个<code>type-id</code>本身是一个模板，用起来会很不方便。</p><p>现在在<code>C++11</code>中，这种限制被取消了，在<code>c++11</code>标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出<code>&gt;&gt;</code>是一个右移操作符还是模板参数表的结束标记(<code>delimiter</code>，界定符)。</p><p>不过这种自动化的处理在某些时候会与老标准不兼容，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo&lt;<span class="number">100</span> &gt;&gt; <span class="number">2</span>&gt; xx;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在<code>C++98/03</code>的编译器中是没有问题的，但是在<code>c++11</code>的编译器会显示：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: expected unqualif?ied-id before &#x27;&gt;&#x27; token Foo&lt;100 &gt;&gt; 2&gt; xx;</span><br></pre></td></tr></table></figure><p>解决办法是，增加括号：<code>Foo&lt;(100 &gt;&gt; 2)&gt; xx;</code></p><p>这种加括号的写法其实也是一个良好的编程习惯，使得在书写时倾向于写出无二义性的代码。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 返回值类型后置</title>
      <link href="/2023/08/02/CPlusPlus11/002.ReturnValueFypeAfter/"/>
      <url>/2023/08/02/CPlusPlus11/002.ReturnValueFypeAfter/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p>C++返回值类型后置（跟踪返回值类型）</p><span id="more"></span><h1 id="C-返回值类型后置（跟踪返回值类型）"><a href="#C-返回值类型后置（跟踪返回值类型）" class="headerlink" title="C++返回值类型后置（跟踪返回值类型）"></a>C++返回值类型后置（跟踪返回值类型）</h1><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。考虑下面的场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">add</span>&lt;<span class="keyword">decltype</span>(a+b)&gt;(a,b);</span><br></pre></td></tr></table></figure><p>这里，我们并不关心<code>a+b</code>的类型是什么，因此，只需要通过<code>decltype(a+b)</code>直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有<code>add</code>函数才知道返回值应当如何推导。</p><p>那么，在<code>add</code>函数的定义上能不能直接通过<code>decltype</code>拿到返回值呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(t+u)</span> <span class="title">add</span><span class="params">(T t, U u)</span> <span class="comment">//error:t、u未定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，直接像上面这样写是编译不通过的。因为<code>t、u</code>在参数列表中，而<code>C++</code>的返回值是前置语法，在返回值定义的时候参数还不存在。可以改成以下写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(T() + U())</span> <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到<code>T、U</code>可能是没有无参构造函数的类，正确是写法应该是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">( (*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>) )</span> <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然成功地使用了<code>decltype</code>完成了返回值的推导，但是写法过于晦涩，会大大增加<code>decltype</code>在返回值类型推导上的使用难度并降低代码的可读性。</p><p>因此，在<code>C++11</code>中增加了**返回值类型后置(trailing-return-type,又称跟踪返回类型)**语法，将<code>decltype</code>和<code>auto</code>结合起来完成返回值类型的推导。</p><p>返回类型后置语法是通过<code>auto</code>和<code>decltype</code>结合起来使用的。上面的<code>add</code>函数，使用新的语法可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u)</span><br><span class="line">&#123;</span><br><span class="line">    return t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看另外一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T&amp; val)</span> -&gt;<span class="title">decltype</span><span class="params">(foo(val))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例子中，使用<code>decltype</code>结合返回值后置语法很容易推导出<code>foo(val)</code>可能出现的返回值类型，并将其用到了<code>func</code>上。</p><p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来。</p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- auto、decltype</title>
      <link href="/2023/08/01/CPlusPlus11/001.AboutAutoDecltype/"/>
      <url>/2023/08/01/CPlusPlus11/001.AboutAutoDecltype/</url>
      
        <content type="html"><![CDATA[<p><code>C++11</code>相关知识点。</p><p><a href="#auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">auto类型推导</a></p><p><a href="#decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">decltype类型推导</a></p><p><a href="#auto%E5%92%8Cdecltype%E7%9A%84%E5%8C%BA%E5%88%AB">auto和decltype的区别</a></p><span id="more"></span><h1 id="auto类型推导"><a href="#auto类型推导" class="headerlink" title="auto类型推导"></a>auto类型推导</h1><p>C++11中，auto有新的含义，使用它来做自动类型推导。</p><p>使用了auto关键字后，编译器会在编译期间自动推导出变量的类型，这样可以不用手动指明变量的数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> *pa = &amp;a;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">10.5</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure><p>auto除了可以独立使用外，还可以和某些具体类型混合使用，这样auto表示的就是”半个”类型，而不是完整的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x; <span class="comment">//p1为int*，auto推导为int</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2为int*，auto推导为int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1 = x; <span class="comment">//r1为int&amp;，auto推导为int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1; <span class="comment">//r2为int，auto推导为int</span></span><br></pre></td></tr></table></figure><p>注意，<code>r1</code>本来是<code>int&amp;</code>类型的，但是<code>auto</code>却被推导为<code>int</code>类型，这表明当<code>=</code>右边的表达式时一个引用类型时，<code>auto</code>会把引用抛弃掉，直接推导出它的原始类型。</p><p><code>auto</code>和<code>const</code>的结合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> n = x;  <span class="comment">//n为const int,auto被推导为int</span></span><br><span class="line"><span class="keyword">auto</span> f = n; <span class="comment">//f为const int，auto被推导为int（const属性会被抛弃掉）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;r1 = x; <span class="comment">//r1为const int&amp;类型，auto被推导为int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1; <span class="comment">//r1为const int&amp;类型，auto被推导为const int类型</span></span><br></pre></td></tr></table></figure><p>注意：<code>n</code>为<code>const int</code>类型，但是<code>auto</code>却被推导为<code>int</code>类型，这说明当<code>=</code>右边的表达式带有<code>const</code>属性时，<code>auto</code>不会使用<code>const</code>属性，二十直接推导出<code>non-const</code>类型。</p><p><code>r1</code>是<code>const int&amp;</code>类型，<code>auto</code>也被推导为<code>const int</code>类型，这说明当<code>const</code>和引用结合时，<code>auto</code>的推导将保留表达式的<code>const</code>类型。</p><p><strong>总结</strong> <code>auto</code>和<code>const</code>结合的用法：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当类型不为引用时，auto的推导结果将不保留表达式的const属性</span><br><span class="line">2.当类型为引用时，auto的推导结果将保留表达式的const属性</span><br></pre></td></tr></table></figure><p><strong>auto的限制</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用<span class="keyword">auto</span>的时候必须对变量进行初始化</span><br><span class="line"><span class="number">2.</span><span class="keyword">auto</span>不能在函数参数中使用</span><br><span class="line">    理解：在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而<span class="keyword">auto</span>必须对变量进行初始化，所以这就是矛盾。</span><br><span class="line"><span class="number">3.</span><span class="keyword">auto</span>不能用作于类的非静态成员变量（也就是没有<span class="type">static</span>关键字修饰的成员变量）中</span><br><span class="line"><span class="number">4.</span><span class="keyword">auto</span>关键字不能定义数组，比如下面的例子</span><br><span class="line">    <span class="type">char</span> url[] = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> str[] = url;  <span class="comment">//arr为数组，不能使用auto</span></span><br><span class="line"><span class="number">5.</span><span class="keyword">auto</span>不能用于模板函数，比如下面例子</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1; <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>auto的应用</strong></p><p>1.使用<code>auto</code>定义迭代器</p><p><code>auto</code>的一个典型的应用场景就是用来定义<code>stl</code>的迭代器。</p><p>在使用<code>stl</code>容器的时候，需要使用迭代器来遍历容器里面的元素；而不同容器的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂，书写起来又长又复杂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; vec;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = vec.<span class="built_in">begin</span>(); <span class="comment">//这太长了，直接用auto省事</span></span><br><span class="line">    <span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>(); <span class="comment">//auto根据表达式vec.begin()的类型(返回值类型)推导iter的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>auto</code>用于泛型编程</p><p><code>auto</code>的另一个应用就是当我们不知道变量是什么类型，或者不希望指明具体类型的时候，比如泛型编程中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;A&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中的模板函数<code>func()</code>会调用所有类的非静态函数<code>get()</code>，并对它的返回值做同意处理，但是<code>get()</code>的返回值类型并不一样，而且不能自动转换。这种要求在以前的<code>C++</code>版本中实现棋类非常的麻烦，需要额外增加一个模板参数，并在调用时手动给改模板参数赋值，用以指明变量<code>val</code>的类型。</p><p>但是有了<code>auto</code>类型自动推导，编译器就根据<code>get()</code>的返回值自己推导出<code>val</code>变量的类型，就不用再增加一个模板参数了。</p><p>不使用<code>auto</code>的解决方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;https://brkzh.github.io.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T2&gt; <span class="comment">//额外增加一个模板参数T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    T2 val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用时也要手动给模板参数赋值</span></span><br><span class="line">    <span class="built_in">func</span>&lt;A, <span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B, <span class="type">const</span> <span class="type">char</span>*&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试用例、代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名：1.auto_demo.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用auto的写法</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_auto</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用auto的写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T2&gt; <span class="comment">//额外增加一个模板参数T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_no_auto</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    T2 val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">auto_demo_main</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//文件名：1.auto_demo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;1.auto_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">auto_demo_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use auto&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func_auto</span>&lt;A&gt;();</span><br><span class="line">    <span class="built_in">func_auto</span>&lt;B&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;no use auto&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用时也要手动给模板参数赋值</span></span><br><span class="line">    <span class="built_in">func_no_auto</span>&lt;A, <span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">func_no_auto</span>&lt;B, <span class="type">const</span> <span class="type">char</span>*&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件名：main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;1.auto_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">auto_demo_main</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="decltype类型推导"><a href="#decltype类型推导" class="headerlink" title="decltype类型推导"></a>decltype类型推导</h1><p><code>decltype</code>是<code>c++11</code>新增的一个关键字，和<code>auto</code>的功能一样，都用来在编译时期进行自动类型推导。</p><p><code>decltype</code>是<code>declare type</code>的缩写，译为”声明类型“</p><p>有了<code>auto</code>关键字，为啥还需要<code>decltype</code>呢？因为<code>auto</code>并不适用于所有的自动类型推导场景，在某些特殊情况下<code>auto</code>用起来非常不方便，甚至压根无法使用，所以<code>decltype</code>关键字也被引入<code>C++11</code>中。</p><p><code>auto</code>和<code>decltype</code>关键字都可以自动推导出变量的类型，但是它们的用法是有区别的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname = value;</span><br></pre></td></tr></table></figure><p>其中<code>varname</code>是变量名，<code>value</code>表示赋值给变量的值，<code>exp</code>表示一个表达式。</p><p><code>auto</code>根据<code>=</code>右边的初始值<code>value</code>推导出变量的类型，而<code>decltype</code>根据<code>exp</code>表达式推导出变量的类型，跟<code>=</code>右边的<code>value</code>没有关系。</p><p>另外，<code>auto</code>要求变量必须初始化，而<code>decltype</code>不要求。<code>auto</code>是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。<code>decltype</code>可以写成下面的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(exp) varname;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10</span><span class="number">+99</span>) iVal;</span><br></pre></td></tr></table></figure><p><strong>exp注意事项</strong>：原则上讲，<code>exp</code>就是一个普通的表达式，它可以是任意复杂的形式，但是必须保证<code>exp</code>的结果是有类型的，不能是<code>void</code>；例如当<code>exp</code>调用一个返回值类型为<code>void</code>的函数时，<code>exp</code>的结果也是<code>void</code>类型，此时就会导致编译错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>; <span class="comment">//b被推导为int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>; <span class="comment">//x被推导为double</span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y; <span class="comment">//y被推导为double，此时y并没有初始化</span></span><br></pre></td></tr></table></figure><p><code>decltype</code>能够根据变量、字面量、带有运算符的表达式推导出变量的类型。</p><p><strong>decltype推导规则</strong></p><p>当程序员使用<code>decltype(exp)</code>获取类型时，编译器根据以下三条规则得出结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.如果exp是一个不被括号()包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么decltype(exp)的类型就和exp一致，这是最常见的情况；</span><br><span class="line">2.如果exp是函数调用，那么decltype(exp)的类型就和函数返回值的类型一致；</span><br><span class="line">3.如果exp是一个左值，或者被括号()包围，那么decltype(exp)的类型就是exp的引用；假设exp的类型为T，那么decltype(exp)的类型就是T<span class="built_in">&amp;</span>。</span><br></pre></td></tr></table></figure><p><code>exp</code>是一个普通表达式例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n; <span class="comment">//n为int类型，a被推导为int类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n; <span class="comment">//r为const int&amp;类型，b被推导为const int&amp;类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>; <span class="comment">//total为类Student的一个int类型的成员变量，c被推导为int</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;https://brkzh.github.io/&quot;</span>; <span class="comment">//stu.name为string类型的成员变量，url被推导为string</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exp</code>为函数调用的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="type">int</span> ,<span class="type">char</span>)</span></span>; <span class="comment">//返回值类型为int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//返回值类型为int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_init</span><span class="params">(<span class="type">double</span>)</span></span>; <span class="comment">//返回值类型为int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func_cint_r</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>; <span class="comment">//返回值类型为const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_r_r</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//返回值类型为const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>(<span class="number">100</span>,<span class="string">&#x27;r&#x27;</span>)) a = n; <span class="comment">//a的类型为int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r_r</span>()) b = <span class="number">0</span>; <span class="comment">//b的类型为int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>(<span class="number">19.5</span>)) c = <span class="number">0</span>; <span class="comment">//c的类型为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) x = n; <span class="comment">//x的类型为 const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_c_int_r_r</span>()) y = <span class="number">0</span>; <span class="comment">//y的类型为const int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>注意：<code>exp</code>中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的取执行函数代码。</p><p><code>exp</code>是左值，或者被<code>()</code>包围的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Base obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>; <span class="comment">//obj.x为类的成员访问表达式，符合规则一，a的类型为int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a; <span class="comment">//obj.x带有括号，符合规则三，b的类型为int&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>; <span class="comment">//n+m得到一个右值，符合规则一，所以推导结果为int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c; <span class="comment">//n=n+m 得到一个左值，符合规则三，所以推导结果为int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点说明：左值是值那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是值那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。</p><p><strong>decltype的实际应用</strong></p><p><code>auto</code>的语法格式比<code>decltype</code>简单，所以在一般的类型推导中，使用<code>auto</code>比使用<code>decltype</code>更加方便。</p><p><code>auto</code>只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果想要推导非静态成员的类型，这个时候就必须使用<code>decltype</code>了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_decltype</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_itt = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it; <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &gt; obj;</span><br><span class="line">    obj.<span class="built_in">func_decltype</span>(vec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，单独看<code>Base</code>类中的<code>m_it</code>成员的定义，很难看出有什么错误，但是在使用<code>Base</code>类的时候，如果传入一个<code>const</code>类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当<code>T</code>是一个<code>const</code>容器时，应当使用<code>const_iterator</code>。</p><p>想要解决这个问题，在之前的<code>C++ 98/03</code>版本下只能想办法把<code>const</code>类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了<code>C++11</code>的<code>decltype</code>关键字，就可以直接这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_decltype</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>&lt;<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it; <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：有些低版本的编译器不支持<code>T().begin()</code>这种写法，在<code>VS2019</code>下可以测试通过，但是在<code>VS2015</code>下测试失败。</p><h1 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h1><p><strong>语法格式的区别</strong></p><p><code>auto</code>和<code>decltype</code>都是<code>c++11</code>新增的关键字，都用于自动类型推导，但是它们的语法格式有区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> varname = value;</span><br><span class="line"><span class="keyword">decltype</span>(exp) varname [ = value];  <span class="comment">//中括号代表可有可无</span></span><br></pre></td></tr></table></figure><p><code>auto</code>和<code>decltype</code>都会自动推导出变量的<code>varname</code>的类型；</p><p><code>auto</code>根据<code>=</code>右边的初始值推导出类型</p><p><code>decltype</code>根据<code>exp</code>表达式推导出变量的类型。</p><p>另外<code>auto</code>要求变量必须初始化，也就是在定义变量的同时必须给它赋值，而<code>decltype</code>不要求，初始化与否都不影响变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10</span>) n2 = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">auto</span> url1 = <span class="string">&quot;https://github.com/brkzh&quot;</span>;</span><br><span class="line"><span class="keyword">decltype</span>(url1) url2 = <span class="string">&quot;https://brkzh.github.io/&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = <span class="number">12.5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(n1*<span class="number">6.7</span>) f2;</span><br></pre></td></tr></table></figure><p><strong>对cv限定符的处理</strong></p><p><code>cv限定符</code> 是<code>const</code>和<code>volatile</code>关键字的统称。</p><p><code>const</code>关键字用来表示数据是只读的，也就是不能被修改。</p><p><code>volatile</code>和<code>const</code>是相反的，它用来表示数据是可变的、易变的，目的是不让<code>CPU</code>将数据缓存到寄存器，而是从原始的内存中读取。</p><p>在推导变量类型时，<code>auto</code>和<code>decltype</code>对<code>cv</code>限定符的处理是不一致的。<code>decltype</code>会保留<code>cv</code>限定符，而<code>auto</code>有可能会去掉<code>cv</code>限定符。</p><p>以下是<code>auto</code>关键字对<code>cv</code>限定符的推导规则</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果表达式的类型不是指针或者引用，auto会把cv限定符直接抛弃，推到成non-const或者non-volatile类型；</span><br><span class="line">2.如果表达式的类型是指针类或者引用，auto将保留cv限定符。</span><br></pre></td></tr></table></figure><p>例子：演示对<code>const</code>限定符的推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非指针非引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n2 = <span class="number">10</span>;</span><br><span class="line">n2 = <span class="number">99</span>; <span class="comment">//赋值不报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(n1) n3 = <span class="number">20</span>;</span><br><span class="line">n3 = <span class="number">5</span>; <span class="comment">//赋值报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;n1;</span><br><span class="line"><span class="keyword">auto</span> p2 = p1;</span><br><span class="line">*p2 = <span class="number">66</span>; <span class="comment">//赋值报错   常量指针，指向的是常量值，值不可以修改，但指针可以指向其他</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(p1) p3 = p1;</span><br><span class="line">*p3 = <span class="number">19</span>; <span class="comment">//赋值报错</span></span><br></pre></td></tr></table></figure><p>在<code>C++</code>中无法将一个变量的完整类型输出，我们通过对变量赋值类判断它是否被<code>const</code>修饰，如果被<code>const</code>修饰那么赋值失败，如果不被<code>const</code>修饰那么赋值成功。</p><p><strong>对引用的处理</strong></p><p>当表达式的类型为引用时，<code>auto</code>和<code>decltype</code>的推导规则也不一样，<code>decltype</code>会保留引用类型，而<code>auto</code>会抛弃引用类型，直接推导出它的原始类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;r1 = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//auto推导</span></span><br><span class="line">    <span class="keyword">auto</span> r2 = r1;</span><br><span class="line">    r2 = <span class="number">20</span>;</span><br><span class="line">    cout&lt;&lt;n &lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;r1&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//输出：10, 10, 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//decltype推导</span></span><br><span class="line">    <span class="keyword">decltype</span>(r1) r3 = n;</span><br><span class="line">    r3 = <span class="number">99</span>;</span><br><span class="line">    cout&lt;&lt;n &lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;r1&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//输出：99, 99, 99</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以发现，给<code>r2</code>赋值并没有改变<code>n</code>的值，说明<code>r2</code>没有指向<code>n</code>，而是自立门户，单独拥有了一块内存，这就证明<code>r</code>不再是引用类型，它的引用类型被<code>auto</code>抛弃了。</p><p>给<code>r3</code>赋值，<code>n</code>的值也跟着改变了，说明<code>r3</code>让然指向<code>n</code>，它的引用类型被<code>decltype</code>保留了。</p><p><strong>总结</strong></p><p><code>auto</code>虽然在书写上比<code>decltype</code>简单，但是它的推导规则复杂，有时候会改变表达式的原始类型，而<code>decltype</code>比较纯粹，它一般会坚持保留原始表达式的任何类型，让推导的结果更加原汁原味。</p><p>从代码是否健壮的角度考虑，推荐使用<code>decltype</code>，它没有那么复杂，但是<code>decltype</code>总是显得比较麻烦，尤其是当表达式比较复杂时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">decltype</span>(nums.<span class="built_in">begin</span>()) it = nums.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//而auto就会清爽很多</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums2;</span><br><span class="line"><span class="keyword">auto</span> it2 = nums<span class="number">2.</span><span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11知识点 -- 导航栏</title>
      <link href="/2023/07/31/CPlusPlus11/000.CPlusPlus11Index/"/>
      <url>/2023/07/31/CPlusPlus11/000.CPlusPlus11Index/</url>
      
        <content type="html"><![CDATA[<p><strong>快速导航</strong></p><span id="more"></span><p><a href="https://brkzh.github.io/2023/08/01/CPlusPlus11/001.AboutAutoDecltype/">C++11知识点 – auto、decltype</a></p><p><a href="https://brkzh.github.io/2023/08/02/CPlusPlus11/002.ReturnValueFypeAfter/">C++11知识点 – 返回值类型后置</a></p><p><a href="https://brkzh.github.io/2023/08/03/CPlusPlus11/003.ImprovementRightAngleBracketsin/">C++11知识点 – 对模板实例化中连续右尖括号&gt;&gt;的改进</a></p><p><a href="https://brkzh.github.io/2023/08/04/CPlusPlus11/004.UsingDefineAliases/">C++11知识点 – 使用using定义别名</a></p><p><a href="https://brkzh.github.io/2023/08/05/CPlusPlus11/005.DefaultTemplateParamForFunctionTemplates/">C++11知识点 – 支持函数模板的默认模板参数</a></p><p><a href="https://brkzh.github.io/2023/08/06/CPlusPlus11/006.AboutTuple/">C++11知识点 – tuple元组</a></p><p><a href="https://brkzh.github.io/2023/08/07/CPlusPlus11/007.InitializationList/">C++11知识点 – 列表初始化</a></p><p><a href="https://brkzh.github.io/2023/08/08/CPlusPlus11/008.LambdaFunc/">C++11知识点 – lambda匿名函数使用详解</a></p><p><a href="https://brkzh.github.io/2023/08/09/CPlusPlus11/009.AboutUnion/">C++11知识点 – 非受限联合体(union)</a></p><p><a href="https://brkzh.github.io/2023/08/10/CPlusPlus11/010.AboutForLoop/">C++11知识点 – for循环</a></p><p><a href="https://brkzh.github.io/2023/08/11/CPlusPlus11/011.AbountConstexprAndConst/">C++11知识点 – constexpr常量表达式相关</a></p><p><a href="https://brkzh.github.io/2023/08/12/CPlusPlus11/012.AboutLongLongDesc/">C++11知识点 – long long超长整形详解</a></p><p><a href="https://brkzh.github.io/2023/08/13/CPlusPlus11/013.RvalueReference/">C++11知识点 – 右值引用</a></p><p><a href="https://brkzh.github.io/2023/08/14/CPlusPlus11/014.MoveConstructorsFunc/">C++11知识点 – 移动构造函数的功能和用法</a></p><p><a href="https://brkzh.github.io/2023/08/15/CPlusPlus11/015.StdMoveFunc/">C++11知识点 – move()函数</a></p><p><a href="https://brkzh.github.io/2023/08/16/CPlusPlus11/016.ReferenceQualifier/">C++11知识点 – 引用限定符</a></p><p><a href="https://brkzh.github.io/2023/08/17/CPlusPlus11/017.PerfectForwarding/">C++11知识点 – 完美转发及其实现</a></p><p><a href="https://brkzh.github.io/2023/08/18/CPlusPlus11/018.AboutNullptr/">C++11知识点 – nullptr：初始化空指针</a></p><p><a href="https://brkzh.github.io/2023/08/19/CPlusPlus11/019.AboutShared_Ptr/">C++11知识点 – shared_ptr智能指针</a></p><p><a href="https://brkzh.github.io/2023/08/20/CPlusPlus11/020.AboutUnique_Ptr/">C++11知识点 – unique_ptr智能指针</a></p><p><a href="https://brkzh.github.io/2023/08/21/CPlusPlus11/021.AboutWeak_Ptr/">C++11知识点 – weak_ptr智能指针</a></p>]]></content>
      
      
      <categories>
          
          <category> CPlusPlus11 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 二叉树(链式存储)</title>
      <link href="/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/"/>
      <url>/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树-链式存储"><a href="#二叉树-链式存储" class="headerlink" title="二叉树(链式存储)"></a>二叉树(链式存储)</h1><p>链式存储二叉树的C++语言实现，模板方式。</p><span id="more"></span><p><strong>链式存储方式的结构示意图</strong></p><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_LinkedStorage_1.png" alt="BinaryTree_LinkedStorage_1"></p><p>需要用到链式栈、链式队列头文件，可以从之前文章中获取。</p><p><a href="https://brkzh.github.io/2023/06/08/DataStructureAndAlgorithms/008.LinkedStack/">数据结构与算法 – 链式栈 </a></p><p><a href="https://brkzh.github.io/2023/06/10/DataStructureAndAlgorithms/010.LinkedQueue/">数据结构与算法 – 链式队列</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkQueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkStack.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// 二叉树的链式存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ECCHILDSIGN</span><span class="comment">// 节点标记</span></span><br><span class="line">&#123;</span><br><span class="line">    E_Root,<span class="comment">// 树根</span></span><br><span class="line">    E_ChildLeft,<span class="comment">// 左孩子</span></span><br><span class="line">    E_ChildRight<span class="comment">// 右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* leftChild;<span class="comment">// 左子节点指针</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* rightChild;<span class="comment">// 右子节点指针</span></span><br><span class="line">    <span class="comment">// BinaryTreeNode&lt;T&gt;* parent;// 父节点指针</span></span><br><span class="line">    <span class="comment">// BinaryTreeNode* leftChild, rightChild, parent;// 这样写也可以，不用&lt;T&gt; ，因为是在类内部定义的，所以可以不需要加上&lt;T&gt;也可以</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为实现二叉树的非递归后序遍历引入的新模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode_extra</span></span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* point;</span><br><span class="line">    ECCHILDSIGN pointSign;<span class="comment">// 节点标记，标记该节点是 左孩子、右孩子、根</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BinaryTree</span>();</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建一个树节点</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">CreateNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="comment">// 释放树节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* pnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 利用扩展二叉树的前序遍历序列来创建一个二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPT</span><span class="params">(<span class="type">char</span>* pstr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(root, pstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 利用扩展二叉树的前序遍历序列创建二叉树的递归函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPTRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>*&amp; pstr)</span></span>;<span class="comment">// 参数类型为引用，确保递归调用中对参数的改变会影响到调用者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归方式前序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line">    <span class="comment">// 递归方式中序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line">    <span class="comment">// 递归方式后序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层序遍历二叉树</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int8_t</span> mis = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">levelOrder</span>(root, mis);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 参数2说明：=1 表示要判断该树是否是一颗完全二叉树，返回的结果记录在ifct里，如果返回-1，则不是一颗完全二叉树，返回1则是</span></span><br><span class="line">    <span class="comment">//=0 表示层序遍历输出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">int8_t</span>&amp; ifct)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断该树是否是一颗完全二叉树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IfCompleteTree</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求二叉树节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSize</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 也可以用遍历二叉树的方式求节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 左子树个数 + 右子树个数 + 1（之所以+1，是因为还有一个根节点）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSize</span>(tnode-&gt;leftChild) + <span class="built_in">GetSize</span>(tnode-&gt;rightChild) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求二叉树高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetHeight</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找某个节点（假设二叉树的节点各不相同）</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">SearchElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchElem</span>(root, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">SearchElem</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找某个节点的父节点（如果节点存在指向父节点的指针，那就很方便，如果不存在，那么就要从根开始查找）</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">GetParent</span><span class="params">(BinaryTreeNode&lt;T&gt;* tSonNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetParent</span>(root, tSonNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">GetParent</span><span class="params">(BinaryTreeNode&lt;T&gt;* tParNode, BinaryTreeNode&lt;T&gt;* tSonNode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 树的拷贝</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinaryTree&lt;T&gt;* targetTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">CopyTree</span>(root, targetTree-&gt;root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 注意参数2：是指针的引用， 因为需要修改参数2的值，得用引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinaryTreeNode&lt;T&gt;* sSource, BinaryTreeNode&lt;T&gt;*&amp; tTarget)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------- 非递归遍历操作</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">需要借助栈来实现</span></span><br><span class="line"><span class="comment">前序遍历  根 左 右</span></span><br><span class="line"><span class="comment">1) 现将根节点入栈</span></span><br><span class="line"><span class="comment">2) 如果栈不为空，则循环下面的步骤，直到栈为空</span></span><br><span class="line"><span class="comment">2.1) 栈顶元素出栈并访问（显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.2) 如果这个被访问的元素右子节点不为空，则把其右子节点入栈</span></span><br><span class="line"><span class="comment">2.3) 如果这个被访问的元素左子节点不为空，则把其左子节点入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">中序遍历 左 根 右</span></span><br><span class="line"><span class="comment">1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line"><span class="comment">2) 如果 栈不为空，则循环下面步骤</span></span><br><span class="line"><span class="comment">2.1) 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line"><span class="comment">(1) 将 当前节点的左子节点入栈,</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line"><span class="comment">2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历</span></span><br><span class="line"><span class="comment">左 右 根</span></span><br><span class="line"><span class="comment">1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"><span class="comment">2) 循环下面的步骤(循环1)：</span></span><br><span class="line"><span class="comment">2.1) 如果 当前节点 不为空，则循环(循环2)做两件事情，直到当前节点为空：</span></span><br><span class="line"><span class="comment">(1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 如果栈不为空，则循环(循环3)做如下事情：</span></span><br><span class="line"><span class="comment">(1) 栈顶元素出栈</span></span><br><span class="line"><span class="comment">(2) 如果出栈的元素有 &quot;左子树&quot;标记，则</span></span><br><span class="line"><span class="comment">(2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line"><span class="comment">(2.2) 重新将该元素入栈</span></span><br><span class="line"><span class="comment">(2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line"><span class="comment">(2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line"><span class="comment">(3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.3） 如果栈为空，则遍历结束，循环1结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------- ## 通过遍历序列创建二叉树</span></span><br><span class="line">    <span class="comment">// 结论：已知前序和中序遍历序列，是能够唯一确定一颗二叉树的。</span></span><br><span class="line">    <span class="comment">// 如何根据前序、中序遍历序列来创建一颗二叉树</span></span><br><span class="line">    <span class="comment">// 参数 pP_T：前序遍历序列(根左右)， 比如  “ABCDE”</span></span><br><span class="line">    <span class="comment">// 参数 pI_T：中序遍历序列(左根右)，比如 &quot;DBACE&quot;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPI</span><span class="params">(<span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPI</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何根据中序、后序遍历序列来创建一颗二叉树？</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordIPO</span><span class="params">(<span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordIPO</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* root;<span class="comment">// 树根节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// *************************************************************</span></span><br><span class="line"><span class="comment">// *************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTree&lt;T&gt;::<span class="built_in">BinaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTree&lt;T&gt;::~<span class="built_in">BinaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从根开始释放节点</span></span><br><span class="line">    <span class="built_in">ReleaseNode</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">ReleaseNode</span>(BinaryTreeNode&lt;T&gt;* pnode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(pnode-&gt;leftChild);</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(pnode-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pnode;<span class="comment">// delete一个空也无所谓</span></span><br><span class="line">    pnode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">CreateNode</span>(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (parentnode == <span class="literal">nullptr</span> &amp;&amp; pointSign != E_Root)<span class="comment">// 只有创建根节点时，parentnode才允许为nullptr</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新节点创建出来</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;</span><br><span class="line">    tmpnode-&gt;data = e;</span><br><span class="line">    tmpnode-&gt;leftChild = <span class="literal">nullptr</span>;</span><br><span class="line">    tmpnode-&gt;rightChild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新节点放入正确的位置</span></span><br><span class="line">    <span class="keyword">if</span> (pointSign == E_Root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)<span class="comment">// 已经存在了根节点，那么就把就得根节点释放掉，用新的替换</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpnode-&gt;leftChild = root-&gt;leftChild;</span><br><span class="line">            tmpnode-&gt;rightChild = root-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pointSign == E_ChildLeft)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是左孩子节点</span></span><br><span class="line">        parentnode-&gt;leftChild = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是右孩子节点</span></span><br><span class="line">        parentnode-&gt;rightChild = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式前序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">preOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式前序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历：根 左 右</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">        <span class="built_in">preOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        <span class="built_in">preOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式中序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">inOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式中序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 中序遍历：左 根 右</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">        <span class="built_in">inOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式后序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">postOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式后序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 后续遍历：左 右 根</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        <span class="built_in">postOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该树是否是一颗完全二叉树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BinaryTree&lt;T&gt;::<span class="built_in">IfCompleteTree</span>()<span class="comment">// 判断是否是一颗完全二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int8_t</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">levelOrder</span>(root, res);<span class="comment">// res返回来的值，要么是1 要么是 -1 </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">bool</span>)(res + <span class="number">1</span>);<span class="comment">// res + 1 然后强转成bool值，就不会出错了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数2说明：=1 表示要判断该树是否是一颗完全二叉树，返回的结果记录在ifct里，如果返回-1，则不是一颗完全二叉树，返回1则是</span></span><br><span class="line"><span class="comment">//=0 表示层序遍历输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">levelOrder</span>(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">int8_t</span>&amp; ifct)<span class="comment">// 层序遍历函数，因为判断一颗树是否是一颗完全二叉树，通过程序遍历 比较方便，在层序遍历中，如果某个节点不存在左孩子，却存在右孩子，那么肯定就不是一颗完全二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">        LinkQueue&lt;BinaryTreeNode&lt;T&gt;*&gt; lnobj;<span class="comment">// 注意队列的元素类型是  节点指针  类型</span></span><br><span class="line">        lnobj.<span class="built_in">EnQueue</span>(tnode);<span class="comment">// 先把根节点指针入队</span></span><br><span class="line">        <span class="keyword">while</span> (lnobj.<span class="built_in">IsEmpty</span>() == <span class="literal">false</span>)<span class="comment">// 循环判断队列是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            lnobj.<span class="built_in">DeQueue</span>(tmpnode);<span class="comment">// 出队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ifct != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果某个节点 左孩子不存在 却存在 右孩子 那么这棵树肯定不是一颗完全二叉树</span></span><br><span class="line">                <span class="keyword">if</span> (tmpnode-&gt;leftChild == <span class="literal">nullptr</span> &amp;&amp; tmpnode-&gt;rightChild)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;这颗二叉树不是一颗完全二叉树.&quot; &lt;&lt; endl;</span></span><br><span class="line">                    ifct = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ifct = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmpnode-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lnobj.<span class="built_in">EnQueue</span>(tmpnode-&gt;leftChild);<span class="comment">// 左孩子入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lnobj.<span class="built_in">EnQueue</span>(tmpnode-&gt;rightChild);<span class="comment">// 右孩子入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line">    &#125; <span class="comment">// end if</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用扩展二叉树的前序遍历序列创建二叉树的递归函数</span></span><br><span class="line"><span class="comment">// 参数类型为引用，确保递归调用中对参数的改变会影响到调用者</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPTRecu</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>*&amp; pstr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历序列：ABD###C#E##    根左右</span></span><br><span class="line">    <span class="keyword">if</span> (*pstr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根左右</span></span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = *pstr;</span><br><span class="line">        tnode-&gt;leftChild = <span class="literal">nullptr</span>;</span><br><span class="line">        tnode-&gt;rightChild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(tnode-&gt;leftChild, ++pstr);<span class="comment">// 创建左子树</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(tnode-&gt;rightChild, ++pstr);<span class="comment">// 创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二叉树高度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> BinaryTree&lt;T&gt;::<span class="built_in">GetHeight</span>(BinaryTreeNode&lt;T&gt;* tnode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftheight = <span class="built_in">GetHeight</span>(tnode-&gt;leftChild);<span class="comment">// 左子树高度</span></span><br><span class="line">    <span class="type">int</span> rightheight = <span class="built_in">GetHeight</span>(tnode-&gt;rightChild);<span class="comment">// 右子树高度</span></span><br><span class="line">    <span class="keyword">if</span> (leftheight &gt; rightheight)</span><br><span class="line">        <span class="keyword">return</span> leftheight + <span class="number">1</span>;<span class="comment">// 左子树高度 + 1（根节点）</span></span><br><span class="line">    <span class="keyword">return</span> rightheight + <span class="number">1</span>;<span class="comment">// 右子树高度 + 1（根节点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个节点（假设二叉树的节点各不相同）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">SearchElem</span>(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (tnode-&gt;data == e)<span class="comment">// 从根开始找</span></span><br><span class="line">        <span class="keyword">return</span> tnode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* p = <span class="built_in">SearchElem</span>(tnode-&gt;leftChild, e);<span class="comment">// 查找左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)<span class="comment">// 这里判断不可少</span></span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">// 在左孩子这里扎到了，那就返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SearchElem</span>(tnode-&gt;rightChild, e);<span class="comment">// 左子树查不到的情况，那就继续到右子树里面查找，这里直接return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个节点的父节点（如果节点存在指向父节点的指针，那就很方便，如果不存在，那么就要从根开始查找）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">GetParent</span>(BinaryTreeNode&lt;T&gt;* tParNode, BinaryTreeNode&lt;T&gt;* tSonNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tParNode == <span class="literal">nullptr</span> || tSonNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (tParNode-&gt;leftChild == tSonNode || tParNode-&gt;rightChild == tSonNode)</span><br><span class="line">        <span class="keyword">return</span> tParNode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* p_left = <span class="built_in">GetParent</span>(tParNode-&gt;leftChild, tSonNode);</span><br><span class="line">    <span class="keyword">if</span> (p_left != <span class="literal">nullptr</span>)<span class="comment">// 走到这里，如果在左孩子树中找到了，那就返回</span></span><br><span class="line">        <span class="keyword">return</span> p_left;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetParent</span>(tParNode-&gt;rightChild, tSonNode);<span class="comment">// 左孩子没找到，那么就去右孩子树递归找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的拷贝</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 注意参数2：是指针的引用， 因为需要修改参数2的值，得用引用</span></span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CopyTree</span>(BinaryTreeNode&lt;T&gt;* sSource, BinaryTreeNode&lt;T&gt;*&amp; tTarget)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sSource == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tTarget = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tTarget = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;</span><br><span class="line">        tTarget-&gt;data = sSource-&gt;data;</span><br><span class="line">        <span class="built_in">CopyTree</span>(sSource-&gt;leftChild, tTarget-&gt;leftChild);<span class="comment">// 对左子树进行拷贝</span></span><br><span class="line">        <span class="built_in">CopyTree</span>(sSource-&gt;rightChild, tTarget-&gt;rightChild);<span class="comment">// 对右子树进行拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************************** 非递归遍历操作</span></span><br><span class="line"><span class="comment">// 需要借助栈来实现</span></span><br><span class="line"><span class="comment">// 前序遍历  根 左 右</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 现将根节点入栈</span></span><br><span class="line"><span class="comment">2) 如果栈不为空，则循环下面的步骤，直到栈为空</span></span><br><span class="line"><span class="comment">2.1) 栈顶元素出栈并访问（显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.2) 如果这个被访问的元素右子节点不为空，则把其右子节点入栈</span></span><br><span class="line"><span class="comment">2.3) 如果这个被访问的元素左子节点不为空，则把其左子节点入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">preOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkStack&lt;BinaryTreeNode&lt;T&gt;*&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(troot);<span class="comment">// 根节点入栈</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">    <span class="keyword">while</span> (slinkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)<span class="comment">// 栈不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        slinkobj.<span class="built_in">Pop</span>(tmpnode);<span class="comment">// 栈顶元素出栈</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(tmpnode-&gt;rightChild);</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(tmpnode-&gt;leftChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 左 根 右</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line"><span class="comment">2) 如果 栈不为空，则循环下面步骤</span></span><br><span class="line"><span class="comment">2.1) 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line"><span class="comment">(1) 将 当前节点的左子节点入栈,</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line"><span class="comment">2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">inOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkStack&lt;BinaryTreeNode&lt;T&gt;*&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(troot);<span class="comment">// 1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* curr_node = troot;<span class="comment">// 这个可以不要，因为形参是指针类型，而不是指针引用，因此修改troot不会影响到外面， 但是为了方便阅读代码，直观表达 当前节点 这个概念，就直接使用curr_node来表示</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">    <span class="keyword">while</span> (slinkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr_node-&gt;leftChild != <span class="literal">nullptr</span>)<span class="comment">// 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(curr_node-&gt;leftChild);<span class="comment">// (1) 将 当前节点的左子节点入栈,</span></span><br><span class="line">            curr_node = curr_node-&gt;leftChild;<span class="comment">// (2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        slinkobj.<span class="built_in">Pop</span>(tmpnode);<span class="comment">// 2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)<span class="comment">// 2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            curr_node = tmpnode-&gt;rightChild;</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(curr_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="comment">// 左 右 根</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"><span class="comment">2) 循环下面的步骤(循环1)：</span></span><br><span class="line"><span class="comment">2.1) 如果 当前节点 不为空，则循环(循环2)做两件事情，直到当前节点为空：</span></span><br><span class="line"><span class="comment">(1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 如果栈不为空，则循环(循环3)做如下事情：</span></span><br><span class="line"><span class="comment">(1) 栈顶元素出栈</span></span><br><span class="line"><span class="comment">(2) 如果出栈的元素有 &quot;左子树&quot;标记，则</span></span><br><span class="line"><span class="comment">(2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line"><span class="comment">(2.2) 重新将该元素入栈</span></span><br><span class="line"><span class="comment">(2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line"><span class="comment">(2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line"><span class="comment">(3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.3） 如果栈为空，则遍历结束，循环1结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">postOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkStack&lt;BTNode_extra&lt;T&gt;&gt; linkobj;</span><br><span class="line">    BTNode_extra&lt;T&gt; ext_tmpnode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* curr_node = troot;<span class="comment">// 1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span><span class="comment">// 循环1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr_node != <span class="literal">nullptr</span>)<span class="comment">// 循环2</span></span><br><span class="line">        &#123;</span><br><span class="line">            ext_tmpnode.point = curr_node;</span><br><span class="line">            ext_tmpnode.pointSign = E_ChildLeft;<span class="comment">// 标记先处理该节点的左孩子</span></span><br><span class="line">            linkobj.<span class="built_in">Push</span>(ext_tmpnode);<span class="comment">// (1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line">            curr_node = curr_node-&gt;leftChild;<span class="comment">// (2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (linkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)<span class="comment">// 循环3</span></span><br><span class="line">        &#123;</span><br><span class="line">            linkobj.<span class="built_in">Pop</span>(ext_tmpnode);<span class="comment">// (1) 栈顶元素出栈</span></span><br><span class="line">            <span class="keyword">if</span> (ext_tmpnode.pointSign == E_ChildLeft)</span><br><span class="line">            &#123;</span><br><span class="line">                ext_tmpnode.pointSign = E_ChildRight;<span class="comment">// (2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line">                linkobj.<span class="built_in">Push</span>(ext_tmpnode);<span class="comment">// (2.2) 重新将该元素入栈</span></span><br><span class="line">                curr_node = ext_tmpnode.point-&gt;rightChild;<span class="comment">// (2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// (2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ext_tmpnode.pointSign == E_ChildRight)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="type">char</span>)ext_tmpnode.point-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// (3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (linkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************** ## 通过遍历序列创建二叉树</span></span><br><span class="line"><span class="comment">// 结论：已知前序和中序遍历序列，是能够唯一确定一颗二叉树的。</span></span><br><span class="line"><span class="comment">// 如何根据前序、中序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">// 参数 pP_T：前序遍历序列(根左右)， 比如  “ABCDE”</span></span><br><span class="line"><span class="comment">// 参数 pI_T：中序遍历序列(左根右)，比如 &quot;DBACE&quot;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPI</span>(<span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有个小插曲，这个成员函数是通过 前序、中序 序列来创建二叉树的，而且创建到 root里面去。</span></span><br><span class="line">    <span class="comment">// 如果 root原本就保存着一颗二叉树，那么在创建之前最好先把原本的树节点给释放掉，以免造成内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(root);<span class="comment">// 释放节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreateBTreeAccordPI</span>(root, pP_T, pI_T, <span class="built_in">strlen</span>(pP_T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPI</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// (1)在中序遍历序列中找到根，前序遍历序列中根是在最前面的</span></span><br><span class="line">        <span class="type">int</span> tmpindex = <span class="number">0</span>;<span class="comment">// 下标，从0开始</span></span><br><span class="line">        <span class="keyword">while</span> (pP_T[<span class="number">0</span>] != pI_T[tmpindex])</span><br><span class="line">        &#123;</span><br><span class="line">            ++tmpindex;<span class="comment">// 先找到根节点在 中序序列字符串中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = pI_T[tmpindex];<span class="comment">// 给根节点的数据域赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 创建左孩子  通过递归来创建</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPI</span>(</span><br><span class="line">            tnode-&gt;leftChild,<span class="comment">// 创建左孩子</span></span><br><span class="line">            pP_T + <span class="number">1</span>,<span class="comment">// 找到前序遍历序列中左树开始节点的位置，这里跳过了第一个节点（根），  （根 左 右）</span></span><br><span class="line">            pI_T,<span class="comment">// 中序遍历不需要改动</span></span><br><span class="line">            tmpindex<span class="comment">// 左孩子的节点个数，因为 tmpindex是父节点(根)的下标</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// (3) 创建右孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPI</span>(</span><br><span class="line">            tnode-&gt;rightChild,<span class="comment">// 创建右孩子</span></span><br><span class="line">            pP_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到前序遍历序列中右树开始节点的位置，不难发现前序遍历序列和中序遍历序列右树开始节点的位置相同</span></span><br><span class="line">            pI_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到中序遍历序列中右树节点开始的位置</span></span><br><span class="line">            n - tmpindex - <span class="number">1</span><span class="comment">// 右孩子节点数  n 节点总数， tmpindex 左孩子节点数， -1 减去根 所以 右孩子 = n - tmpindex - 1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何根据中序、后序遍历序列来创建一颗二叉树？</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordIPO</span>(<span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有个小插曲，这个成员函数是通过 前序、中序 序列来创建二叉树的，而且创建到 root里面去。</span></span><br><span class="line">    <span class="comment">// 如果 root原本就保存着一颗二叉树，那么在创建之前最好先把原本的树节点给释放掉，以免造成内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(root);<span class="comment">// 释放节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreateBTreeAccordIPO</span>(root, pInorder_T, pPostOrder_T, <span class="built_in">strlen</span>(pInorder_T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordIPO</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以通过 后序遍历 找到根节点 （最后一个就是）</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在中序遍历序列中 找根，后序遍历序列中 根是在最后</span></span><br><span class="line">        <span class="type">int</span> tmpindex = <span class="number">0</span>;<span class="comment">// 找根的 下标，找打了的话，那么下标就是根节点在中序序列中的下标</span></span><br><span class="line">        <span class="keyword">while</span> (pPostOrder_T[n - <span class="number">1</span>] != pInorder_T[tmpindex])</span><br><span class="line">            ++tmpindex;</span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = pInorder_T[tmpindex];<span class="comment">// 给根节点数据域赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) 创建左孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordIPO</span>(</span><br><span class="line">            tnode-&gt;leftChild,<span class="comment">// 创建左孩子</span></span><br><span class="line">            pInorder_T,<span class="comment">// 中序(左根右)的不需要改动，因为开头的都是左孩子</span></span><br><span class="line">            pPostOrder_T,<span class="comment">// 后序(左右根） 仍旧不需要改动</span></span><br><span class="line">            tmpindex<span class="comment">// 左孩子节点个数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 创建右孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordIPO</span>(</span><br><span class="line">            tnode-&gt;rightChild,<span class="comment">// 创建右孩子</span></span><br><span class="line">            pInorder_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到中序遍历序列中右树开始节点的位置</span></span><br><span class="line">            pPostOrder_T + tmpindex,<span class="comment">// 找到后序遍历序列中右树开始的节点位置</span></span><br><span class="line">            n - tmpindex - <span class="number">1</span><span class="comment">// 右孩子节点数</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkBinaryTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree;</span><br><span class="line">    <span class="comment">// 创建一颗二叉树</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* rootpoint = mytree.<span class="built_in">CreateNode</span>(<span class="literal">nullptr</span>, E_Root, <span class="string">&#x27;A&#x27;</span>);<span class="comment">// 创建树根节点 A</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeB = mytree.<span class="built_in">CreateNode</span>(rootpoint, E_ChildLeft, <span class="string">&#x27;B&#x27;</span>);<span class="comment">// 创建A的左孩子B</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeC = mytree.<span class="built_in">CreateNode</span>(rootpoint, E_ChildRight, <span class="string">&#x27;C&#x27;</span>);<span class="comment">// 创建A的右孩子C</span></span><br><span class="line"></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeD = mytree.<span class="built_in">CreateNode</span>(treenodeB, E_ChildLeft, <span class="string">&#x27;D&#x27;</span>);<span class="comment">// 创建B的左孩子D</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeE = mytree.<span class="built_in">CreateNode</span>(treenodeC, E_ChildRight, <span class="string">&#x27;E&#x27;</span>);<span class="comment">// 创建C的右孩子D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历序列：ABD###C#E##(给出一个扩展二叉树的前序遍历序列，是能够唯一确定一颗二叉树的)</span></span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree2;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">CreateBTreeAccordPT</span>((<span class="type">char</span>*)<span class="string">&quot;ABD###C#E##&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">前序遍历序列为：A  B  D  C  E</span></span><br><span class="line"><span class="comment">中序遍历序列为：D  B  A  C  E</span></span><br><span class="line"><span class="comment">后序遍历序列为：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;层序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.l</span>evelOrder();</span><br><span class="line">    <span class="comment">/* 层序遍历序列为：A  B  C  D  E */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;是否是一颗完全二叉树? &quot;</span> &lt;&lt; ((mytree<span class="number">2.</span><span class="built_in">IfCompleteTree</span>()) ? <span class="string">&quot;是的&quot;</span> : <span class="string">&quot;不是&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树节点个数为：&quot;</span> &lt;&lt; mytree<span class="number">2.</span><span class="built_in">GetSize</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树的高度为：&quot;</span> &lt;&lt; mytree<span class="number">2.</span><span class="built_in">GetHeight</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 查找某个节点</span></span><br><span class="line">    <span class="type">int</span> val = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* s_node = mytree<span class="number">2.</span><span class="built_in">SearchElem</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (s_node != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)val &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 查找某个节点的父节点</span></span><br><span class="line">        BinaryTreeNode&lt;<span class="type">int</span>&gt;* p_node = mytree<span class="number">2.</span><span class="built_in">GetParent</span>(s_node);</span><br><span class="line">        <span class="keyword">if</span> (p_node != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;找到了节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)s_node-&gt;data &lt;&lt; <span class="string">&quot; 的父节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)p_node-&gt;data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;未找到节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)s_node-&gt;data &lt;&lt; <span class="string">&quot; 的父节&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试树的拷贝</span></span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree3;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">CopyTree</span>(&amp;mytree3);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝的树mytree3的中序遍历：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归 前序遍历二叉树</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 前序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">preOrder_noRecu</span>();</span><br><span class="line">    <span class="comment">// 非递归 中序遍历二叉树</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 中序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">inOrder_noRecu</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 后序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">postOrder_noRecu</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用前序遍历、中序遍历序列来创建一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree4;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">CreateBTreeAccordPI</span>((<span class="type">char</span>*)<span class="string">&quot;ABDCE&quot;</span>, (<span class="type">char</span>*)<span class="string">&quot;DBACE&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用前序：ABDCE 中序：DBACE 序列创建了一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的前序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的中序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的后序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">使用前序遍历、中序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">使用前序：ABDCE 中序：DBACE 序列创建了一颗二叉树</span></span><br><span class="line"><span class="comment">该二叉树的前序遍历序列：A  B  D  C  E</span></span><br><span class="line"><span class="comment">该二叉树的中序遍历序列：D  B  A  C  E</span></span><br><span class="line"><span class="comment">该二叉树的后序遍历序列：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用中序遍历、后序遍历序列来创建一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree5;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">CreateBTreeAccordIPO</span>((<span class="type">char</span>*)<span class="string">&quot;DBACE&quot;</span>, (<span class="type">char</span>*)<span class="string">&quot;DBECA&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用中序：DBACE 后序：DBECA 序列创建了一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的前序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的中序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的后序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">使用中序遍历、后序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">使用中序：DBACE 后序：DBECA 序列创建了一颗二叉树</span></span><br><span class="line"><span class="comment">该二叉树的前序遍历序列：A  B  D  C  E</span></span><br><span class="line"><span class="comment">该二叉树的中序遍历序列：D  B  A  C  E</span></span><br><span class="line"><span class="comment">该二叉树的后序遍历序列：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_LinkedStorage_2.png" alt="BinaryTree_LinkedStorage_2"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 二叉树(顺序存储)</title>
      <link href="/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/"/>
      <url>/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树-顺序存储"><a href="#二叉树-顺序存储" class="headerlink" title="二叉树(顺序存储)"></a>二叉树(顺序存储)</h1><p>顺序存储二叉树的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ECCHILDSIGN</span><span class="comment">// 节点标记</span></span><br><span class="line">&#123;</span><br><span class="line">    E_Root,<span class="comment">// 树根</span></span><br><span class="line">    E_ChildLeft,<span class="comment">// 左孩子</span></span><br><span class="line">    E_ChildRight<span class="comment">// 右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，用于存放数据元素</span></span><br><span class="line">    <span class="type">bool</span> isValid;<span class="comment">// 该节点是否有效以应对非完全二叉树(只有保存了实际节点数据的节点才是有效的)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BinaryTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MaxSize; ++i)<span class="comment">// 这里数组大小是MaxSize +1，所以这里i的终止值没有问题</span></span><br><span class="line">        &#123;</span><br><span class="line">            SqBiTree[i].isValid = <span class="literal">false</span>;<span class="comment">// 开始时节点无效，没有保存任何数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建一个树节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CreateNode</span><span class="params">(<span class="type">int</span> parindex, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="comment">// 获取父节点的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetParentIdx</span><span class="params">(<span class="type">int</span> sonindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ifValidRangeIdx(sonindex))<span class="comment">// 位置不合理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[sonindex].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点，不要尝试找父节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(sonindex / <span class="number">2</span>); <span class="comment">// i的父节点是(i/2)向下取整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取某个节点所在的高度</span></span><br><span class="line">    <span class="comment">// 根据二叉树的性质5：具有n(n&gt;0)个节点的完全二叉树的高度log2(n+1) 向上取整 或者是 log2(n) 向下取整 再来 + 1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPointLevel</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点，不要尝试找父节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 采用公式计算：log2(n) 向下取整 再来 +1</span></span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">int</span>(<span class="built_in">log</span>(index) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// c++中的log(n)函数求的是以e(2.71828)为底的对数值，如果要求以数字m为底的，则需要 log(n) / log(m)</span></span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = MaxSize; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[i].isValid == <span class="literal">true</span>)<span class="comment">// 找到了最后一个有效节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPointLevel</span>(i);<span class="comment">// 最后一个有效节点的高度，就是整个二叉树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是个完全二叉树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IfCompleteBT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = MaxSize; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[i].isValid == <span class="literal">true</span>)<span class="comment">// 找到了最后一个有效节点</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 找到最后一个有效节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个有效节点之前的所有下标必须都是有效的，才是一颗完全二叉树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[k].isValid == <span class="literal">false</span>)<span class="comment">// 所有节点必须都要有效</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历二叉树，其他的遍历方式在二叉树的链式存储中再详细书写代码</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">1</span>);<span class="comment">// 根节点的数组下标是1，所以这里把根的下标传递进去</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根左右顺序</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="comment">// 输出节点的数据域的值，为了方便观察，这里用char以显示字符</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">2</span> * index);<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);<span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 左右根 顺序</span></span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">2</span> * index);</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">posOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">posOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 左右根 顺序</span></span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">2</span> * index);</span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 判断下标是否有效</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ifValidRangeIdx</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 位置必须合理</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; MaxSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt; SqBiTree[MaxSize + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 存储二叉树节点的数组，为了写程序方便，下标为0的数组元素不使用，因此这里需要+1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 参数1：父节点所在的数组下标</span></span><br><span class="line"><span class="comment">// 参数2：标记所创建的是树根、左孩子、右孩子</span></span><br><span class="line"><span class="comment">// 参数3：插入的数据节点的元素值</span></span><br><span class="line"><span class="type">int</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateNode</span>(<span class="type">int</span> parindex, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointSign != E_Root)</span><br><span class="line">    &#123;<span class="comment">// 创建的是 非根节点，则一定是子节点，要求parindex一定是个合理值</span></span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(parindex) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[parindex].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pointSign == E_Root)<span class="comment">// 创建的是根</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">1</span>;<span class="comment">// 根节点固定存储在下标为1的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pointSign == E_ChildLeft)<span class="comment">// 左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是左孩子的节点，节点i的左孩子节点的下标是2*i</span></span><br><span class="line">        index = <span class="number">2</span> * parindex;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是右孩子的节点，节点i的右孩子节点的下标是2*i + 1</span></span><br><span class="line">        index = <span class="number">2</span> * parindex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SqBiTree[index].data = e;</span><br><span class="line">    SqBiTree[index].isValid = <span class="literal">true</span>;<span class="comment">// 标记该下标中有有效数据</span></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqBinaryTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree;</span><br><span class="line">    <span class="comment">// 创建一颗二叉树</span></span><br><span class="line">    <span class="type">int</span> indexRoot = mytree.<span class="built_in">CreateNode</span>(<span class="number">-1</span>, E_Root, <span class="string">&#x27;A&#x27;</span>);<span class="comment">// 创建树根节点A</span></span><br><span class="line">    <span class="type">int</span> indexNodeB = mytree.<span class="built_in">CreateNode</span>(indexRoot, E_ChildLeft, <span class="string">&#x27;B&#x27;</span>);<span class="comment">// 创建根节点的左孩子节点B</span></span><br><span class="line">    <span class="type">int</span> indexNodeC = mytree.<span class="built_in">CreateNode</span>(indexRoot, E_ChildRight, <span class="string">&#x27;C&#x27;</span>);<span class="comment">// 创建根节点的右孩子节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeD = mytree.<span class="built_in">CreateNode</span>(indexNodeB, E_ChildLeft, <span class="string">&#x27;D&#x27;</span>);<span class="comment">// 创建节点B的左孩子节点D</span></span><br><span class="line">    <span class="type">int</span> indexNodeE = mytree.<span class="built_in">CreateNode</span>(indexNodeB, E_ChildRight, <span class="string">&#x27;E&#x27;</span>);<span class="comment">// 创建节点C的右孩子节点E</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeG = mytree.<span class="built_in">CreateNode</span>(indexNodeD, E_ChildRight, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> indexNodeH = mytree.<span class="built_in">CreateNode</span>(indexNodeE, E_ChildLeft, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeF = mytree.<span class="built_in">CreateNode</span>(indexNodeC, E_ChildRight, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iParentIndexE = mytree.<span class="built_in">GetParentIdx</span>(indexNodeE);<span class="comment">// 获取某个节点父节点的下标</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点E的父节点的下标是:&quot;</span> &lt;&lt; iParentIndexE &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iLevel = mytree.<span class="built_in">GetPointLevel</span>(indexNodeD);<span class="comment">// 获取某个节点所在的高度/深度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点D所在的高度/深度是:&quot;</span> &lt;&lt; iLevel &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    iLevel = mytree.<span class="built_in">GetPointLevel</span>(indexNodeB);<span class="comment">// 获取某个节点所在的高度/深度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点B所在的高度/深度是:&quot;</span> &lt;&lt; iLevel &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整个二叉树的深度是:&quot;</span> &lt;&lt; mytree.<span class="built_in">GetLevel</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树是个完全二叉树码? &quot;</span> &lt;&lt; (mytree.<span class="built_in">IfCompleteBT</span>() ? <span class="string">&quot;是的&quot;</span> : <span class="string">&quot;不是&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">PreOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">posOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">节点E的父节点的下标是:2</span></span><br><span class="line"><span class="comment">节点D所在的高度/深度是:3</span></span><br><span class="line"><span class="comment">节点B所在的高度/深度是:2</span></span><br><span class="line"><span class="comment">整个二叉树的深度是:4</span></span><br><span class="line"><span class="comment">二叉树是个完全二叉树码? 不是</span></span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="comment">前序遍历序列为:A  B  D  G  E  H  C  F</span></span><br><span class="line"><span class="comment">中序遍历序列为:D  G  B  H  E  A  C  F</span></span><br><span class="line"><span class="comment">后序遍历序列为:G  D  H  E  B  F  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_SeqStorage.png" alt="BinaryTree_SeqStorage"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 循环队列</title>
      <link href="/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/"/>
      <url>/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>循环队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYCIRCLEQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYCIRCLEQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircleQueue</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">CircleQueue</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EntQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入队列（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelQueue</span><span class="params">(T&amp; e)</span></span>;    <span class="comment">// 出队列（删除数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;   <span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;  <span class="comment">// 将队列清空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序队列中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>; <span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断顺序队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序队列是否为满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data; <span class="comment">// 存放顺序队列中的元素</span></span><br><span class="line">    <span class="type">int</span> m_front;  <span class="comment">// 队头指针（数组下标），允许删除的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> m_rear;  <span class="comment">// 队尾指针（数组下标），允许插入的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队尾元素的下一个位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircleQueue&lt;T&gt;::<span class="built_in">CircleQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[MaxSize];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    <span class="comment">// 空队列，约定m_front 和 m_rear 都为0</span></span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序队列进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircleQueue&lt;T&gt;::~<span class="built_in">CircleQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列（增加数据）,也就是从队尾增加数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">EntQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂时先不扩容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列已满，无法进行入队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[m_rear] = e;  <span class="comment">// 将数据放到队尾</span></span><br><span class="line">    <span class="comment">// m_rear++;  // 队尾指针往后走， +1</span></span><br><span class="line">    m_rear = (m_rear + <span class="number">1</span>) % MaxSize;  </span><br><span class="line">    <span class="comment">// 队尾指针+1并取余，这样m_data的下标就控制在0~（MaxSize-1）之间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列（删除数据），也就是从队头删除数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">DelQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法进行出队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_front];   <span class="comment">// 队头元素值返回到e中</span></span><br><span class="line">    <span class="comment">// m_front++;  // 队头往后走一个</span></span><br><span class="line">    m_front = (m_front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法读取队头元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_rear];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列清空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CircleQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_rear = m_front = <span class="number">0</span>;  <span class="comment">// 直接修改队头、队尾指针，设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序队列中的所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CircleQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123; <span class="comment">// 按照从队头到队尾的顺序来显示数据</span></span><br><span class="line">    <span class="comment">// for (int i = m_front; i &lt; m_rear; ++i)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m_front; i != m_rear;)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line"></span><br><span class="line">        i = (i + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> CircleQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return m_rear - m_front;</span></span><br><span class="line">    <span class="keyword">return</span> (m_rear + MaxSize - m_front) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为空, 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为满,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_rear + <span class="number">1</span>)%MaxSize == m_front)<span class="comment">// 队尾指针和数组容量作比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYCIRCLEQUEUE_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCircleQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CircleQueue&lt;<span class="type">int</span>&gt; cricleobj;</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">150</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">200</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">300</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">400</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    cricleobj.<span class="built_in">DelQueue</span>(eval);</span><br><span class="line">    cricleobj.<span class="built_in">DelQueue</span>(eval);</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">500</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">600</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">700</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">800</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">900</span>);</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopQueue.png" alt="LoopQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 双端链式队列</title>
      <link href="/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/"/>
      <url>/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/</url>
      
        <content type="html"><![CDATA[<h1 id="双端链式队列"><a href="#双端链式队列" class="headerlink" title="双端链式队列"></a>双端链式队列</h1><p>双端链式队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T 代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblQueueNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* prev;<span class="comment">// 指针域，指向前一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblLinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblLinkQueue</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">DblLinkQueue</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue_Front</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素） 队头入</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue_Front</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素） 队头出</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素） 队尾入</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue_Back</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素） 队尾出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetRear</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队尾元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList_Front</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素  队头开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList_Back</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素  队尾开始</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取链式队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">// 判断链式队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblQueueNode&lt;T&gt;* m_front;<span class="comment">// 头指针（指向头结点），这一端允许出队（删除）</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* m_rear;<span class="comment">// 专门引入尾指针以方便入队（插入）操作</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 记录长度，方便长度使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkQueue&lt;T&gt;::<span class="built_in">DblLinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_front = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_front-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear = m_front;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对链式队列进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkQueue&lt;T&gt;::~<span class="built_in">DblLinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* pnode = m_front-&gt;next;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_front;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_front = m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列 队头开始入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">EnQueue_Front</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* node = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;next = m_front-&gt;next;</span><br><span class="line">    node-&gt;prev = m_front;</span><br><span class="line">    <span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">    &#123;</span><br><span class="line">        m_rear = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_front-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    m_front-&gt;next = node;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列 队尾开始入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">EnQueue_Back</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* node = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear-&gt;next = node;<span class="comment">// 新节点插入到m_rear后面</span></span><br><span class="line">    node-&gt;prev = m_rear;</span><br><span class="line">    m_rear = node;<span class="comment">// 更新队尾指针</span></span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列 从队头出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DeQueue_Front</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp = m_front-&gt;next;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_front-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="comment">// 这里需要考虑，如果只有一个元素时，出队了就为空了</span></span><br><span class="line">    <span class="keyword">if</span> (ptmp == m_rear)</span><br><span class="line">    &#123;<span class="comment">// 只有一个元素，出队了就为空了，那么尾指针就指向m_front了</span></span><br><span class="line">        m_rear = m_front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 超过2个元素，那么就需要更新前向指针指向m_front</span></span><br><span class="line">        ptmp-&gt;next-&gt;prev = m_front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == ptmp)</span><br><span class="line">    &#123;<span class="comment">// 队列中只有一个元素节点（被删除后，整个队列为空）</span></span><br><span class="line">        m_rear = m_front;<span class="comment">// 设置队列为空，尾指针指向头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列 从队尾出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DeQueue_Back</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp = m_rear;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_rear = m_rear-&gt;prev;</span><br><span class="line">    m_rear-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取队头元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队尾元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">GetRear</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_rear-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)  从前往后输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DispList_Front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* p = m_front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)  从后往输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DispList_Back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* p = m_rear;</span><br><span class="line">    <span class="keyword">while</span> (p != m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链式队列的长度 O&#123;1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkQueue&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链式队列是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m_length &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblLinkQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblLinkQueue&lt;<span class="type">int</span>&gt; lnobj;</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    lnobj.<span class="built_in">DeQueue_Front</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">212</span>);</span><br><span class="line">    lnobj.<span class="built_in">DeQueue_Back</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">200</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">700</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList_Front</span>();<span class="comment">// 200  700</span></span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">666</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">888</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList_Front</span>();</span><br><span class="line">    lnobj.<span class="built_in">DispList_Back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">700  200</span></span><br><span class="line"><span class="comment">888  700  200  666</span></span><br><span class="line"><span class="comment">666  200  700  888</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedDequeue.png" alt="LinkedDequeue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 链式队列</title>
      <link href="/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/"/>
      <url>/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h1><p>链式队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T 代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    QueueNode&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkQueue</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkQueue</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取链式队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">// 判断链式队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    QueueNode&lt;T&gt;* m_front;<span class="comment">// 头指针（指向头结点），这一端允许出队（删除）</span></span><br><span class="line">    QueueNode&lt;T&gt;* m_rear;<span class="comment">// 专门引入尾指针以方便入队（插入）操作</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 记录长度，方便长度使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_front = <span class="keyword">new</span> QueueNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear = m_front;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对链式队列进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::~<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* pnode = m_front-&gt;next;</span><br><span class="line">    QueueNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_front;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_front = m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* node = <span class="keyword">new</span> QueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear-&gt;next = node;<span class="comment">// 新节点插入到m_rear后面</span></span><br><span class="line">    m_rear = node;<span class="comment">// 更新队尾指针</span></span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode&lt;T&gt;* ptmp = m_front-&gt;next;;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_front-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == ptmp)<span class="comment">// 队列中只有一个元素节点（被删除后，整个队列为空）</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_rear = m_front;<span class="comment">// 设置队列为空，尾指针指向头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取队头元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkQueue&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* p = m_front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链式队列的长度 O&#123;1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkQueue&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链式队列是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue&lt;<span class="type">int</span>&gt; lnobj;</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    lnobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">200</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">700</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList</span>();<span class="comment">// 200  700</span></span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">666</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">888</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedQueue.png" alt="LinkedQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序队列</title>
      <link href="/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/"/>
      <url>/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><p>顺序队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqQueue</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">SeqQueue</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EntQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入队列（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelQueue</span><span class="params">(T&amp; e)</span></span>;    <span class="comment">// 出队列（删除数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;   <span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;  <span class="comment">// 将队列清空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序队列中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>;  <span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断顺序队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序队列是否为满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;  <span class="comment">// 存放顺序队列中的元素</span></span><br><span class="line">    <span class="type">int</span> m_front;  <span class="comment">// 队头指针（数组下标），允许删除的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> m_rear;  <span class="comment">// 队尾指针（数组下标），允许插入的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队尾元素的下一个位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[MaxSize];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    <span class="comment">// 空队列，约定m_front 和 m_rear 都为0</span></span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序队列进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::~<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列（增加数据）,也就是从队尾增加数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">EntQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂时先不扩容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列已满，无法进行入队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[m_rear] = e;  <span class="comment">// 将数据放到队尾</span></span><br><span class="line">    m_rear++;  <span class="comment">// 队尾指针往后走， +1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列（删除数据），也就是从队头删除数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">DelQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法进行出队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_front];   <span class="comment">// 队头元素值返回到e中</span></span><br><span class="line">    m_front++;  <span class="comment">// 队头往后走一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法读取队头元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_rear];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列清空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_rear = m_front = <span class="number">0</span>;   <span class="comment">// 直接修改队头、队尾指针，设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序队列中的所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123; <span class="comment">// 按照从队头到队尾的顺序来显示数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m_front; i &lt; m_rear; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_rear - m_front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为空, 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为满,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear &gt;= MaxSize)  <span class="comment">// 队尾指针和数组容量作比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSEQQUEUE_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqQueue&lt;<span class="type">int</span>&gt; seqobj;</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">150</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">200</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">300</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">400</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqQueue.png" alt="SeqQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 链式栈</title>
      <link href="/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/"/>
      <url>/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/</url>
      
        <content type="html"><![CDATA[<h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><p>链式栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYLINKSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYLINKSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 链式栈中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;  <span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    StackNode&lt;T&gt;* next;  <span class="comment">// 指针域，指向下一个同类型(和本节点类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式栈的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkStack</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkStack</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入栈元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>; <span class="comment">// 出栈(删除数据)操作，也就是删除栈顶数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;  <span class="comment">// 读取栈顶数据，但该元素并没有出栈，依旧在栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;  <span class="comment">// 输出链式栈中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;   <span class="comment">// 获取链式栈的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;  <span class="comment">// 判断链式栈是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    StackNode&lt;T&gt;* m_top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> m_length; <span class="comment">// 链式栈当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_top = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作。入栈元素e，时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode&lt;T&gt;* p_new = <span class="keyword">new</span> StackNode&lt;T&gt;;</span><br><span class="line">    p_new-&gt;data = e;</span><br><span class="line">    p_new-&gt;next = m_top;</span><br><span class="line">    m_top = p_new;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈(删除数据)操作，也就是删除栈顶数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;当前链式栈为空，无法进行出栈操作!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode&lt;T&gt;* p_curr = m_top;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    m_top = m_top-&gt;next;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;出栈操作成功，元素为值为:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">delete</span> p_curr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取栈顶数据，但该元素并没有出栈，依旧在栈中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前链式栈为空，无法读取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_top-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出链式栈中所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    StackNode&lt;T&gt;* p_curr = m_top;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取链式栈的长度 O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断链式栈是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数 释放链式栈内存空间</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::~<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T tmp_value = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Pop</span>(tmp_value) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里不用干啥</span></span><br><span class="line">        <span class="comment">// 把栈顶元素删除光，while循环也就退出了，此时也就是空栈了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYLINKSTACK_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkStack.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数字相加的和值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> tmpA, <span class="type">int</span> tmpB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = tmpA + tmpB;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_operator_ch[] = &#123; <span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result = <span class="built_in">Add</span>(a1, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;和值为:&quot;</span> &lt;&lt; result &lt;&lt; endl;<span class="comment">// 和值为:115</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isMatchSucc = <span class="literal">true</span>;<span class="comment">// 是否匹配成功的标志，先标记为匹配成功</span></span><br><span class="line">    LinkStack&lt;<span class="type">char</span>&gt; slinkobjprocKH;<span class="comment">// 用来保存左括号的栈 &#123; [ (</span></span><br><span class="line">    string strExp = <span class="string">&quot;[(&#123;&#125;)&#123;&#125;]&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strExp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (strExp[i] == <span class="string">&#x27;(&#x27;</span> || </span><br><span class="line">            strExp[i] == <span class="string">&#x27;[&#x27;</span> || </span><br><span class="line">            strExp[i] == <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">           )</span><br><span class="line">        &#123;</span><br><span class="line">            slinkobjprocKH.<span class="built_in">Push</span>(strExp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前是个右括号，则从栈顶取出一个左括号</span></span><br><span class="line">            <span class="type">char</span> tmpTopChar;</span><br><span class="line">            <span class="keyword">if</span> (slinkobjprocKH.<span class="built_in">Pop</span>(tmpTopChar) == <span class="literal">false</span>)</span><br><span class="line">            &#123;<span class="comment">// 从栈顶取出数据失败</span></span><br><span class="line">                isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((strExp[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (strExp[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                (strExp[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;&#123;&#x27;</span>) </span><br><span class="line">               )  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// isMatchSucc = true;</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 匹配，继续扫描</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;  <span class="comment">// 不匹配，直接退出循环，因为已经不匹配了，直接不扫描了</span></span><br><span class="line">                isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// end if</span></span><br><span class="line">    &#125;  <span class="comment">// end for</span></span><br><span class="line">    <span class="comment">// 扫描完成，还要确定slinkobjprocKH为空才可以</span></span><br><span class="line">    <span class="keyword">if</span> ((isMatchSucc == <span class="literal">true</span>) &amp;&amp; (slinkobjprocKH.<span class="built_in">Empty</span>() == <span class="literal">false</span>))</span><br><span class="line">    &#123; <span class="comment">// 栈不为空，也是不可以的</span></span><br><span class="line">        isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMatchSucc)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式合法，括号配对数量和顺序都正确！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式非法，括号配对数量和顺序都不正确！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------- Main 结束 -------------------------&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedStack.png" alt="LinkedStack"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 共享栈</title>
      <link href="/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/"/>
      <url>/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/</url>
      
        <content type="html"><![CDATA[<h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><p>共享栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSHARESTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSHARESTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5   <span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"><span class="comment">// 共享栈</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShareStack</span>(<span class="type">int</span> length = InitSize);  <span class="comment">// 构造函数参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">ShareStack</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span>  <span class="comment">// 判断共享栈是否满</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_top1 + <span class="number">1</span> &gt;= m_top2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> stackNum, <span class="type">const</span> T&amp; e)</span>  <span class="comment">// 入栈(增加数据) 参数 stackNum用于表示栈1还是栈2</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里简单处理</span></span><br><span class="line">            <span class="comment">// 也可以增加代码支持共享栈的扩容操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;共享栈满了，无法入栈新数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的入栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的入栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;  <span class="comment">// 走这里，就是入栈1</span></span><br><span class="line">            m_data[++m_top1] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// 前面已经判断过 stackNum 不是1 就是2</span></span><br><span class="line">        &#123; <span class="comment">// 走到这里，就是入栈2</span></span><br><span class="line">            m_data[--m_top2] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(<span class="type">int</span> stackNum, T&amp; e)</span>  <span class="comment">// 出栈(删除数据)，也就是删除栈顶数据</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top1 &lt;= <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈1为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top1--];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top2 &gt;= m_maxsize)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈2为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top2++];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetPop</span><span class="params">(<span class="type">int</span> stackNum, T&amp; e)</span>  <span class="comment">// 获取栈顶元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top1 &lt;= <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈1为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top1];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top2 &gt;= m_maxsize)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈2为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top2];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DisplayStack</span><span class="params">(<span class="type">int</span> stackNum = <span class="number">0</span>)</span><span class="comment">// 打印栈元素</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">/* 参数说明：  </span></span><br><span class="line"><span class="comment">stackNum = 0 代表打印所有元素， 先打印栈1，后打印栈2，从栈顶往栈底打印</span></span><br><span class="line"><span class="comment">stackNum = 1 代表打印栈1的元素，从栈顶往栈顶打印</span></span><br><span class="line"><span class="comment">stackNum = 2 代表打印栈2的元素，从栈顶往栈底打印</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span> &amp;&amp; stackNum != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[0 或者 1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(stackNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Priv_DisplayStack</span><span class="params">(<span class="type">int</span> stackNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打印共享栈1的数据:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m_top1; i &gt; <span class="number">-1</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打印共享栈2的数据:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m_top2; i &lt; m_maxsize; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;   <span class="comment">// 存放共享栈中的元素</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;  <span class="comment">// 动态数组最大容量</span></span><br><span class="line">    <span class="type">int</span> m_top1;   <span class="comment">// 顺序栈1的栈顶指针为-1，表示空栈</span></span><br><span class="line">    <span class="type">int</span> m_top2;  <span class="comment">// 顺序栈2的栈顶指针为m_maxsize，表示空栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数参数可以有默认值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ShareStack&lt;T&gt;::<span class="built_in">ShareStack</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    m_maxsize = length;  <span class="comment">// 共享栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">    m_top1 = <span class="number">-1</span>;   <span class="comment">// 顺序栈1的栈顶指针为-1，表示空栈</span></span><br><span class="line">    m_top2 = m_maxsize;  <span class="comment">// 顺序栈2的栈顶指针为m_maxsize，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ShareStack&lt;T&gt;::~<span class="built_in">ShareStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSHARESTACK_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 共享栈 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyShareStack.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ShareStack&lt;<span class="type">int</span>&gt; <span class="title">shareobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">1</span>, <span class="number">150</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">1</span>, <span class="number">200</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">2</span>, <span class="number">1500</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">    shareobj.<span class="built_in">DisplayStack</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SharedStack.png" alt="SharedStack"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序栈</title>
      <link href="/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/"/>
      <url>/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>顺序栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySeqStack.h 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="type">int</span> length = InitSize);<span class="comment">// 构造函数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//入栈（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出栈（删除数据），也就是删除栈顶数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 读取栈顶元素，但该元素并没有出栈，而依旧是在栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispStack</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序栈中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;  <span class="comment">// 获取顺序栈的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序栈是否已满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;  <span class="comment">// 当顺序栈存满数据后可以调用此函数为顺序栈扩容</span></span><br><span class="line"></span><br><span class="line">    T* m_data;  <span class="comment">// 存放顺序栈中的元素</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;  <span class="comment">// 动态数组最大容量</span></span><br><span class="line">    <span class="type">int</span> m_top;  <span class="comment">// 栈顶指针（用作数组下标），指向栈顶元素，该值为-1表示空栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::<span class="built_in">SeqStack</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];  <span class="comment">// 为一维数组动态分配内存，该值和算法空间复杂度无关。</span></span><br><span class="line">    <span class="comment">// 空间复杂度一般指的是，算法额外需要的存储空间</span></span><br><span class="line">    m_top = <span class="number">-1</span>;  <span class="comment">// -1 代表空栈</span></span><br><span class="line">    m_maxsize = length;  <span class="comment">// 顺序栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序栈进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::~<span class="built_in">SeqStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈（增加数据） 通常时间复杂度为O(1)，但一旦栈满了，就需要扩容，时间复杂度就变为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 栈已经满了，需要扩容</span></span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;顺序栈已满，无法进行入栈操作了!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">        <span class="built_in">IncreaseSize</span>();  <span class="comment">// 扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_top++;  <span class="comment">// 栈顶指针向后走</span></span><br><span class="line">    m_data[m_top] = e;</span><br><span class="line">    <span class="comment">// 或者写成  m_data[++m_top] = e;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当顺序栈存满数据后可以调用此函数为顺序栈扩容, 时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T* p = m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[m_maxsize + IncSize];<span class="comment">// 重新为顺序栈分配更大的内存空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m_top; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = p[i];  <span class="comment">// 将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_maxsize = m_maxsize + IncSize;<span class="comment">// 顺序栈最大长度增加 IncSize;</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈（删除数据），也就是删除栈顶数据  时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_top];  <span class="comment">// 栈顶元素返回到e中</span></span><br><span class="line">    <span class="comment">// 有的实现版本不会在Pop成员函数中返回栈顶元素，此时要取得栈顶元素，就得通过GetTop成员函数取得</span></span><br><span class="line">    --m_top;</span><br><span class="line">    <span class="comment">// 代码合并  e = m_data[m_top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取栈顶元素，但该元素并没有出栈，而依旧是在栈中   时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_top];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序栈中所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">DispStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从栈顶到栈底的顺序显示数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m_top; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序栈的长度（实际拥有的元素数量） 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序栈是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序栈是否已满</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top &gt;= m_maxsize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqStack.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SeqStack&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">150</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">200</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">300</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">400</span>);</span><br><span class="line">    seqobj.<span class="built_in">DispStack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    seqobj.<span class="built_in">DispStack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqQueue.png" alt="SeqQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 静态链表</title>
      <link href="/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/"/>
      <url>/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>静态链表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTATICLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTATICLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 201</span></span><br><span class="line"><span class="comment">// 静态链表的尺寸，可以根据实际需要设定该值，可用数组下标 0 - 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点使用情况，枚举标记值</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">NODEUSE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这些枚举值都给负值，以免和数组下标(从0开始的正值)冲突</span></span><br><span class="line">    e_NOUSE = <span class="number">-1</span>,<span class="comment">// 未使用(未用)</span></span><br><span class="line">    e_LAST = <span class="number">-2</span>,<span class="comment">// 最后一个节点(末尾)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 元素数据域，存放数据元素</span></span><br><span class="line">    <span class="type">int</span> cur;<span class="comment">// 游标，记录下个静态链表节点的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StaticLinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">StaticLinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findAnIdlePos</span><span class="params">()</span></span>; <span class="comment">// 找到一个空闲位置用于保存数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 在第i个位置插入指定元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelte</span><span class="params">(<span class="type">int</span> i)</span></span>;  <span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;  <span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 按元素值查找其在静态链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;  <span class="comment">// 输出静态链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;  <span class="comment">// 获取静态链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;  <span class="comment">// 判断静态链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; m_data[MaxSize];  <span class="comment">// 保存节点数据的数组</span></span><br><span class="line">    <span class="type">int</span> m_length; <span class="comment">// 当前长度，也就是当前保存的数据节点数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对静态链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">StaticLinkList&lt;T&gt;::<span class="built_in">StaticLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MaxSize; ++i)</span><br><span class="line">    &#123;<span class="comment">// 从下标1开始的节点用于保存实际的数据，这些节点的curr有必要设置值，而头结点其实不用给任何值</span></span><br><span class="line">        m_data[i].cur = e_NOUSE;</span><br><span class="line">    &#125;</span><br><span class="line">    m_length = <span class="number">0</span>;  <span class="comment">// 还未向其中存入任何数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在m_data中找到一个空闲位置用于保存数据,若没找到(静态链表满了)就返回-1</span></span><br><span class="line"><span class="comment">// (插入数据的辅助函数)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">findAnIdlePos</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MaxSize; ++i)  </span><br><span class="line">    &#123;<span class="comment">// 因为下标0是头结点，不能用于保存数据，所以循环变量从1开始</span></span><br><span class="line">        <span class="keyword">if</span> (m_data[i].cur == e_NOUSE)  <span class="comment">// 未使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第iPos个位置(编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> iPos, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (iPos &lt; <span class="number">1</span> || iPos &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;不合法，合法位置是: [1 - &quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;] !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> iIdx;</span><br><span class="line">    <span class="keyword">if</span> ((iIdx = <span class="built_in">findAnIdlePos</span>()) == <span class="number">-1</span>)  <span class="comment">// 静态链表满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表已满!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然需要在第iPos位置插入元素，那么肯定需要找到iPos-1个位置</span></span><br><span class="line">    <span class="type">int</span> iDataCount = <span class="number">1</span>;  <span class="comment">// 统计静态链表中元素数量</span></span><br><span class="line">    <span class="type">int</span> iIdxPrev;   <span class="comment">// 保存第iPos-1个位置对应的m_data数组的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iPos == <span class="number">1</span>)   <span class="comment">// 向第一个位置插入元素，需要单独处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data[iIdx].data = e;</span><br><span class="line">        <span class="keyword">if</span> (m_length == <span class="number">0</span>)  <span class="comment">// 插入前是，空表</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[iIdx].cur = e_LAST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 非空表</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[iIdx].cur = m_data[<span class="number">0</span>].cur;  </span><br><span class="line">            <span class="comment">// 新插入的元素的游标指向原来头节点游标指向的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_data[<span class="number">0</span>].cur = iIdx;  <span class="comment">// 头节点的游标指向新插入的节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 插入位置不等于1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> iPosCount = <span class="number">0</span>;  <span class="comment">// 位置计数</span></span><br><span class="line">        <span class="type">int</span> tmpcur = m_data[<span class="number">0</span>].cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为前面已经判断过插入位置合法，所以一定可以扎到合适的位置</span></span><br><span class="line">            <span class="comment">// while(true)循环肯定可以正常退出</span></span><br><span class="line">            iPosCount++;</span><br><span class="line">            <span class="keyword">if</span> (iPosCount &gt;= (iPos - <span class="number">1</span>))  <span class="comment">// 找到了第iPos-1个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                iIdxPrev = tmpcur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpcur = m_data[tmpcur].cur;</span><br><span class="line">        &#125;  <span class="comment">// end while</span></span><br><span class="line">        <span class="type">int</span> iTmpCurr = m_data[iIdxPrev].cur;</span><br><span class="line">        m_data[iIdxPrev].cur = iIdx;</span><br><span class="line">        m_data[iIdx].data = e;</span><br><span class="line">        m_data[iIdx].cur = iTmpCurr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法获取数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1-&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="type">int</span> iPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iPos++;</span><br><span class="line">        <span class="keyword">if</span> (iPos == i)</span><br><span class="line">        &#123;</span><br><span class="line">            e = m_data[tmp_cur].data;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在静态链表中第一次出现的位置  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法获取数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="type">int</span> iPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iPos++;</span><br><span class="line">        <span class="keyword">if</span> (e == m_data[tmp_cur].data &amp;&amp; m_data[tmp_cur].cur != e_NOUSE)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;成功找到元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;在静态链表中的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> iPos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_data[tmp_cur].cur == e_LAST)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;在静态链表中没有找到!:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出静态链表中的所有元素 O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> StaticLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[tmp_cur].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((tmp_cur = m_data[tmp_cur].cur) == e_LAST)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态链表的长度  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断静态链表是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第iPos个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListDelte</span>(<span class="type">int</span> iPos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iPos &lt; <span class="number">1</span> || iPos &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;待删除的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1-&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur; <span class="comment">// 第一个数据节点的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> (iPos == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 删除第一个位置元素，要单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (m_length != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这个静态链表里有多个元素，那么</span></span><br><span class="line">            m_data[<span class="number">0</span>].cur = m_data[tmp_cur].cur; </span><br><span class="line">            <span class="comment">// 头结点指向第二个数据节点数组下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_data[tmp_cur].cur = e_NOUSE;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;的元素，该元素值为:&quot;</span> &lt;&lt; m_data[tmp_cur].data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 删除的不是第一个位置的元素</span></span><br><span class="line">        <span class="type">int</span> iIdxPrev;  <span class="comment">// 第iPos - 1个位置对应的m_data数组的下标</span></span><br><span class="line">        <span class="type">int</span> iPosCount = <span class="number">0</span>; <span class="comment">// 位置计数</span></span><br><span class="line">        <span class="comment">// 前面已经判断过删除位置合法，所以一定可以找到合适位置，while(true)循环肯定可以正常退出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iPosCount++;</span><br><span class="line">            <span class="keyword">if</span> (iPosCount &gt;= (iPos - <span class="number">1</span>))<span class="comment">// 找到了第i-1个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                iIdxPrev = tmp_cur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line">        <span class="type">int</span> iTmpCur = m_data[iIdxPrev].cur;<span class="comment">// 当前要删除的这个节点的数组下标</span></span><br><span class="line">        m_data[iIdxPrev].cur = m_data[iTmpCur].cur;<span class="comment">// 前一个系欸但的cur指向当前要删除节点的cur</span></span><br><span class="line">        m_data[iTmpCur].cur = e_NOUSE;<span class="comment">// 标记被删除数据节点的数组下标为未用状态</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;的元素，该元素值为:&quot;</span> &lt;&lt; m_data[iTmpCur].data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">StaticLinkList&lt;T&gt;::~<span class="built_in">StaticLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先暂时为空</span></span><br><span class="line">    <span class="comment">// 静态链表没有动态new空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSTATICLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyStaticLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StaticLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">5</span>, <span class="number">190</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">190</span>);</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">300</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">0</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">6</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">1</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">5</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">10</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">600</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">700</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/StaticLinkedList.png" alt="StaticLinkedList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 循环链表</title>
      <link href="/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/"/>
      <url>/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>循环链表的C++语言实现，模板方式。</p><span id="more"></span><h1 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单循环链表中每个节点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;       <span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;                <span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    Node&lt;T&gt;* next;         <span class="comment">// 指针域，指向下一个同类型(和本节点类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CirLinkList</span>();                   <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">CirLinkList</span>();                  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;    <span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;                <span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;    <span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;   <span class="comment">// 按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;              <span class="comment">// 输出单循环链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;             <span class="comment">// 获取单循环链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                 <span class="comment">// 判断单循环链表是否为空</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* m_head; <span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;    <span class="comment">// 单循环链表当前长度(当前有几个元素)，为编程更方便而引入的，但非必须</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对单循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    m_head-&gt;next = m_head;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要插入的位置，比如要在第2个位置插入，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next; </span><br><span class="line">    <span class="comment">// 让新节点链上后续链表，因为pcurr-&gt;next指向后续的链表节点</span></span><br><span class="line">    </span><br><span class="line">    p_curr-&gt;next = node; <span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length++;                                                     <span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next; </span><br><span class="line">        <span class="comment">// pcurr会找到当前要删除的位置所代表的节点的前一个节点的位置，比如要删除第2个位置的节点，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_curr-&gt;next;   <span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;   <span class="comment">// 第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length--;     <span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        e = p_curr-&gt;data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span> CirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;                                                      <span class="comment">// 返回-1表示查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出单循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != m_head)                                             <span class="comment">// 这里采用while循环或者for循环书写都可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;                                <span class="comment">// 每个数据之间以空格分隔</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;                                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span>  CirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_head-&gt;next == m_head)                                     <span class="comment">// 单循环链表为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对单循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::~<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">    Node&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != m_head)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;</span><br><span class="line">    m_head = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYCIRLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCirLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单循环链表</span></span><br><span class="line">    CirLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval); <span class="comment">//如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">100</span>; <span class="comment">//在单循环链表中要找的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单循环链表的长度为：&quot;</span> &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopLinkedList_1.png" alt="LoopLinkedList_1"></p><h1 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h1><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYDBLCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYDBLCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//双循环链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T        data;          <span class="comment">//数据域，存放数据元素</span></span><br><span class="line">    DblNode&lt;T&gt;* prior;      <span class="comment">//前趋指针，指向前一个同类型（和本节点类型相同）节点</span></span><br><span class="line">    DblNode&lt;T&gt;* next;       <span class="comment">//后继指针，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblCirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblCirLinkList</span>();     <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">DblCirLinkList</span>();    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;    <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;                <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;     <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;   <span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;               <span class="comment">//输出双循环链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;             <span class="comment">//获取双循环链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                  <span class="comment">//判断双循环链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;T&gt;* m_head;            </span><br><span class="line">    <span class="comment">//头指针（指向链表第一个节点的指针，如果链表有头结点则指向头结点）</span></span><br><span class="line">    <span class="type">int</span> m_length;                  </span><br><span class="line">    <span class="comment">//双循环链表当前长度（当前有几个元素），为编写程序更加方便和提高程序运行效率而引入，但不是必须引入</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对双循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblCirLinkList&lt;T&gt;::<span class="built_in">DblCirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> DblNode&lt;T&gt;;    <span class="comment">//先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = m_head;</span><br><span class="line">    m_head-&gt;prior = m_head;</span><br><span class="line">    m_length = <span class="number">0</span>;               <span class="comment">//头结点不计入双循环链表的长度     </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要插入的位置，比如要在第2个位置插入，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next; </span><br><span class="line">    <span class="comment">// 让新节点链上后续链表，因为pcurr-&gt;next指向后续的链表节点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;prior = p_curr;</span><br><span class="line">    <span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        p_curr-&gt;next-&gt;prior = node;</span><br><span class="line"></span><br><span class="line">    p_curr-&gt;next = node;   <span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length++;     <span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要删除的位置所代表的节点的前一个节点的位置，比如要删除第2个位置的节点，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_willdel = p_curr-&gt;next;   <span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    DblNode&lt;T&gt;* p_willdelNext = p_willdel-&gt;next; <span class="comment">// p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;  <span class="comment">// 第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_willdelNext != <span class="literal">nullptr</span>)</span><br><span class="line">        p_willdelNext-&gt;prior = p_curr;  <span class="comment">// 第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length--;       <span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        e = p_curr-&gt;data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span> DblCirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出双循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">void</span> DblCirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        DblNode&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != m_head)                                             <span class="comment">// 这里采用while循环或者for循环书写都可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;                                <span class="comment">// 每个数据之间以空格分隔</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span>  DblCirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_head-&gt;next == m_head)                                     <span class="comment">// 双循环链表为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对双循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblCirLinkList&lt;T&gt;::~<span class="built_in">DblCirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">    DblNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != m_head)                                         <span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;                                                  <span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;                                               <span class="comment">// 非必须</span></span><br><span class="line">    m_length = <span class="number">0</span>;                                                   <span class="comment">// 非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYDBLCIRLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblCirLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblCirLinkList&lt;<span class="type">int</span>&gt; sdblcirlinkobj;</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">2</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopLinkedList_2.png" alt="LoopLinkedList_2"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 双向链表</title>
      <link href="/2023/06/03/DataStructuresAndAlgorithms/003.DeList/"/>
      <url>/2023/06/03/DataStructuresAndAlgorithms/003.DeList/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>双向链表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYDBLLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYDBLLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，用于存放数据元素</span></span><br><span class="line">    DblNode&lt;T&gt;* prior; <span class="comment">// 前趋指针，指向前一个同类型(和本节点类型相同的)节点</span></span><br><span class="line">    DblNode&lt;T&gt;* next; <span class="comment">// 后继指针，指向下一个同类型(和本节点类型相同的)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblLinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">DblLinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(DblNode&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 通过已知节点之前插入新元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeletePriorNode</span><span class="params">(DblNode&lt;T&gt;* p_del)</span></span>;<span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出双链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispListAndAddr</span><span class="params">()</span></span>;<span class="comment">// 输出双链表中的所有元素并打印地址</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取双链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">// 判断双链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListReverse</span><span class="params">()</span></span>;<span class="comment">// 双链表的翻转操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DblNode&lt;T&gt;* <span class="title">GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DblNode&lt;T&gt;* p_tmp = m_head;</span><br><span class="line">        <span class="keyword">return</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;T&gt;* m_head;</span><br><span class="line">    <span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点，则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 双链表当前长度(当前有几个元素),</span></span><br><span class="line">    <span class="comment">// 为了编写程序更方便和提高程序运行效率而引入，但不是必须引入。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的翻转操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListReverse</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next-&gt;next;</span><br><span class="line">    m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    DblNode&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_curr!= <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_curr;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        p_tmp-&gt;prior = m_head;</span><br><span class="line">        p_tmp-&gt;next = m_head-&gt;next;</span><br><span class="line">        m_head-&gt;next-&gt;prior = p_tmp;</span><br><span class="line">        m_head-&gt;next = p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取双链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断双链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*if (m_length &lt; 1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    <span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="comment">// 如果是不带头节点的双链表，则用if(m_head == nullptr)来判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; i || i &gt;(m_length ))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中第一次出现的位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对双链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkList&lt;T&gt;::<span class="built_in">DblLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> DblNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 该值暂时为nullptr，因为还没有后继节点</span></span><br><span class="line">    m_head-&gt;prior = <span class="literal">nullptr</span>;<span class="comment">// 该值一直为nullptr</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 头结点不计入双链表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的元素插入操作  在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断插入的位置i是否合法，i的合法位置应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; (m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于扎到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头节点)</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next;</span><br><span class="line">    <span class="comment">// 让新节点链上后续节点，因为p_curr-&gt;next 指向后续的链表节点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;prior = p_curr;<span class="comment">// 新节点的前趋节点指向当前p_curr节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr-&gt;next-&gt;prior = node;<span class="comment">// 原p_curr的下一个节点的前趋指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p_curr-&gt;next = node;<span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;<span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过已知节点之前插入新元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">InsertPriorNode</span>(DblNode&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* new_node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    new_node-&gt;data = e;</span><br><span class="line">    new_node-&gt;next = p_curr;</span><br><span class="line">    new_node-&gt;prior = p_curr-&gt;prior;</span><br><span class="line">    p_curr-&gt;prior-&gt;next = new_node;</span><br><span class="line">    p_curr-&gt;prior = new_node;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出双链表中的所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>  DblLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;  </span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出双链表中的所有元素并打印地址</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>  DblLinkList&lt;T&gt;::<span class="built_in">DispListAndAddr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m_head:&quot;</span> &lt;&lt; m_head &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node :&quot;</span> &lt;&lt; i &lt;&lt; p_curr &lt;&lt; <span class="string">&quot;  value:&quot;</span> &lt;&lt; p_curr-&gt;data &lt;&lt; std::endl;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkList&lt;T&gt;::~<span class="built_in">DblLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_node = m_head-&gt;next;</span><br><span class="line">    DblNode&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_node != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_node;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;<span class="comment">// 非必须</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;<span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头结点)</span></span><br><span class="line">        p_curr = p_curr-&gt;next;  </span><br><span class="line">        <span class="comment">// p_curr会找到当前要删除的位置所代表的节点的前一个节点位置，</span></span><br><span class="line">        <span class="comment">// 比如要删除第2个位置的节点，p_curr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    DblNode&lt;T&gt;* p_willdelNext = p_willdel-&gt;next;</span><br><span class="line">    <span class="comment">// p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">    </span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">// 第i-1个节点的next指针指向第i+1节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_willdelNext != <span class="literal">nullptr</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        p_willdelNext-&gt;prior = p_curr;</span><br><span class="line">        <span class="comment">// 第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">DeletePriorNode</span>(DblNode&lt;T&gt;* p_del)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_del_prod = p_del-&gt;prior;</span><br><span class="line">    DblNode&lt;T&gt;* p_del_next = p_del-&gt;next;</span><br><span class="line">    p_del_prod-&gt;next = p_del_next;</span><br><span class="line">    <span class="keyword">if</span> (p_del_next)</span><br><span class="line">    &#123;</span><br><span class="line">        p_del_next-&gt;prior = p_del_prod;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除元素为:&quot;</span> &lt;&lt; p_del-&gt;data &lt;&lt; <span class="string">&quot;的节点!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p_del;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYDBLLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblLinkList&lt;<span class="type">int</span>&gt; sdbllinkobj;</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转双链表前打印元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispListAndAddr</span>();</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListReverse</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转双链表后打印元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispListAndAddr</span>();</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/DeList.png" alt="DeList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 单链表</title>
      <link href="/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/"/>
      <url>/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>单链表的<code>C++</code>语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    Node&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型(和本类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(Node&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeletePriorNode</span><span class="params">(Node&lt;T&gt;* p_del)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在单链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出单链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取单链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">// 判断单链表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;<span class="comment">// 翻转单链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt;* <span class="title">GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* m_head;<span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点，则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 单链表当前长度(当前有几个元素),</span></span><br><span class="line">    <span class="comment">// 为了编写程序更方便和提高程序运行效率而引入，但不是必须引入。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对单链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 头结点的指针域指向空</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 头结点不计入单链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不带头结点的单链表 </span></span><br><span class="line"><span class="comment">m_head = mullptr;</span></span><br><span class="line"><span class="comment">m_length = 0;  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带头节点的单链表插入操作</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断插入位置是否合法，i的合法值应该时从 1 到 m_length + 1 之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法,合法的位置是:[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">// j从0开始，表示p_curr更开始指向的是第0个节点(头结点)</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;<span class="comment">// p_curr会找到当前要插入的位置，</span></span><br><span class="line">        <span class="comment">// 比如要在第2个位置插入,p_curr最终会指向第1个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">// ①   创建新节点</span></span><br><span class="line">    node-&gt;data = e;<span class="comment">// ②</span></span><br><span class="line">    node-&gt;next = p_curr-&gt;next;<span class="comment">// ③   让新节点链上后续链表，因为p_curr-&gt;next指向的是后续链表的节点</span></span><br><span class="line">    p_curr-&gt;next = node;<span class="comment">// ④   让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;<span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 不带头结点的单链表插入操作</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e  【【仅供参考】】</span></span><br><span class="line"><span class="comment">template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">bool LinkList&lt;T&gt;::ListInsert(int i, const T&amp; e)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">// 判断插入位置是否合法，i的合法值应该时从 1 到 m_length + 1 之间</span></span><br><span class="line"><span class="comment">if (i &lt; 1 || i &gt;(m_length + 1))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;元素:&quot; &lt;&lt; e &lt;&lt; &quot;插入位置:&quot; &lt;&lt; i &lt;&lt; &quot;不合法,合法的位置是:[1~&quot; &lt;&lt; m_length + 1 &lt;&lt; &quot;]!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (i == 1)  // 插入到第一个位置与插入到其他位置不同，需要单独处理</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* node = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">node-&gt;data = e;</span></span><br><span class="line"><span class="comment">node-&gt;next = m_head;   // m_head原来指向的啥，就让新创建的 node(新的头结点)指向m_head</span></span><br><span class="line"><span class="comment">m_head = node;   // 头指针指向新插入的第一个节点</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;成功在位置为:&quot; &lt;&lt; i &lt;&lt; &quot;处插入元素:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">++m_length;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 插入的不是第一个位置，测程序流程继续向下走</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* p_curr = m_head;</span></span><br><span class="line"><span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt; (i - 1); ++j)  // j从1开始，表示p_curr刚开始指向的是第1个节点</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">p_curr = p_curr-&gt;next;</span></span><br><span class="line"><span class="comment"> // p_curr会找到当前要插入的位置，比如要在第2个位置插入，p_curr会指向第1个节点</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* node = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">node-&gt;data = e;</span></span><br><span class="line"><span class="comment">node-&gt;next = p_curr-&gt;next;  // 让新节点链上后续链表,因为p_curr-&gt;next指向的就是后续链表节点</span></span><br><span class="line"><span class="comment">p_curr-&gt;next = node;  // 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;成功在位置为:&quot; &lt;&lt; i &lt;&lt; &quot;处插入元素:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">++m_length;  // 实际长度+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现向某个已知节点之前插入新节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">InsertPriorNode</span>(Node&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在节点p_curr之前插入新节点，新节点数据域元素值为e</span></span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next;</span><br><span class="line">    p_curr-&gt;next = node;</span><br><span class="line">    node-&gt;data = p_curr-&gt;data;</span><br><span class="line">    p_curr-&gt;data = e;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表为空，无法删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;  </span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头结点)</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// p_curr会找到当前要删除的位置所代表的节点的前一个节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">// 第i-1个节点的next指针指向了第i+1个节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">DeletePriorNode</span>(Node&lt;T&gt;* p_del)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 思想：把要删除的节点的下一个节点数据域拷贝到当前要删除的节点，</span></span><br><span class="line">    <span class="comment">// 当前要删除的节点的指针域指向下一个节点的指针域指向的节点。</span></span><br><span class="line">    <span class="comment">// 这样就相当于把待删除的节点的下一个节点数据拷贝到了需要待删除的节点上。</span></span><br><span class="line">    <span class="comment">// 然后真正删除的是待删除节点的下一个节点，从而实现时间复杂度为O(1)</span></span><br><span class="line">    <span class="comment">// 删除p_del所指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_del-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 待删除的节点正好是最后一个节点,不能用这种方法删除，只能常规删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ListDelete</span>(m_length);</span><br><span class="line">    &#125;</span><br><span class="line">    p_del-&gt;data = p_del-&gt;next-&gt;data;<span class="comment">// 把待删除的下一个节点的数据保存到当前的需要删除节点的数据域</span></span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_del-&gt;next;<span class="comment">// 待删除的节点的下一个节点(真正要删除的节点)</span></span><br><span class="line">    p_del-&gt;next = p_willdel-&gt;next;</span><br><span class="line">    --m_length;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除节点元素值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;的节点!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表为空，无法获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在单链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p_curr-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中第一次出现的位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中不存在!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出单链表中的所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始打印单链表的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head-&gt;next;<span class="comment">// 直接略过头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p_curr!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;单链表元素打印结束!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// O(1)</span></span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断单链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// O(1)</span></span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  带头节点的还可以这样判断</span></span><br><span class="line"><span class="comment">if (m_head-&gt;next == nullptr)</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转单链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123; <span class="comment">// 这个不是针对数据域的翻转，而是整个节点的翻转</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表中的元素不超过1个，不用做任何翻转操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 至少有2个节点才会走到这里</span></span><br><span class="line">    Node&lt;T&gt;* pothersjd = m_head-&gt;next-&gt;next;<span class="comment">// 指向从第二个节点开始的后续节点</span></span><br><span class="line">    m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 把第一个节点的指针域先置空</span></span><br><span class="line">    Node&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (pothersjd != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = pothersjd;<span class="comment">// 当前需要移动的元素</span></span><br><span class="line">        pothersjd = pothersjd-&gt;next;<span class="comment">// 指向下一个需要移动的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ListInsert(1, p_tmp);// 这样也可以</span></span><br><span class="line">        p_tmp-&gt;next = m_head-&gt;next;</span><br><span class="line">        m_head-&gt;next = p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放单链表-析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* p_node = m_head-&gt;next;</span><br><span class="line">    Node&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_node != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_node;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;<span class="comment">//非必须，但是是个好习惯</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 长度置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main 主函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);<span class="comment">// 删除第四个位置的节点</span></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval);</span><br><span class="line">    <span class="comment">// 如果GetElem返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">100</span>;<span class="comment">// 在单链表中要找的元素值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单链表的长度:&quot;</span> &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单链表是否为空:&quot;</span> &lt;&lt; slinkobj.<span class="built_in">Empty</span>() &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SinglyLinkedList.png" alt="SinglyLinkedList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序表</title>
      <link href="/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/"/>
      <url>/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>顺序表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySeqList.h 文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>(<span class="type">int</span> length = InitSize);<span class="comment">// 构造函数，参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">SeqList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">// 接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获取第i个位置的元素，值通过形参引用方式返回</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出顺序表中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取顺序表长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;<span class="comment">// 反转顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;<span class="comment">// 当顺序表满了，扩容函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;<span class="comment">// 存放顺序表中的元素</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 当前长度</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;<span class="comment">// 最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::<span class="built_in">SeqList</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 顺序表当前长度为0，表示还没有存储任何元素</span></span><br><span class="line">    m_maxsize = length;<span class="comment">// 顺序表最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">    m_maxsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表元素插入</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(n)，时间开销主要是缘于元素的移动</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 如果数组表已经存在，则不允许再插入数据，当前先这样，后续课程再完善</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">IncreaseSize</span>();<span class="comment">// 存满了，扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断插入位置i是否合法，i的和法治应该时从1到m_length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;].&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从最后一个元素开始向前遍历到要插入新元素的第i个位置，</span></span><br><span class="line">    <span class="comment">// 分别将这些位置中原有的元素向后移动一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m_length; j &gt;= i; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[j] = m_data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[i - <span class="number">1</span>] = e;<span class="comment">// 在指定位置i出插入元素e，因为数组下标从0开始，所以这里用i-1表示插入位置所对应的数组下标</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)<span class="comment">// 空的元素表</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;空列表，无法进行删除操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从数组中第i+1个位置开始向后遍历所有元素，分别将这些位置中原有的元素向前移动一个位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m_length; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[j - <span class="number">1</span>] = m_data[j];<span class="comment">// 依次往前移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)<span class="comment">// 参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)<span class="comment">// 空的元素表</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;空列表，无法获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[i - <span class="number">1</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)<span class="comment">// 参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中第一次出现的位置为&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;<span class="comment">// 返回位置应该用数组 下标值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里，在该顺序表中没有找到对应的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表元素的其他常用操作</span></span><br><span class="line"><span class="comment">// 输出顺序表中所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">DispList</span>()  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取顺序表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转顺序表reverse，时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T temp;<span class="comment">// 中间变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length / <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = m_data[i];</span><br><span class="line">        m_data[i] = m_data[m_length - i - <span class="number">1</span>];  </span><br><span class="line">        <span class="comment">// 第一个和最后一个交换，依次往后走 第二个和倒数第二交换...</span></span><br><span class="line">        m_data[m_length - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表的扩展操作</span></span><br><span class="line"><span class="comment">// 当顺序表存满数据后可以调用此函数为顺序表扩容,时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T* p = m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[m_maxsize + IncSize];</span><br><span class="line">    <span class="comment">// 重新为顺序表分配更大的内存空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = p[i];<span class="comment">// 将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_maxsize += IncSize;<span class="comment">// 顺序表最大长度郑家IncSize</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MYSEQLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqList.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m_data[<span class="number">10</span>];  <span class="comment">// 静态数组来保存顺序表中的元素</span></span><br><span class="line">        <span class="comment">// 最多能存储10个元素</span></span><br><span class="line">        <span class="type">int</span> m_length;  <span class="comment">// 顺序表中当前实际长度(已存在的元素个数)</span></span><br><span class="line">    &#125; SeqList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* m_data; <span class="comment">// 顺序表中的元素保存在m_data所指向的动态数组内存中</span></span><br><span class="line">        <span class="type">int</span> m_length;  <span class="comment">// 顺序表中当前实际长度(已存在的元素个数)</span></span><br><span class="line">        <span class="type">int</span> m_maxsize;   <span class="comment">// 动态数组最大容量，因为动态数组可以扩容，因此要记录该值</span></span><br><span class="line">    &#125; SeqList_Dync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SeqList&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">30</span>, <span class="number">8</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListDelete</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> get_res = seqobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval);</span><br><span class="line">    <span class="comment">// 如果get_res值为true，则eval中保存着获取到的元素值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">10</span>;  <span class="comment">// 在顺序表中要找的元素值</span></span><br><span class="line">    <span class="type">int</span> find_res = seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    findvalue = <span class="number">22</span>;  <span class="comment">// 这里改为了22，表示查找值22这个元素的下标</span></span><br><span class="line">    find_res = seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line"></span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前顺序表中存在元素个数:&quot;</span> &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; std::endl;</span><br><span class="line">    seqobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        seqobj.<span class="built_in">ListInsert</span>(i, i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前顺序表中存在元素个数:&quot;</span> &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; std::endl;</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqList.png" alt="SeqList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 导航栏</title>
      <link href="/2023/05/31/DataStructuresAndAlgorithms/000.DataStructersAndAlgorithmsIndex/"/>
      <url>/2023/05/31/DataStructuresAndAlgorithms/000.DataStructersAndAlgorithmsIndex/</url>
      
        <content type="html"><![CDATA[<p><strong>数据结构与算法 - 快速导航</strong></p><span id="more"></span><p><a href="https://brkzh.github.io/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/">数据结构与算法 – 顺序表</a></p><p><a href="https://brkzh.github.io/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/">数据结构与算法 – 单链表</a></p><p><a href="https://brkzh.github.io/2023/06/03/DataStructuresAndAlgorithms/003.DeList/">数据结构与算法 – 双链表</a></p><p><a href="https://brkzh.github.io/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/">数据结构与算法 – 循环链表</a></p><p><a href="https://brkzh.github.io/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/">数据结构与算法 – 静态链表</a></p><p><a href="https://brkzh.github.io/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/">数据结构与算法 – 顺序栈</a></p><p><a href="https://brkzh.github.io/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/">数据结构与算法 – 共享栈</a></p><p><a href="https://brkzh.github.io/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/">数据结构与算法 – 链式栈</a></p><p><a href="https://brkzh.github.io/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/">数据结构与算法 – 顺序队列</a></p><p><a href="https://brkzh.github.io/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/">数据结构与算法 – 链式队列</a></p><p><a href="https://brkzh.github.io/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/">数据结构与算法 – 双端队列</a></p><p><a href="https://brkzh.github.io/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/">数据结构与算法 – 循环队列</a></p><p><a href="https://brkzh.github.io/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/">数据结构与算法 – 二叉树(顺序存储)</a></p><p><a href="https://brkzh.github.io/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/">数据结构与算法 – 二叉树(链式存储)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode配置免密远程Ubuntu</title>
      <link href="/2023/02/01/Notes/VS_Code_Remote_Ubuntu_SSH/"/>
      <url>/2023/02/01/Notes/VS_Code_Remote_Ubuntu_SSH/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode配置免密远程Ubuntu"><a href="#VSCode配置免密远程Ubuntu" class="headerlink" title="VSCode配置免密远程Ubuntu"></a>VSCode配置免密远程Ubuntu</h1><p>VSCode远程连接Ubuntu系统进行开发，如果没有配置密钥文件，每次都需要手动输入密码，特别烦，因此本篇文章告诉你如何配置密钥文件，从此不再需要频繁手动输入密码了。</p><span id="more"></span><h2 id="本地机器配置"><a href="#本地机器配置" class="headerlink" title="本地机器配置"></a>本地机器配置</h2><p>安装<code>VSCode</code>，注意，如果远程<code>Ubuntu</code>主机版本是<code>18.04</code>及以下版本,建议不要安装太新版本的<code>VSCode</code>。</p><p><a href="https://vscode.download.prss.microsoft.com/dbazure/download/stable/e10f2369d0d9614a452462f2e01cdc4aa9486296/VSCodeUserSetup-x64-1.94.1.exe">下载地址 VSCodeUserSetup-x64-1.94.1.exe</a></p><p>安装完<code>VSCode</code>后，安装<code>remote ssh</code>插件</p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_1.png" alt="VS_Code_Remote_Ubuntu_SSH_1"></p><p>插件安装成功后，在左侧菜单栏会多出一个远程管理的图标，点击，添加<code>ssh</code>配置信息</p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_2.png" alt="VS_Code_Remote_Ubuntu_SSH_2"></p><p>弹出的选项，选择要在哪里保存<code>config</code>配置文件，这里推荐使用第一项</p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_3.png" alt="VS_Code_Remote_Ubuntu_SSH_3"></p><p>默认的<code>config</code>配置文件如下</p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_4.png" alt="VS_Code_Remote_Ubuntu_SSH_4"></p><p>修改配置文件之前，先生产使用<code>ssh-keygen</code>生成密钥</p><p>打开<code>Git</code>(或者<code>cmd</code>需要安装了ssh等相关工具才行)</p><p>[Git下载官网](<a href="https://git-scm.com/downloads/win">Git - Downloading Package (git-scm.com)</a>)</p><p><a href="https://objects.githubusercontent.com/github-production-release-asset-2e65be/23216272/b956bf27-aac4-4674-bcf3-bb4ff2e61e22?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=releaseassetproduction/20241009/us-east-1/s3/aws4_request&X-Amz-Date=20241009T054048Z&X-Amz-Expires=300&X-Amz-Signature=5782efc5ba22d429de902c37c4c0699408fee1756f1da9e7daba05795aa52afd&X-Amz-SignedHeaders=host&response-content-disposition=attachment;%20filename=Git-2.47.0-64-bit.exe&response-content-type=application/octet-stream">Git-2.47.0-64-bit.exe</a></p><p>安装了<code>Git</code>工具后，鼠标右键，选择<code>Open Git Bash here</code>，然后输入命令<code>ssh-keygen -t rsa -b 4096</code>，生成的时候可以直接指定密钥文件名，也可以生成后手动命名。</p><p>这里我把生成的密钥文件放在了用户目录下的<code>.ssh</code>目录。</p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_5.png" alt="VS_Code_Remote_Ubuntu_SSH_5"></p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_6.png" alt="VS_Code_Remote_Ubuntu_SSH_6"></p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_7.png" alt="VS_Code_Remote_Ubuntu_SSH_7"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host Ubuntu</span><br><span class="line">    HostName 192.168.31.222</span><br><span class="line">    Port 22</span><br><span class="line">    User ubuntu</span><br><span class="line">    IdentityFile C:<span class="keyword">\Users</span><span class="keyword">\Acer</span><span class="keyword">\VSCode</span><span class="built_in">_</span>Ubuntu<span class="built_in">_</span>id<span class="built_in">_</span>rsa</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">Host 别名,自定义</span><br><span class="line">HostName 远程主机地址</span><br><span class="line">Port 远程主机ssh端口,默认22</span><br><span class="line">User 远程主机用户名</span><br><span class="line">IdentityFile 密钥文件路径</span><br></pre></td></tr></table></figure><h1 id="远程Ubuntu的配置"><a href="#远程Ubuntu的配置" class="headerlink" title="远程Ubuntu的配置"></a>远程Ubuntu的配置</h1><p>修改远程 <code>Ubuntu</code>系统的<code>ssh</code>配置文件</p><p><code>sudo vim /etc/ssh/sshd_config</code></p><p>这里最重要的是我们要把<code>PubkeyAuthentication</code>配置为<code>yes</code>允许使用基于密钥认证的方式登录。</p><p>重启<code>ssh</code>服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service ssh stop      <span class="comment">#停止。</span></span><br><span class="line"><span class="built_in">sudo</span> service ssh start     <span class="comment">#启动。</span></span><br><span class="line"><span class="built_in">sudo</span> service ssh restart   <span class="comment">#重启。</span></span><br></pre></td></tr></table></figure><p>最后，将客户端的公钥<code>VSCode_Ubuntu_id_rsa.pub</code>文件上传到对应用户根目录的<code>.ssh</code>文件夹下，进入<code>.ssh</code>中将公钥的内容拷贝到<code>authorized_keys</code>文件中</p><p>如果 用户的<code>home</code>目录没有 <code>.ssh</code>文件夹，那就创建一个。</p><p>把<code>VSCode_Ubuntu_id_rsa.pub</code>放进去，然后改名字，改为 <code>authorized_keys</code></p><p>给文件夹赋予权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 .ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>到此就配置完成了,点击如下图，进行远程访问。</p><p><img src="https://brkzh.github.io/docPics/Notes/VS_Code_Remote_Ubuntu_SSH/VS_Code_Remote_Ubuntu_SSH_8.png" alt="VS_Code_Remote_Ubuntu_SSH_8"></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win系统tcp模拟粘包Demo - C语言</title>
      <link href="/2023/01/02/C_CPlusPlus/TcSimulationPacketSticking_Win_C/"/>
      <url>/2023/01/02/C_CPlusPlus/TcSimulationPacketSticking_Win_C/</url>
      
        <content type="html"><![CDATA[<h1 id="Win系统tcp模拟粘包Demo-C语言"><a href="#Win系统tcp模拟粘包Demo-C语言" class="headerlink" title="Win系统tcp模拟粘包Demo - C语言"></a>Win系统tcp模拟粘包Demo - C语言</h1><p><strong>粘包</strong>：客户端发送的多个数据包被当做一个数据包接收。</p><p>也叫做 <strong>数据的无边界性</strong></p><span id="more"></span><p>函数 <code>recv()/read()</code> 是不知道数据包的开始、结束标志的（实际上也没有标志），这两个函数只把数据包当作连续的数据流来处理的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：server.c</span></span><br><span class="line"><span class="comment">// 描述：服务器端代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 11111</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    SOCKET servSock =  socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockAddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(SERV_IP);</span><br><span class="line">    sockAddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server IP:%s\nServer Port:%d\n&quot;</span>,SERV_IP, SERV_PORT);</span><br><span class="line">    bind(servSock, (SOCKADDR*)&amp;sockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入监听</span></span><br><span class="line">    listen(servSock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wait Client Accept\n&quot;</span>);</span><br><span class="line">    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client Connected\n&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">8000</span>);  <span class="comment">// 这里让程序暂停8秒钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据，并原样返回</span></span><br><span class="line">    <span class="type">int</span> recvLen = recv(clntSock, buffer, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    send(clntSock, buffer, recvLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字并终止DLL的使用</span></span><br><span class="line">    closesocket(clntSock);</span><br><span class="line">    closesocket(servSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server is Closed\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：client.c</span></span><br><span class="line"><span class="comment">// 描述：客户端代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockAddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    sockAddr.sin_port = htons(<span class="number">11111</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    connect(sock, (SOCKADDR*)&amp;sockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户输入的字符串并发送给服务器</span></span><br><span class="line">    <span class="type">char</span> bufSend[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string:&quot;</span>);</span><br><span class="line">    gets(bufSend);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        send(sock, bufSend, <span class="built_in">strlen</span>(bufSend), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> bufRecv[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Recving Message From Server.\n&quot;</span>);</span><br><span class="line">    recv(sock, bufRecv, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server:%s\n&quot;</span>, bufRecv);</span><br><span class="line"></span><br><span class="line">    closesocket(sock); <span class="comment">// 关闭套接字</span></span><br><span class="line">    WSACleanup();  <span class="comment">// 终止使用DLL</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译脚本</strong></p><p>文件名：<code>编译.bat</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o server server.c -lws2_32</span><br><span class="line">gcc -o client client.c -lws2_32</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/TcSimulationPacketSticking_Win_C/TcSimulationPacketSticking_Win_C.png" alt="TcSimulationPacketSticking_Win_C"></p><p><strong>说明</strong></p><p><code>client</code> 的 <code>send()</code> 发送了三个数据包，而 <code>server</code> 的 <code>recv()</code> 却只接收到一个数据包，这很好的说明了数据的粘包问题。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现配置文件的读写</title>
      <link href="/2023/01/01/C_CPlusPlus/ConfigurationFileLoadingAndModify_C/"/>
      <url>/2023/01/01/C_CPlusPlus/ConfigurationFileLoadingAndModify_C/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言实现配置文件的读写"><a href="#C语言实现配置文件的读写" class="headerlink" title="C语言实现配置文件的读写"></a>C语言实现配置文件的读写</h1><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>global.h</td><td>定义一些宏</td></tr><tr><td>Func.h</td><td>公用函数头文件</td></tr><tr><td>Func.c</td><td>公用函数的实现</td></tr><tr><td>config.h</td><td>读写配置文件的函数声明</td></tr><tr><td>config.c</td><td>读写配置文件的函数实现</td></tr><tr><td>config_main.c</td><td>主函数入口</td></tr><tr><td>config.conf</td><td>配置文件</td></tr></tbody></table><span id="more"></span><p>直接上代码，一些解释以注释的形式写在了相应的文件里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：global.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GLOBAL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GLOBAL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__GLOBAL_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：Func.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __Func_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __Func_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rtrim</span><span class="params">(<span class="type">char</span>* sstring)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Ltrim</span><span class="params">(<span class="type">char</span>* sstring)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较str1和str2两个字符串内容是否一样，忽略大小写的比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StrcaseCmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把str全都变成大写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCase</span><span class="params">(<span class="type">char</span>* str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__Func_h__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：Func.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//截取字符串尾部空格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rtrim</span><span class="params">(<span class="type">char</span> *sstring)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sstring == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">len = <span class="built_in">strlen</span>(sstring);</span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span> &amp;&amp; sstring[len - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)<span class="comment">//位置换一下</span></span><br><span class="line">sstring[--len] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取字符串首部空格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ltrim</span><span class="params">(<span class="type">char</span> *sstring)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sstring == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">char</span> *p_tmp = sstring;  <span class="comment">//此时p_tmp指向了sstring</span></span><br><span class="line"><span class="keyword">if</span> ((*p_tmp) != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">return</span>;  <span class="comment">//不是以空格开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个不为空格的位置</span></span><br><span class="line"><span class="keyword">while</span> ((*p_tmp) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*p_tmp) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">p_tmp++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*p_tmp) == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//全是空格</span></span><br><span class="line">&#123;</span><br><span class="line">*sstring = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *p_tmp2 = sstring;  <span class="comment">//此时 p_tmp2 指向了 sstring</span></span><br><span class="line"><span class="keyword">while</span> ((*p_tmp2) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*p_tmp2) = (*p_tmp);</span><br><span class="line">p_tmp++;</span><br><span class="line">p_tmp2++;</span><br><span class="line">&#125;</span><br><span class="line">(*p_tmp2) = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//空格处理完毕，记得在末尾添加一个&#x27;\0&#x27; 表示字符串结尾</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较str1和str2两个字符串内容是否一样，忽略大小写的比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StrcaseCmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1 == <span class="literal">NULL</span> || str2 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">size_t</span> strLen1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="type">size_t</span> strLen2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line"><span class="keyword">if</span> (strLen1 != strLen2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// char *str = new char[strLen2]; </span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">malloc</span>(strLen2);</span><br><span class="line"><span class="built_in">strcpy</span>(str, str2); <span class="comment">//把str2的内容拷贝到str中</span></span><br><span class="line">StringCase(str);  <span class="comment">//把str中的所有内容转成大写字母</span></span><br><span class="line"><span class="keyword">while</span> ((*str) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*str1) &gt; <span class="number">90</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (((*str1) - <span class="number">32</span>) == (*str))</span><br><span class="line">&#123;</span><br><span class="line">++str1;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*str1) == (*str))</span><br><span class="line">&#123;</span><br><span class="line">++str1;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把str中所有的小写字母变成大写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCase</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(str) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> strLen = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="type">char</span> *ptmp = str;</span><br><span class="line"><span class="keyword">while</span> ((*ptmp) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">97</span> &lt;= (*ptmp)) &amp;&amp; ((*ptmp) &lt;= <span class="number">122</span>))</span><br><span class="line">&#123;</span><br><span class="line">(*ptmp) -= <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">++ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：config.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CONFIG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CONFIG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// item数组的大小，也是配置文件中有效的item项目的最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGSTRUCTSIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGNAMESIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGCONTENTSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ItemName[CONFIGNAMESIZE];</span><br><span class="line">    <span class="type">char</span> ItemContent[CONFIGCONTENTSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pconfName)</span>;</span><br><span class="line"><span class="comment">// 通过item名字获取item的内容</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetConfigFromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname)</span>;</span><br><span class="line"><span class="comment">// 通过item名字获取item内容，整型，获取不到返回默认值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetConfigIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 释放内存</span></span><br><span class="line"><span class="comment">// void FreeConfigItem();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写配置文件</span></span><br><span class="line"><span class="comment">// 通过item名字修改item内容</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ModifyConfigItemContent</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span>;</span><br><span class="line"><span class="comment">// 通过item名字和内容 添加新的item项目</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">AddConfigItem</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span>;</span><br><span class="line"><span class="comment">// 把加载进来的、或者有修改过了、增加过的 item数组写到指定的文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">WriteNewConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pconfName)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__CONFIG_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：config.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> arr_curr_ind = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span> <span class="title">ArrayConfig</span>[<span class="title">CONFIGSTRUCTSIZE</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pconfName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr_curr_ind &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(pconfName, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一行配置文件读取出来放到这里</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> linebuf_size = CONFIGCONTENTSIZE + <span class="number">1</span> + CONFIGNAMESIZE + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> linebuf[linebuf_size];  <span class="comment">// 128+1 结尾为结束符</span></span><br><span class="line">    <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(linebuf));</span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fgets(linebuf, linebuf_size, fp) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(linebuf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(*linebuf == <span class="string">&#x27;;&#x27;</span> || *linebuf == <span class="string">&#x27; &#x27;</span> || *linebuf == <span class="string">&#x27;#&#x27;</span> || *linebuf == <span class="string">&#x27;\t&#x27;</span> || *linebuf == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除字符串中的 \r \n 以及空格&#x27; &#x27;</span></span><br><span class="line">    lblprocstring:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(linebuf) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] == <span class="number">10</span> || linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] == <span class="number">13</span> || linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] == <span class="number">32</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">goto</span> lblprocstring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(linebuf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*linebuf == <span class="string">&#x27;[&#x27;</span>)  <span class="comment">// [ 开头的注释，也保存，方便以后写文件时写回去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr_curr_ind &lt; CONFIGSTRUCTSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemName, linebuf);</span><br><span class="line">                <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemContent, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">// ArrayConfig[arr_curr_ind] = p_configitem;</span></span><br><span class="line">                arr_curr_ind += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ERROR</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，都是合法的配置项</span></span><br><span class="line">        <span class="type">char</span> *ptmp = <span class="built_in">strchr</span>(linebuf, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr_curr_ind &lt; CONFIGSTRUCTSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strncpy</span>(ArrayConfig[arr_curr_ind].ItemName, linebuf, (<span class="type">int</span>)(ptmp-linebuf));</span><br><span class="line">                <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemContent, ptmp+<span class="number">1</span>);</span><br><span class="line">                Rtrim(ArrayConfig[arr_curr_ind].ItemName);</span><br><span class="line">                Ltrim(ArrayConfig[arr_curr_ind].ItemName);</span><br><span class="line">                Rtrim(ArrayConfig[arr_curr_ind].ItemContent);</span><br><span class="line">                Ltrim(ArrayConfig[arr_curr_ind].ItemContent);</span><br><span class="line">                arr_curr_ind += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ERROR</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end if</span></span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetConfigFromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p_itemname, ArrayConfig[i].ItemName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ArrayConfig[i].ItemContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetConfigIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p_itemname, ArrayConfig[i].ItemName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> atoi(ArrayConfig[i].ItemContent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> def;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ModifyConfigItemContent</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p_itemName || !p_itemContent)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret_res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p_itemName, ArrayConfig[i].ItemName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(ArrayConfig[i].ItemContent, p_itemContent);</span><br><span class="line">            ret_res = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AddConfigItem</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p_itemName || !p_itemContent)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret_res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;arr_curr_ind; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ret_res = ModifyConfigItemContent(p_itemName, p_itemContent);</span><br><span class="line">        <span class="keyword">if</span>(ret_res == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ret_res;</span><br><span class="line">    &#125;</span><br><span class="line">    ret_res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr_curr_ind &lt; CONFIGSTRUCTSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemName, p_itemName);</span><br><span class="line">        <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemContent, p_itemContent);</span><br><span class="line">        arr_curr_ind += <span class="number">1</span>;</span><br><span class="line">        ret_res = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret_res = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">WriteNewConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pconfName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pconfName)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> new_fd;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (new_fd = open(pconfName,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> line_buf[<span class="number">32</span>+<span class="number">128</span>+<span class="number">1</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="type">char</span> equal_char = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(ArrayConfig[i].ItemName) == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            equal_char = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            equal_char = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(line_buf, <span class="string">&quot;%s%c%s\n&quot;</span>, ArrayConfig[i].ItemName, equal_char, ArrayConfig[i].ItemContent);</span><br><span class="line">        write(new_fd, line_buf, <span class="built_in">strlen</span>(line_buf));</span><br><span class="line">        <span class="built_in">memset</span>(line_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(line_buf));</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：config_main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* config_file = <span class="string">&quot;./config.conf&quot;</span>;</span><br><span class="line"></span><br><span class="line">    LoadConfigFile(config_file);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = GetConfigFromString(<span class="string">&quot;server_url&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = GetConfigIntDefault(<span class="string">&quot;server_port&quot;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="keyword">if</span> (ip)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;url:%s\t&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%d\n&quot;</span>, port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;device_id:%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;device_id&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;device_name:%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;device_name&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serv_pub_info_url=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;serv_pub_info_url&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serv_pub_curr_log=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;serv_pub_curr_log&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serv_pub_hist_log=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;serv_pub_hist_log&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;certificate=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;certificate&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>文件名：config.conf</code></strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[服务器地址]</span>  </span><br><span class="line"><span class="attr">server_url</span>=<span class="number">192.168</span>.<span class="number">137.1</span></span><br><span class="line"><span class="attr">server_port</span>=<span class="number">80</span></span><br><span class="line"><span class="section">[信息推送地址]</span>  </span><br><span class="line"><span class="attr">serv_regi_dev_url</span>=/regist_dev</span><br><span class="line"><span class="attr">serv_pub_info_url</span>=/pub_dev_info</span><br><span class="line"><span class="attr">serv_pub_curr_log</span>=/pub_current_log</span><br><span class="line"><span class="attr">serv_pub_hist_log</span>=/pub_history_log</span><br><span class="line"><span class="section">[设备信息]</span>  </span><br><span class="line"><span class="attr">device_id</span>=<span class="number">20210830_1400_00001</span></span><br><span class="line"><span class="attr">device_name</span>=DEV_001</span><br><span class="line"><span class="section">[设备证书]</span>  </span><br><span class="line"><span class="attr">certificate</span>=CONFIG_BRKZH.GITHUB.IO_CONFIG</span><br><span class="line"><span class="section">[设备是否注册]</span>  </span><br><span class="line"><span class="attr">registry_flag</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">CT</span>=<span class="number">65534</span></span><br></pre></td></tr></table></figure><p>把以上的代码都存到 <strong>对应文件</strong> 里面，并且放到 <strong>同一个目录</strong> 下。</p><p>编译指令：<code>gcc -o my_conf config_main.c config.c Func.c -I ./</code></p><p>运行指令：<code>./my_config</code></p><p>运行结果：<br><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoadingAndModify_C/ConfigurationFileLoadingAndModify_C.png" alt="ConfigurationFileLoadingAndModify_C"><br>注意：此份代码仅供学习使用，并没有什么商业价值。<br>因为这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item数组的大小，也是配置文件中有效的item项目的最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGSTRUCTSIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGNAMESIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGCONTENTSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ItemName[CONFIGNAMESIZE];</span><br><span class="line">    <span class="type">char</span> ItemContent[CONFIGCONTENTSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span> <span class="title">ArrayConfig</span>[<span class="title">CONFIGSTRUCTSIZE</span>];</span></span><br></pre></td></tr></table></figure><p>这里设定了配置文件的最大项目数量等，一开始就创建这么多数组，用于保存配置文件，这些开销都是在栈上。没有使用malloc动态分配内存，所以代码<strong>仅供学习。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取网卡地址 -- Linux C</title>
      <link href="/2022/11/01/C_CPlusPlus/GetEthMacIpAddr_LinuxC/"/>
      <url>/2022/11/01/C_CPlusPlus/GetEthMacIpAddr_LinuxC/</url>
      
        <content type="html"><![CDATA[<h1 id="获取指定名字的网卡的Mac地址和IP地址"><a href="#获取指定名字的网卡的Mac地址和IP地址" class="headerlink" title="获取指定名字的网卡的Mac地址和IP地址"></a>获取指定名字的网卡的Mac地址和IP地址</h1><p>文件名：<code>get_mac_ip.c</code><br>运行环境：<code>Linux、Arm</code><br>编译指令：<code>gcc -o get_mac_ip get_mac_ip.c</code><br>运行程序：<code>./get_mac_ip eth0</code> 其中<code>eth0</code>是网卡的名字，不同网卡名字一般是不一样的。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：get_ip_mac.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_mac_addr</span><span class="params">(<span class="type">char</span>* mac, <span class="type">char</span>* ip, <span class="type">char</span> *_net_card)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">tmp</span>;</span></span><br><span class="line"><span class="type">int</span> sock_mac;</span><br><span class="line"><span class="type">char</span> mac_addr[<span class="number">30</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">sin</span>;</span></span><br><span class="line">sock_mac = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sock_mac == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;create socket fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="built_in">strncpy</span>(tmp.ifr_name, _net_card, <span class="keyword">sizeof</span>(tmp.ifr_name)<span class="number">-1</span> );</span><br><span class="line"><span class="keyword">if</span>(ioctl(sock_mac, SIOCGIFHWADDR, &amp;tmp)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mac ioctl error\n&quot;</span>);</span><br><span class="line">close(sock_mac);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(mac_addr, <span class="string">&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</span>,</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">0</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">1</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">2</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">3</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">4</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">memcpy</span>(mac, mac_addr, <span class="built_in">strlen</span>(mac_addr));</span><br><span class="line"><span class="comment">// printf(&quot;local mac:%s\n&quot;, mac_addr);</span></span><br><span class="line"><span class="keyword">if</span>(ioctl(sock_mac, SIOCGIFADDR, &amp;tmp) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(sock_mac);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sin</span> = (<span class="keyword">struct</span> sockaddr_in *)&amp;(tmp.ifr_addr);</span><br><span class="line"><span class="built_in">strcpy</span>(ip, inet_ntoa(<span class="built_in">sin</span>-&gt;sin_addr));</span><br><span class="line">close(sock_mac);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> mac[<span class="number">32</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">32</span>]=<span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sorry. Please input net card name.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Such as: ./get_ip_mac eth0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    get_mac_addr(mac, ip, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mac=%s\nip=%s\n&quot;</span>, mac, ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行截图：<br><img src="https://brkzh.github.io/docPics/GetEthMacIpAddr_LinuxC/GetEthMacIpAddr_LinuxC.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监听键盘输入 C语言</title>
      <link href="/2022/10/01/C_CPlusPlus/MonitorKeyboardInput_C/"/>
      <url>/2022/10/01/C_CPlusPlus/MonitorKeyboardInput_C/</url>
      
        <content type="html"><![CDATA[<h1 id="监听键盘的输入"><a href="#监听键盘的输入" class="headerlink" title="监听键盘的输入"></a>监听键盘的输入</h1><p>程序编译： <code>gcc -o keyboard_listen keyboard_listen.c</code></p><p>程序运行： <code>./keyboard_listen</code></p><p>说明：程序运行，当用户敲击键盘时，程序会打印初敲击的案件。其中<code>q</code>是退出程序。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：keyboard_listen.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc=%d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ti=<span class="number">0</span>; ti &lt; argc; ti++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]=%s\n&quot;</span>, ti, argv[ti]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> keyboard;</span><br><span class="line">    <span class="type">int</span> ret, i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line">    c= <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> tm_ts = <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> tm_us = <span class="number">3333</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tm_ts = (<span class="type">long</span> <span class="type">int</span>)atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tm_ts = (<span class="type">long</span> <span class="type">int</span>)atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        tm_us = (<span class="type">long</span> <span class="type">int</span>)atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    keyboard = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY|O_NONBLOCK);</span><br><span class="line">    assert(keyboard&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> w_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        timeout.tv_sec = tm_ts;</span><br><span class="line">        timeout.tv_usec = tm_us;</span><br><span class="line">        FD_ZERO(&amp;readfd);</span><br><span class="line">        </span><br><span class="line">        FD_SET(keyboard, &amp;readfd);</span><br><span class="line">        <span class="comment">// 监控函数</span></span><br><span class="line">        ret = select(keyboard+<span class="number">1</span>, &amp;readfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret)  <span class="comment">// 返回值大于0，有数据到来</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span>(FD_ISSET(keyboard, &amp;readfd))</span><br><span class="line">            &#123;</span><br><span class="line">                i = read(keyboard, &amp;c, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;\n&#x27;</span> == c)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;char &#x27;q&#x27; is quit. &quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;you input is &lt;[%c]&gt;.\n&quot;</span>, c);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;q&#x27;</span> == c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 超时情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;time out...\t%ld\t%d\t%d\t%d\t%d\t%d\n&quot;</span>, time(<span class="literal">NULL</span>), rand(), rand(), rand(), rand(), rand());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏服务器与客户端</title>
      <link href="/2022/06/22/Adventure_Road/"/>
      <url>/2022/06/22/Adventure_Road/</url>
      
        <content type="html"><![CDATA[<p>卡牌游戏Demo</p><span id="more"></span><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>说明：服务器使用C++语言开发，使用到了epoll高并发通讯技术，线程池处理业务逻辑，MySQL存储用户数据，定时心跳包检测，服务器安全（畸形数据包识别并处理、恶意客户端识别并处理）等等。<br>服务器使用 “主服务器+游戏服务器”的程序架构。<br>主服务器负责一些基本的业务逻辑，如账号注册、账号登录验证1、修改密码、忘记密码功能。<br>游戏服务器负责一些游戏相关的业务，账号登录验证2、游戏逻辑等。</p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/serverRun.png" alt="服务器运行"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/mainServerSpLogicFunc.png" alt="主服务器业务逻辑相关函数"></p><p>后期如果需要扩展业务逻辑，只需要在statusHandler数组里面添加相应的函数，同时约定好对应的消息码，然后实现相应函数即可完成对业务逻辑的扩充。</p><p>游戏服务器的相关业务逻辑就不展示了。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端使用Unity-3D开发引擎，搭配C#语言，开发一个2D战棋游戏。<br>客户端（C#）和服务器（C++）的通讯，是使用自己封装的Dll库来实现的。<br>下面的图片是客户端的部分界面的截图。</p><h3 id="账号登录"><a href="#账号登录" class="headerlink" title="账号登录"></a>账号登录</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/clientLoginPage.png" alt="客户端登录界面"></p><h3 id="账号注册"><a href="#账号注册" class="headerlink" title="账号注册"></a>账号注册</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage1.png" alt="注册界面1"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage2.png" alt="注册界面2"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage3.png" alt="注册界面3"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage4.png" alt="注册界面4"><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emailVerify.jpg" alt="邮箱验证码 (2)"></p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager1.png" alt="密码管理-1"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager_forget.png" alt="密码管理-忘记密码"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager_Modify.png" alt="密码管理-修改密码"></p><h3 id="登录后主界面"><a href="#登录后主界面" class="headerlink" title="登录后主界面"></a>登录后主界面</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/loginedMainPage.png" alt="登录后的主界面"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/clientMain_SettingPage.png" alt="客户端登录界面-设置菜单"></p><h2 id=""><a href="#" class="headerlink" title="."></a>.</h2><p>游戏还不是很完善，游戏的玩法正在开发中。</p><p>敬请期待…</p><h3 id="客户端下载链接"><a href="#客户端下载链接" class="headerlink" title="客户端下载链接"></a>客户端下载链接</h3><p>客户端配置文件<code>Adventure_Road.conf</code>，在程序的根目录</p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/Adventure_Road_conf.png" alt="image-20230918225002524"></p><p>给配置文件配置主服务器的<code>ip</code>地址和端口号。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器IP地址</span></span><br><span class="line"><span class="attr">MasterServerAddr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># 服务器端口</span></span><br><span class="line"><span class="attr">MasterServerPort</span> = <span class="number">35300</span></span><br></pre></td></tr></table></figure><p>百度网盘链接：</p><p>链接：<a href="https://pan.baidu.com/s/1Fl9mRH0gFj3PmATxoGVZDA">https://pan.baidu.com/s/1Fl9mRH0gFj3PmATxoGVZDA</a><br>提取码：mxzl</p><p>115网盘链接：</p><p><a href="https://115.com/s/sw6c6sv36eu?password=mxzl&#">https://115.com/s/sw6c6sv36eu?password=mxzl&amp;#</a><br>Adventure_Road_Client.0906.R.zip<br>访问码:mxzl</p><p>夸克网盘：<br>链接：<a href="https://pan.quark.cn/s/e868fc0d4e38">https://pan.quark.cn/s/e868fc0d4e38</a><br>提取码：XmHH</p><h3 id="服务器下载链接"><a href="#服务器下载链接" class="headerlink" title="服务器下载链接"></a>服务器下载链接</h3><p>服务器，笔者制作了<code>docker</code>镜像，下载后导入镜像，创建容器后就可以使用了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">导入镜像</span><br><span class="line">docker import - mxzl_demo_image &lt; mxzlDemoImage.tar </span><br><span class="line">这样就把，mxzlDemoImage.tar导入了，镜像名字为mxzl_demo_image</span><br><span class="line"></span><br><span class="line">创建容器</span><br><span class="line">docker run --name mxzl_demo_env -itd -p 35300:35300 -p 39300:39300 mxzl_demo_image  /bin/bash</span><br><span class="line">这样就创建了容器mxzl_demo_env</span><br><span class="line"></span><br><span class="line">启动容器</span><br><span class="line">docker start mxzl_demo_env</span><br><span class="line"></span><br><span class="line">进入已启动的容器</span><br><span class="line">docker <span class="built_in">exec</span> -it mxzl_demo_env /bin/bash</span><br><span class="line"></span><br><span class="line">启动脚本，启动数据库、启动游戏服务器</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">./startDemo.sh </span><br><span class="line"></span><br><span class="line">数据库已经有了测试账号，服务器运行起来后可以直接登录使用</span><br><span class="line">账号：brkzh</span><br><span class="line">密码：brkzh</span><br><span class="line"></span><br><span class="line">如果需要注册账号等，需要启用验证码功能，那么就需要改主服务器的配置文件：</span><br><span class="line">vim /home/mxzl/MasterServer.conf</span><br><span class="line">需要更改 [E-Mail]节点的 sendUser、sendPass等配置项</span><br></pre></td></tr></table></figure><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/vim_config.png" alt="image-20230918222156628"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emainConfig.png" alt="image-20230918222222613"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emainConfig2.png" alt="image-20230918222233795"></p><p>百度网盘链接：</p><p>链接：<a href="https://pan.baidu.com/s/1wLpDleYBLlprs58rPv-ZFA">https://pan.baidu.com/s/1wLpDleYBLlprs58rPv-ZFA</a><br>提取码：mxzl</p><p>夸克网盘：<br>链接：<a href="https://pan.quark.cn/s/a914ea04c026">https://pan.quark.cn/s/a914ea04c026</a><br>提取码：7GNC</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PC版微信客户端多开</title>
      <link href="/2022/02/02/Notes/OpenWeChatClientMulti/"/>
      <url>/2022/02/02/Notes/OpenWeChatClientMulti/</url>
      
        <content type="html"><![CDATA[<p><a href="#Win%E7%B3%BB%E7%BB%9F%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%9A%E5%BC%80">Win电脑微信客户端多开</a></p><p><a href="#MacOS%E7%B3%BB%E7%BB%9F%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%9A%E5%BC%80">MacOS系统微信客户端多开</a></p><span id="more"></span><h1 id="Win系统微信客户端多开"><a href="#Win系统微信客户端多开" class="headerlink" title="Win系统微信客户端多开"></a>Win系统微信客户端多开</h1><p>有多个微信号想同时在电脑上登陆怎么办？</p><p>别着急，下边有个脚本能帮助你多开微信。</p><p>把下面代码复制到文本文档，并把格式改为<code>bat</code>，并修改微信的安装位置为你电脑中微信的安装位置即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:again</span><br><span class="line">set /p num=请输入要启动几个微信客户端（1~3）【输入0退出】：</span><br><span class="line">if &quot;%num%&quot; EQU &quot;0&quot; (</span><br><span class="line">    echo 程序退出</span><br><span class="line">    pause</span><br><span class="line">    exit</span><br><span class="line">)</span><br><span class="line">if &quot;%num%&quot; NEQ &quot;1&quot; (</span><br><span class="line">    if &quot;%num%&quot; NEQ &quot;2&quot; (</span><br><span class="line">        if &quot;%num%&quot; NEQ &quot;3&quot; (</span><br><span class="line">            echo 输入有问题</span><br><span class="line">            set /a num = 1</span><br><span class="line">            echo 默认为您启动一个客户端</span><br><span class="line">            pause</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if &quot;%num%&quot; EQU &quot;1&quot; (</span><br><span class="line">    echo 正在为您启动%num%个客户端</span><br><span class="line">    goto startWechatClient1</span><br><span class="line">    pause</span><br><span class="line">    exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if &quot;%num%&quot; EQU &quot;2&quot; (</span><br><span class="line">    echo 正在为您启动%num%个客户端</span><br><span class="line">    goto startWechatClient2</span><br><span class="line">    pause</span><br><span class="line">    exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if &quot;%num%&quot; EQU &quot;3&quot; (</span><br><span class="line">    echo 正在为您启动%num%个客户端</span><br><span class="line">    goto startWechatClient3</span><br><span class="line">    pause</span><br><span class="line">    exit</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:startWechatClient1</span><br><span class="line">TASKKILL /F /IM wechat.exe</span><br><span class="line">start &quot;&quot; &quot;E:\software\Tencent\WeChat\WeChat.exe&quot;</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">:startWechatClient2</span><br><span class="line">TASKKILL /F /IM wechat.exe</span><br><span class="line">start &quot;&quot; &quot;E:\software\Tencent\WeChat\WeChat.exe&quot;</span><br><span class="line">start &quot;&quot; &quot;E:\software\Tencent\WeChat\WeChat.exe&quot;</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">:startWechatClient3</span><br><span class="line">TASKKILL /F /IM wechat.exe</span><br><span class="line">start &quot;&quot; &quot;E:\software\Tencent\WeChat\WeChat.exe&quot;</span><br><span class="line">start &quot;&quot; &quot;E:\software\Tencent\WeChat\WeChat.exe&quot;</span><br><span class="line">start &quot;&quot; &quot;E:\software\Tencent\WeChat\WeChat.exe&quot;</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>说明：<code>E:\software\Tencent\WeChat\WeChat.exe </code>是微信的安装位置，不同电脑安装位置可能不一样。</p><h1 id="MacOS系统微信客户端多开"><a href="#MacOS系统微信客户端多开" class="headerlink" title="MacOS系统微信客户端多开"></a>MacOS系统微信客户端多开</h1><p><code>MacOS</code>系统微信客户端多开</p><p>现在很多人都有两个甚至两个以上的微信账号</p><p>由于某些不可抗拒的原因，不得不同时在电脑上登陆多个账号</p><p>因此就有了这片文章，教你如何在<code>MacOS</code>系统下启动多个微信客户端</p><h3 id="MacOS微信默认安装位置是在"><a href="#MacOS微信默认安装位置是在" class="headerlink" title="MacOS微信默认安装位置是在"></a>MacOS微信默认安装位置是在</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/WeChat.app/Contents/MacOS/WeChat</span><br></pre></td></tr></table></figure><h3 id="来看看脚本"><a href="#来看看脚本" class="headerlink" title="来看看脚本"></a>来看看脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入要启动的微信客户端的个数:&quot; val </span><br><span class="line">echo $val</span><br><span class="line">case &quot;$val&quot; in </span><br><span class="line">[1-9]*)</span><br><span class="line">echo &quot;$val 是一个有效数字，将启动 $val 个微信客户端。&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;$val 不是一个有效数字。默认将启动1个微信客户端。&quot;</span><br><span class="line">val=1</span><br><span class="line">esac </span><br><span class="line">if [ $val -gt 5 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;$val 值太大了。不建议启动这么多个微信客户端，默认修改为启动5个微信客户端。&quot;</span><br><span class="line">echo &quot;如果执意要启动这么多，直接修改文件中的代码val=【你想要启动的最多的个数】。&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里修改了val的值，超过5个就修改为5，因为不建议启动这么多个客户端</span></span><br><span class="line">val=5</span><br><span class="line">fi</span><br><span class="line">for k in $( seq 1 $val )</span><br><span class="line">do</span><br><span class="line">echo &quot;正在启动微信客户端:$k&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里是微信的程序路径，一般都在这里，除非安装微信时，自定义了路径</span></span><br><span class="line">(/Applications/WeChat.app/Contents/MacOS/WeChat &amp;)</span><br><span class="line">done</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;查看启动的微信的进程信息&quot;</span><br><span class="line">ps -ef | grep WeChat</span><br><span class="line">echo &quot;+++++++++++++++++++++++++++++++++++++++&quot;</span><br><span class="line">echo &quot;     这个终端可以关闭了，谢谢使用&quot;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>上面的代码是一个sh脚本，直接复制粘贴到一个<code>txt</code>文本文档，然后把文件后缀名改为<code>.sh</code>即可</p><p>接着，打开终端<code>Terminal</code></p><p>同时按 <code>command</code>+<code>空格键</code> 然后紧接着键盘输入<code>terminal</code> 如下图，然后回车，打开终端</p><p><img src="https://brkzh.github.io/docPics/Notes/OpenWeChatClientMulti/OpenWeChatClientMulti_MacOS1.png" alt="OpenWeChatClientMulti_MacOS1"></p><p>接着，给刚刚创建的脚本增加可执行权限</p><p>在打开的终端，输入 <code>chmod a+x 上面保存的.sh文件路径</code></p><p>例如，上面的.sh文件保存在 桌面，并且.sh文件名为<code>run_wechat.sh</code></p><p>则可以在终端中输入下面的命令</p><p><code>chmod a+x ~/Desktop/run_wechat.sh</code><br>这样就给.sh文件授权了，然后运行.sh文件</p><p><code>~/Desktop/./run_wechat.sh</code> 回车，然后输入要启动的个数就OK了<br>结果如下图所示</p><p><img src="https://brkzh.github.io/docPics/Notes/OpenWeChatClientMulti/OpenWeChatClientMulti_MacOS2.png" alt="截屏2020-08-26 下午11.23.16"></p><h2 id="到这里就完成了"><a href="#到这里就完成了" class="headerlink" title="到这里就完成了"></a>到这里就完成了</h2><p>还有一种方法，直接创建<code>.command</code>文件，双击运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;请输入要启动的微信客户端的个数:&quot; val </span><br><span class="line">echo $val</span><br><span class="line">case &quot;$val&quot; in </span><br><span class="line">[1-9]*)</span><br><span class="line">echo &quot;$val 是一个有效数字，将启动 $val 个微信客户端。&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;$val 不是一个有效数字。默认将启动1个微信客户端。&quot;</span><br><span class="line">val=1</span><br><span class="line">esac </span><br><span class="line">if [ $val -gt 5 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;$val 值太大了。不建议启动这么多个微信客户端，默认修改为启动5个微信客户端。&quot;</span><br><span class="line">echo &quot;如果执意要启动这么多，直接修改文件中的代码val=【你想要启动的最多的个数】。&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里修改了val的值，超过5个就修改为5，因为不建议启动这么多个客户端</span></span><br><span class="line">val=5</span><br><span class="line">fi</span><br><span class="line">for k in $( seq 1 $val )</span><br><span class="line">do</span><br><span class="line">echo &quot;正在启动微信客户端:$k&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里是微信的程序路径，一般都在这里，除非安装微信时，自定义了路径</span></span><br><span class="line">(/Applications/WeChat.app/Contents/MacOS/WeChat &amp;)</span><br><span class="line">done</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;查看启动的微信的进程信息&quot;</span><br><span class="line">ps -ef | grep WeChat</span><br><span class="line">echo &quot;+++++++++++++++++++++++++++++++++++++++&quot;</span><br><span class="line">echo &quot;     这个终端可以关闭了，谢谢使用&quot;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>把上面的文件保存早一个文本文档，然后把后缀名改为<code>command</code></p><p>然后给这个文件授权，按照前面的方式，然后双击运行了，如果弹出说不信任，无法运行等，转到<code>macos</code>的<code>设置</code>，</p><p><code>安全性与隐私</code> – <code>通用</code> 看到有 允许从一下位置下载的App 那里有 <code>仍然打开</code> 点击它</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统鼠标右键菜单添加打开cmd终端</title>
      <link href="/2022/02/01/Notes/AddTerminalToMenuOfMouse/"/>
      <url>/2022/02/01/Notes/AddTerminalToMenuOfMouse/</url>
      
        <content type="html"><![CDATA[<h1 id="Win10系统鼠标右键菜单添加打开cmd终端"><a href="#Win10系统鼠标右键菜单添加打开cmd终端" class="headerlink" title="Win10系统鼠标右键菜单添加打开cmd终端"></a>Win10系统鼠标右键菜单添加打开cmd终端</h1><p>有时候，当要在某个文件夹下打开<code>cmd</code>终端时，如果没有右键菜单快捷方式，就得打开<code>cmd</code>后，使用<code>cd</code>方式进入 当前目录，很麻烦。<br>以下的脚本，可以帮你解决这个问题。</p><p><strong>PS：</strong><code>Win11</code>也适用，但是<code>Win11</code>系统本身自带。</p><span id="more"></span><p>文件名：<code>右键在此处运行cmd.reg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here]  </span><br><span class="line">  </span><br><span class="line">@=&quot;open cmd here&quot;  </span><br><span class="line">&quot;Icon&quot;=&quot;cmd.exe&quot;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\cmd_here\command]  </span><br><span class="line">  </span><br><span class="line">@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot;&quot;  </span><br><span class="line"> &quot;Icon&quot;=&quot;cmd.exe&quot;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\cmdPrompt]  </span><br><span class="line">  </span><br><span class="line">@=&quot;open cmd here&quot;  </span><br><span class="line">&quot;Icon&quot;=&quot;cmd.exe&quot;   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\cmdPrompt\command]  </span><br><span class="line">  </span><br><span class="line">@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot; \&quot;cd %1\&quot;&quot;  </span><br><span class="line">&quot;Icon&quot;=&quot;cmd.exe&quot;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here]  </span><br><span class="line">  </span><br><span class="line">@=&quot;open cmd here&quot;  </span><br><span class="line">&quot;Icon&quot;=&quot;cmd.exe&quot;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\cmd_here\command]  </span><br><span class="line">  </span><br><span class="line">@=&quot;\&quot;C:\\Windows\\System32\\cmd.exe\&quot;&quot;  </span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\runas]</span><br><span class="line">&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\runas\command]</span><br><span class="line">@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;</span><br></pre></td></tr></table></figure><p>直接拷贝上面的一段代码，保存到<code>文本文档</code>，然后把<code>.txt</code>后缀改为<code>.reg</code>，然后右键该文件，点击<code>合并</code>即可。这样，鼠标右键菜单就有<code>open cmd here</code>即在当前路径打开<code>cmd</code>这个选项了，但是这个是普通用户运行cmd。</p><p>同时还会添加另一个选项，<code>以管理员身份运行(A)</code> ，这个是以管理员身份运行cmd。<br><img src="https://brkzh.github.io/docPics/Notes/AddTerminalToMenuOfMouse/AddTerminalToMenuOfMouse.png" alt="AddTerminalToMenuOfMouse"></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
