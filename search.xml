<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>配置文件加载 -- C++</title>
      <link href="/2024/01/01/C_CPlusPlus/ConfigurationFileLoading_Demo/"/>
      <url>/2024/01/01/C_CPlusPlus/ConfigurationFileLoading_Demo/</url>
      
        <content type="html"><![CDATA[<h1 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h1><p>单例类实现配置文件的加载。<code>Linux</code>下环境能直接运行，如果要在<code>Win</code>平台运行，部分地方需要做点小调整。</p><span id="more"></span><h1 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是注释行，</span></span><br><span class="line"><span class="comment">#每个有效配置项用 等号 处理，等号前不超过40个字符，等号后不超过400个字符；</span></span><br><span class="line"><span class="comment">#I love Cina，中华民族是世界上最伟大的民族！加油啊，兄弟们。</span></span><br><span class="line"><span class="comment">#感谢。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[开头的表示组信息，也等价于注释行</span></span><br><span class="line"><span class="comment">#[Socket]</span></span><br><span class="line"><span class="comment">#ListenPort = 5678    </span></span><br><span class="line"><span class="comment">#DBInfo = 127.0.0.1;1234;myr;123456;mxdb_g</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Server]</span></span><br><span class="line"><span class="comment">#ServerID代表本服务器ID，以标识自己</span></span><br><span class="line"><span class="attr">ServerName</span>=</span><br><span class="line">Name=</span><br><span class="line"></span><br><span class="line"><span class="comment">#日志相关</span></span><br><span class="line"><span class="section">[Log]</span></span><br><span class="line"><span class="comment">#日志文件输出目录和文件名</span></span><br><span class="line"><span class="comment">#Log=logs/error.log</span></span><br><span class="line"><span class="attr">Log</span>=error.log</span><br><span class="line"><span class="comment">#开开心心学习，顺其自然。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#只打印日志等级&lt;= 数字 的日志到日志文件中 ，日志等级0-8,0级</span></span><br><span class="line"><span class="attr">Csdn</span>=Chinese_Style</span><br><span class="line"></span><br><span class="line"><span class="comment">#进程相关</span></span><br><span class="line"><span class="section">[Proc]</span></span><br><span class="line"><span class="comment">#处理接收到的消息的线程池中线程数量，不建议超过300</span></span><br><span class="line"><span class="attr">ProcMsgRecvWorkThreadCount</span> = <span class="number">185</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#和网络相关</span></span><br><span class="line"><span class="section">[Net]</span></span><br><span class="line"><span class="comment">#监听的端口数量，一般都是1个，当然如果支持多于一个也是可以的</span></span><br><span class="line"><span class="attr">ListenPortCount</span> =<span class="number">185</span></span><br><span class="line"><span class="comment">#ListenPort+数字【数字从0开始】，这种ListenPort开头的项有几个，取决于ListenPortCount的数量，</span></span><br><span class="line"><span class="comment">#ListenPort 0==80</span></span><br><span class="line"><span class="attr">ListenPort1</span> == <span class="number">443</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#epoll连接的最大数【是每个worker进程允许连接的客户端数00000001】，实际其中有一些连接要被监听socket使用，实际允许的客户端连接数会比这个数小一些</span></span><br><span class="line"><span class="attr">worker_connections</span> = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Sock_RecyConnectionWaitTime:为确保系统稳定socket关闭后资源不会立即收回，而要等一定的秒数，在这个秒数之后，才进行资源/连接的回收</span></span><br><span class="line"><span class="attr">Sock_RecyConnectionWaitTime</span> = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Sock_WaitTimeEnable：是否开启踢人时钟，1：开启   0：不开启</span></span><br><span class="line"><span class="attr">Sock_WaitTimeEnable</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#多少秒检测一次是否 心跳超时，只有当Sock_WaitTimeEnable = 1时，本项才有用</span></span><br><span class="line"><span class="attr">Sock_MaxWaitTime</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">#当时间到达Sock_MaxWaitTime指定的时间时，直接把客户端踢出去，只有当Sock_WaitTimeEnable = 1时，本项才有用</span></span><br><span class="line"><span class="comment">#因为gameserver也要连接到本服务器，所以不能轻易踢人哦。</span></span><br><span class="line"><span class="attr">Sock_TimeOutKick</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[GameServerInfo]</span></span><br><span class="line"><span class="comment">#所有要连入到本服务器的GameServer信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一共允许这些个GameServer连入</span></span><br><span class="line"><span class="attr">AllowConnInGameServerCount</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#格式为：GameServer的唯一编号;对应的ip地址，域名（之所以引进域名是因为ipv6的getaddrinfo解析ipv4地址时不管是不是ipv6网络都返回ipv4网络）</span></span><br><span class="line"><span class="comment">#AllowConnInGameServer1=1000;192.168.1.126;192.168.1.126</span></span><br><span class="line"><span class="attr">AllowConnInGameServer1</span>=<span class="number">1000</span><span class="comment">;127.0.0.1;127.0.0.1</span></span><br><span class="line"><span class="comment">#AllowConnInGameServer3=1200;192.168.5.6;192.168.5.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#和网络安全相关</span></span><br><span class="line"><span class="section">[NetSecurity]</span></span><br><span class="line"><span class="comment">#flood检测</span></span><br><span class="line"><span class="comment">#Flood攻击检测是否开启,1：开启   0：不开启</span></span><br><span class="line"><span class="attr">Sock_FloodAttackKickEnable</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#Sock_FloodTimeInterval表示每次收到数据包的时间间隔是100(单位：毫秒)</span></span><br><span class="line"><span class="attr">Sock_FloodTimeInterval</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">#Sock_FloodKickCounter表示计算到连续10次，每次100毫秒时间间隔内发包，就算恶意入侵，把他kick出去</span></span><br><span class="line"><span class="attr">Sock_FloodKickCounter</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#和数据库相关</span></span><br><span class="line"><span class="section">[Database]</span></span><br><span class="line"><span class="comment"># 数据库连接信息,格式为:&quot;IP;端口;帐号;密码;数据库名&quot;</span></span><br><span class="line"><span class="comment">#DatabaseLoginInfo = 192.168.1.126;3306;root;123456;mxzl_masterv3</span></span><br><span class="line"><span class="attr">DatabaseLoginInfo</span> = <span class="number">127.0</span>.<span class="number">0.1</span><span class="comment">;3306;brkzh;brkzh;brkzh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DatabasePoolSize:数据库连接池大小,大点还是应该,有些复杂查询是要消耗近1秒的时间</span></span><br><span class="line"><span class="comment"># 另外本服务器数据库确实连的人不多，所以多几个连接没问题；</span></span><br><span class="line"><span class="attr">DatabasePoolSize</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure><h1 id="CMakeLists文件"><a href="#CMakeLists文件" class="headerlink" title="CMakeLists文件"></a>CMakeLists文件</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmake --version 查看 cmake版本</span></span><br><span class="line"><span class="comment"># 指定CMake的最小版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工程名称</span></span><br><span class="line"><span class="keyword">project</span>(configSingleDemo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前编译选项后追加新编译选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -g -O2 -Wall -lmysqlclient -std=c++11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件搜索路径，类似g++里的-i参数</span></span><br><span class="line"><span class="keyword">include_directories</span>(./)</span><br><span class="line"><span class="comment">#include_directories(/usr/include/mysql/plugin)</span></span><br><span class="line"><span class="comment">#include_directories(/usr/include/mysql)</span></span><br><span class="line"><span class="comment">#link_libraries(&quot;libmysqlclient.so&quot;)</span></span><br><span class="line"><span class="comment">#link_directories(&quot;usr/lib/x86_64-linux-gnu&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set(MYSQL_LIBS</span></span><br><span class="line"><span class="comment">#     mysqlclient pthread z m rt atomic ssl crypto dl</span></span><br><span class="line"><span class="comment"># )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH ../)</span><br><span class="line"><span class="comment"># 生成可执行文件（这里可执行文件名叫做main_cmake），其他的是工程里包含的文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(main_cmake main.cpp config.cpp string_my.cpp)</span><br><span class="line"><span class="comment">#target_link_libraries(main_cmake $&#123;MYSQL_LIBS&#125;)</span></span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>公共函数头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:func.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __FUNC_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FUNC_H__</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rtrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ltrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>公共函数源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名: string_my.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rtrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str_in == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(str_in);</span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span> &amp;&amp; str_in[len<span class="number">-1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str_in[--len] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Ltrim</span><span class="params">(<span class="type">char</span> *str_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str_in == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">char</span> *p_curr = str_in;</span><br><span class="line">    <span class="keyword">if</span>(*p_curr != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>((*p_curr) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*p_curr) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            ++p_curr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*p_curr) == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *str_in = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *p_new = str_in;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">         *p_new = *p_curr;</span><br><span class="line">         ++p_new;</span><br><span class="line">         ++p_curr;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((*p_curr) != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    *p_new = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例类头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:config.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CONFIG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CONFIG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CConfItem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ItemName[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> ItemContent[<span class="number">500</span>];</span><br><span class="line">&#125;CConfItem, *LPCConfItem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CConfig</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CConfig</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">CConfig</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CConfig* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CGarhuishou</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">CGarhuishou</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(CConfig::m_instance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> CConfig::m_instance;</span><br><span class="line">                CConfig::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pconfName)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p_itemname)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> CConfig* m_instance;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt; m_ConfigItemList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>单例配置类源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:config.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成语变量定义</span></span><br><span class="line">CConfig* CConfig::m_instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> m_mutex;   <span class="comment">// 定义一个互斥量</span></span><br><span class="line"></span><br><span class="line">CConfig::<span class="built_in">CConfig</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CConfig::~<span class="built_in">CConfig</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt;::iterator pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = m_ConfigItemList.<span class="built_in">begin</span>(); pos != m_ConfigItemList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">delete</span>(*pos);</span><br><span class="line">    &#125;</span><br><span class="line">    m_ConfigItemList.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CConfig* <span class="title">CConfig::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CConfig::m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">if</span>(CConfig::m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">CConfig</span>();</span><br><span class="line">            <span class="type">static</span> CGarhuishou cl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CConfig::Load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p_confName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = <span class="built_in">fopen</span>(p_confName, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> lineBuf[<span class="number">501</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fgets</span>(lineBuf, <span class="built_in">sizeof</span>(lineBuf) - <span class="number">1</span>, fp) == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(lineBuf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(*lineBuf == <span class="string">&#x27;*&#x27;</span> || *lineBuf == <span class="string">&#x27;#&#x27;</span> || *lineBuf == <span class="string">&#x27;;&#x27;</span> || *lineBuf==<span class="string">&#x27;\n&#x27;</span> || *lineBuf==<span class="string">&#x27;\r&#x27;</span> || *lineBuf==<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">    lblprocstring:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(lineBuf) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lineBuf[<span class="built_in">strlen</span>(lineBuf) - <span class="number">1</span>] == <span class="number">10</span> || </span><br><span class="line">                lineBuf[<span class="built_in">strlen</span>(lineBuf) - <span class="number">1</span>] == <span class="number">13</span> || </span><br><span class="line">                lineBuf[<span class="built_in">strlen</span>(lineBuf) - <span class="number">1</span>] == <span class="number">32</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    lineBuf[<span class="built_in">strlen</span>(lineBuf)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> lblprocstring;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lineBuf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(*lineBuf == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> *ptmp = <span class="built_in">strchr</span>(lineBuf, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptmp != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LPCConfItem p_confitem = <span class="keyword">new</span> CConfItem;</span><br><span class="line">            <span class="built_in">memset</span>(p_confitem, <span class="number">0</span>, <span class="built_in">sizeof</span>(CConfItem));</span><br><span class="line">            <span class="built_in">strncpy</span>(p_confitem-&gt;ItemName, lineBuf, (<span class="type">int</span>)(ptmp - lineBuf));</span><br><span class="line">            <span class="built_in">strcpy</span>(p_confitem-&gt;ItemContent, ptmp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Rtrim</span>(p_confitem-&gt;ItemName);</span><br><span class="line">            <span class="built_in">Rtrim</span>(p_confitem-&gt;ItemContent);</span><br><span class="line">            <span class="built_in">Ltrim</span>(p_confitem-&gt;ItemName);</span><br><span class="line">            <span class="built_in">Ltrim</span>(p_confitem-&gt;ItemContent);</span><br><span class="line"></span><br><span class="line">            m_ConfigItemList.<span class="built_in">push_back</span>(p_confitem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">CConfig::GetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *p_itemname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt;::iterator pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = m_ConfigItemList.<span class="built_in">begin</span>(); pos != m_ConfigItemList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>((*pos)-&gt;ItemName, p_itemname) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>(*pos)-&gt;ItemContent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CConfig::GetIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;LPCConfItem&gt;::iterator pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = m_ConfigItemList.<span class="built_in">begin</span>(); pos != m_ConfigItemList.<span class="built_in">end</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcasecmp</span>((*pos)-&gt;ItemName, p_itemname) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">atoi</span>((*pos)-&gt;ItemContent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> def;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PATH <span class="string">&quot;/home/brkzh/demo/1.ConfigLoad/MsSrv_V2.conf&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CConfig* p_config = CConfig::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">if</span>(p_config-&gt;<span class="built_in">Load</span>(CONFIG_PATH) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;配置文件[&quot;</span>&lt;&lt;CONFIG_PATH&lt;&lt;<span class="string">&quot;]载入失败，退出!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *data_info = <span class="literal">nullptr</span>;</span><br><span class="line">    data_info = (<span class="type">char</span>*)p_config-&gt;<span class="built_in">GetString</span>(<span class="string">&quot;DatabaseLoginInfo&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(data_info)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;DatabaseLoginInfo=&quot;</span>&lt;&lt;data_info&lt;&lt;std::endl;</span><br><span class="line">        <span class="type">char</span> db_ip[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> db_user[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> db_passwd[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span> db_database[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> db_port = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *cur_tmp;</span><br><span class="line">        <span class="type">int</span> reg_ind = <span class="number">0</span>;</span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(db_ip, data_info, (<span class="type">int</span>)(cur_tmp - data_info));</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(db_ip) <span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info+reg_ind, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="type">char</span> tmp_port[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strncpy</span>(tmp_port, data_info+reg_ind, (<span class="type">int</span>)(cur_tmp - (data_info+reg_ind)));</span><br><span class="line">        db_port = <span class="built_in">atoi</span>(tmp_port);</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(tmp_port) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info+reg_ind, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(db_user, data_info+reg_ind, (<span class="type">int</span>)(cur_tmp - (data_info+reg_ind)));</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(db_user) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        cur_tmp = <span class="built_in">strchr</span>(data_info+reg_ind, <span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(db_passwd, data_info+reg_ind, (<span class="type">int</span>)(cur_tmp - (data_info+reg_ind)));</span><br><span class="line">        reg_ind += <span class="built_in">strlen</span>(db_passwd) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(db_database, data_info+reg_ind);</span><br><span class="line">        </span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_ip=&quot;</span>&lt;&lt;db_ip&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_port=&quot;</span>&lt;&lt;db_port&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_user=&quot;</span>&lt;&lt;db_user&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_passwd=&quot;</span>&lt;&lt;db_passwd&lt;&lt;std::endl;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;db_database=&quot;</span>&lt;&lt;db_database&lt;&lt;std::endl;     </span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;DatabasePoolSize=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;DatabasePoolSize&quot;</span>, <span class="number">1</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Csdn=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetString</span>(<span class="string">&quot;Csdn&quot;</span>)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;worker_connections=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;worker_connections&quot;</span>, <span class="number">1</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Log=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetString</span>(<span class="string">&quot;Log&quot;</span>)&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;DatabasePoolSize=&quot;</span>&lt;&lt;p_config-&gt;<span class="built_in">GetIntDefault</span>(<span class="string">&quot;DatabasePoolSize&quot;</span>, <span class="number">1</span>)&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先进入当前代码所在的目录</span></span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br><span class="line">cd ..</span><br><span class="line">./main_cmake</span><br></pre></td></tr></table></figure><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoading_Demo/ConfigurationFileLoading_Demo_1.png" alt="ConfigurationFileLoading_Demo_1"></p><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoading_Demo/ConfigurationFileLoading_Demo_2.png" alt="ConfigurationFileLoading_Demo_2"></p><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoading_Demo/ConfigurationFileLoading_Demo_3.png" alt="ConfigurationFileLoading_Demo_3"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux C++ 发送验证码邮件</title>
      <link href="/2024/01/01/C_CPlusPlus/SendEMail_LinuxCPlusPlus/"/>
      <url>/2024/01/01/C_CPlusPlus/SendEMail_LinuxCPlusPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-C-发送验证码邮件"><a href="#Linux-C-发送验证码邮件" class="headerlink" title="Linux C++ 发送验证码邮件"></a>Linux C++ 发送验证码邮件</h1><p><code>Linux</code>下环境能直接运行。</p><span id="more"></span><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:my_smtp.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY_SMTP_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_SMTP_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SMTP_MAXLEN = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C_MY_SMTP</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C_MY_SMTP</span>(<span class="type">void</span>);</span><br><span class="line">    <span class="built_in">C_MY_SMTP</span>(</span><br><span class="line">        <span class="type">int</span> port,</span><br><span class="line">        std::string srvDomain,              <span class="comment">// smtp服务器域名  smtp@163.com 等</span></span><br><span class="line">        std::string userName,               <span class="comment">// 用户名 邮箱账号</span></span><br><span class="line">        std::string passWord,               <span class="comment">// 密码 邮箱 SMTP授权码</span></span><br><span class="line">        std::string targetEmail,            <span class="comment">// 目标邮箱 账号</span></span><br><span class="line">        std::string emailTitle,             <span class="comment">// 邮件主题</span></span><br><span class="line">        std::string content                <span class="comment">// 邮件内容</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">C_MY_SMTP</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_port;                               <span class="comment">// 端口号，一般是25</span></span><br><span class="line">    std::string m_domain;</span><br><span class="line">    std::string m_user;</span><br><span class="line">    std::string m_pass;</span><br><span class="line">    std::string m_targetUser;</span><br><span class="line">    std::string m_title;</span><br><span class="line">    std::string m_content;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_buff[SMTP_MAXLEN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> m_buffLen;</span><br><span class="line">    <span class="type">int</span> m_sockClient;                        <span class="comment">// 客户端套接字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">CreateConn</span><span class="params">()</span></span>;                      <span class="comment">// 创建连接</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Send</span><span class="params">(std::string &amp;message)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Recv</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FormatEmailHead</span><span class="params">(std::string &amp;email)</span></span>;               <span class="comment">// 格式化要发送的邮件头部</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Login</span><span class="params">()</span></span>;                                            <span class="comment">// 登录邮箱账号</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SendEmailHead</span><span class="params">()</span></span>;                                   <span class="comment">// 发送邮件头部信息</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SendTextBody</span><span class="params">()</span></span>;                                    <span class="comment">// 发送邮件正文（文本信息）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SendEnd</span><span class="params">()</span></span>;                                         <span class="comment">// 发送邮件尾部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetSrvDomain</span><span class="params">(std::string domain)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_domain = domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetSrvDomain</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_domain; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetUserName</span><span class="params">(std::string user)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetUserName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_user; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPass</span><span class="params">(std::string pass)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pass = pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetPass</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_pass; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTargetEmail</span><span class="params">(std::string targetAddr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_targetUser = targetAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetTargetEmail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_targetUser; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetEmailTitle</span><span class="params">(std::string title)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetEmailTitle</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_title; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetContent</span><span class="params">(std::string content)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetContent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_content; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPort</span><span class="params">(<span class="type">int</span> port)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPort</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_port; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">SendEmail_Ex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关于错误码的说明：1.网络错误导致的错误，2.用户名错误，3.密码错误 0.成功</span></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">base64Encode</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* origSigned, <span class="type">unsigned</span> origLength)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MY_SMTP_H__</span></span></span><br></pre></td></tr></table></figure><p><strong>源文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名:my_smtp.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_smtp.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> SMTP_base64Char[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">C_MY_SMTP::base64Encode</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* origSigned, <span class="type">unsigned</span> origLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span>* orig = (<span class="type">unsigned</span> <span class="type">char</span> <span class="type">const</span>*)origSigned; <span class="comment">// in case any input bytes have the MSB set</span></span><br><span class="line"><span class="keyword">if</span> (orig == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">const</span> numOrig24BitValues = origLength / <span class="number">3</span>;</span><br><span class="line"><span class="type">bool</span> havePadding = origLength &gt; numOrig24BitValues * <span class="number">3</span>;</span><br><span class="line"><span class="type">bool</span> havePadding2 = origLength == numOrig24BitValues * <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">const</span> numResultBytes = <span class="number">4</span> * (numOrig24BitValues + havePadding);</span><br><span class="line"><span class="type">char</span>* result = <span class="keyword">new</span> <span class="type">char</span>[numResultBytes + <span class="number">3</span>]; <span class="comment">// allow for trailing &#x27;/0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map each full group of 3 input bytes into 4 output base-64 characters:</span></span><br><span class="line"><span class="type">unsigned</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numOrig24BitValues; ++i)</span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">0</span>] = SMTP_base64Char[(orig[<span class="number">3</span> * i] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">1</span>] = SMTP_base64Char[(((orig[<span class="number">3</span> * i] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (orig[<span class="number">3</span> * i + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">2</span>] = SMTP_base64Char[((orig[<span class="number">3</span> * i + <span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (orig[<span class="number">3</span> * i + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">3</span>] = SMTP_base64Char[orig[<span class="number">3</span> * i + <span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, take padding into account.  (Note: i == numOrig24BitValues)</span></span><br><span class="line"><span class="keyword">if</span> (havePadding)</span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">0</span>] = SMTP_base64Char[(orig[<span class="number">3</span> * i] &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line"><span class="keyword">if</span> (havePadding2)</span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">1</span>] = SMTP_base64Char[(((orig[<span class="number">3</span> * i] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) | (orig[<span class="number">3</span> * i + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">2</span>] = SMTP_base64Char[(orig[<span class="number">3</span> * i + <span class="number">1</span>] &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">1</span>] = SMTP_base64Char[((orig[<span class="number">3</span> * i] &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">4</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">2</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">result[<span class="number">4</span> * i + <span class="number">3</span>] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result[numResultBytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line">C_MY_SMTP::<span class="built_in">C_MY_SMTP</span>(<span class="type">void</span>):<span class="built_in">m_port</span>(<span class="number">25</span>),<span class="built_in">m_domain</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_user</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_pass</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_targetUser</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_title</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">m_content</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    m_sockClient = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">C_MY_SMTP::~<span class="built_in">C_MY_SMTP</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_sockClient != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_sockClient);</span><br><span class="line">        m_sockClient = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的构造函数</span></span><br><span class="line">C_MY_SMTP::<span class="built_in">C_MY_SMTP</span>(</span><br><span class="line">        <span class="type">int</span> port,</span><br><span class="line">        std::string srvDomain,              <span class="comment">// smtp服务器域名  smtp@163.com 等</span></span><br><span class="line">        std::string userName,               <span class="comment">// 用户名 邮箱账号</span></span><br><span class="line">        std::string passWord,               <span class="comment">// 密码 邮箱 SMTP授权码</span></span><br><span class="line">        std::string targetEmail,            <span class="comment">// 目标邮箱 账号</span></span><br><span class="line">        std::string emailTitle,             <span class="comment">// 邮件主题</span></span><br><span class="line">        std::string content                <span class="comment">// 邮件内容</span></span><br><span class="line">    ): <span class="built_in">m_port</span>(port), <span class="built_in">m_domain</span>(srvDomain), <span class="built_in">m_user</span>(userName), <span class="built_in">m_pass</span>(passWord), <span class="built_in">m_targetUser</span>(targetEmail), <span class="built_in">m_title</span>(emailTitle), <span class="built_in">m_content</span>(content)</span><br><span class="line">&#123;</span><br><span class="line">    m_sockClient = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建创建socket并连接</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::CreateConn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    m_sockClient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_sockClient &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addrSrv;</span><br><span class="line">    hostent * pHostent = <span class="built_in">gethostbyname</span>(m_domain.<span class="built_in">c_str</span>());               <span class="comment">// 得到有关的域名的信息</span></span><br><span class="line">    <span class="keyword">if</span>(pHostent == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addrSrv.sin_addr.s_addr = *((<span class="type">uint32_t</span>*)pHostent-&gt;h_addr);</span><br><span class="line">    addrSrv.sin_family = AF_INET;</span><br><span class="line">    addrSrv.sin_port = <span class="built_in">htons</span>(m_port);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(m_sockClient, (<span class="keyword">struct</span> sockaddr*)&amp;addrSrv, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::Send</span><span class="params">(std::string&amp; message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> need_send = message.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">char</span>* tmp_send = (<span class="type">char</span>*)message.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="type">int</span> curr_send = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        curr_send = <span class="built_in">send</span>(m_sockClient, tmp_send, need_send, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(curr_send &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        need_send -= curr_send;</span><br><span class="line">        tmp_send += curr_send;</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_send &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::Recv</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(m_buff, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_buff));</span><br><span class="line">    <span class="type">int</span> reco = <span class="built_in">recv</span>(m_sockClient, m_buff, SMTP_MAXLEN, <span class="number">0</span>);      <span class="comment">// 收数据</span></span><br><span class="line">    <span class="keyword">if</span>(reco == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 这里需要注意一下，越界问题</span></span><br><span class="line">    m_buff[reco] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C_MY_SMTP::Login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以改为 char数组，提高效率</span></span><br><span class="line">    std::string sendBuff;</span><br><span class="line">    sendBuff = <span class="string">&quot;EHLO &quot;</span>;</span><br><span class="line">    sendBuff += m_user;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 既要接收 也要发送</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">// 表示发送失败由于网络</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = <span class="string">&quot;AUTH LOGIN\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 请求登录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;       <span class="comment">// 表示发送失败由于网络</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = m_user;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* ecode;</span><br><span class="line">    <span class="comment">/*在这里顺带扯一句，关于string类的length函数与C语言中的strlen函数的区别,strlen计算出来的长度，只到&#x27;\0&#x27;字符为止,而string::length()函数实际上返回的是string类中字符数组的大小,你自己可以测试一下，这也是为什么我下面不使用string::length()的原因*/</span></span><br><span class="line"></span><br><span class="line">    ecode = <span class="built_in">base64Encode</span>(sendBuff.<span class="built_in">c_str</span>(),<span class="built_in">strlen</span>(sendBuff.<span class="built_in">c_str</span>()));</span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = ecode;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] ecode;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 发送用户名，并接收服务器的返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    ecode = <span class="built_in">base64Encode</span>(m_pass.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(m_pass.<span class="built_in">c_str</span>()));</span><br><span class="line">    sendBuff = ecode;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] ecode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())      <span class="comment">// 发送用户密码，并接收服务器的返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> != <span class="built_in">strstr</span>(m_buff, <span class="string">&quot;550&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;               <span class="comment">// 错误码2表示用户名错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> != <span class="built_in">strstr</span>(m_buff, <span class="string">&quot;535&quot;</span>))            <span class="comment">// 535是认证失败的返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;               <span class="comment">// 错误码3表示密码错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                   <span class="comment">// 返回0 表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::SendEmailHead</span><span class="params">()</span>                 <span class="comment">// 发送邮件头部信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sendBuff;</span><br><span class="line">    sendBuff = <span class="string">&quot;MAIL From: &lt;&quot;</span> + m_user + <span class="string">&quot;&gt;\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">// 网络错误导致失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::istringstream <span class="title">is_tmp</span><span class="params">(m_targetUser)</span></span>;</span><br><span class="line">    std::string tmpadd;</span><br><span class="line">    <span class="keyword">while</span>(is_tmp &gt;&gt; tmpadd)</span><br><span class="line">    &#123;</span><br><span class="line">        sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">        sendBuff = <span class="string">&quot;RCPT TO: &lt;&quot;</span> + tmpadd + <span class="string">&quot;&gt;\r\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuff = <span class="string">&quot;DATA\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sendBuff.<span class="built_in">empty</span>();</span><br><span class="line">    <span class="built_in">FormatEmailHead</span>(sendBuff);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuff))</span><br><span class="line">    <span class="comment">// 发送完头部之后不必调用接收函数，因为没有\r\n</span></span><br><span class="line">    <span class="comment">// 没有\r\n 结尾，服务器认为你没有发完数据，所以不会返回什么值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化要发送的内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C_MY_SMTP::FormatEmailHead</span><span class="params">(std::string&amp; email)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    email = <span class="string">&quot;From: &quot;</span>;</span><br><span class="line">    email += m_user;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;To: &quot;</span>;</span><br><span class="line">    email += m_targetUser;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;Subject: &quot;</span>;</span><br><span class="line">    email += m_title;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;MIME_Version: 1.0&quot;</span>;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    email += <span class="string">&quot;Content-Type: multipart/mixed;boundary=qwertyuiop&quot;</span>;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    email += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件正文（文本）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::SendTextBody</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sendBuff;</span><br><span class="line">    sendBuff = <span class="string">&quot;--qwertyuiop\r\n&quot;</span>;</span><br><span class="line">    sendBuff += <span class="string">&quot;Content-Type: text/plain;&quot;</span>;</span><br><span class="line">    sendBuff += <span class="string">&quot;charset=\&quot;utf-8\&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    sendBuff += m_content;</span><br><span class="line">    sendBuff += <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Send</span>(sendBuff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送结尾信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">C_MY_SMTP::SendEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string sendBuf;</span><br><span class="line">    sendBuf = <span class="string">&quot;--qwertyuiop--&quot;</span>;</span><br><span class="line">    sendBuf += <span class="string">&quot;\r\n.\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">Send</span>(sendBuf) || <span class="literal">false</span> == <span class="built_in">Recv</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sendBuf.<span class="built_in">empty</span>();</span><br><span class="line">    sendBuf = <span class="string">&quot;QUIT\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Send</span>(sendBuf) &amp;&amp; <span class="built_in">Recv</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C_MY_SMTP::SendEmail_Ex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">CreateConn</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recv()</span></span><br><span class="line">    <span class="type">int</span> err = <span class="built_in">Login</span>();          <span class="comment">// 登录</span></span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> err;             <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">SendEmailHead</span>())        <span class="comment">// 发送EMAIL头部信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">SendTextBody</span>())         <span class="comment">// 发送邮件正文（文本）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> == <span class="built_in">SendEnd</span>())              <span class="comment">// 发送邮件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">// 发送成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_smtp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;测试通过SMTP发送邮件到指定邮箱。&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">time_t</span> start_time1 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function">C_MY_SMTP <span class="title">smtp_cli</span><span class="params">(<span class="number">25</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// smtp服务 端口 25固定的</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;smtp.163.com&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">//因为我发送的邮箱是163邮箱,所以这里是163邮箱的smtp服务域名</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;你的邮箱账号@163.com&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 发送邮件的邮箱</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;1234567891352465&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 发送邮件的邮箱的授权码</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;你的需要接收的邮箱账号@m.scnu.edu.cn&quot;</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 接收邮件的邮箱</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;Linux SMTP Client Test!&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 邮件的主题</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="string">&quot;这是一个测试我的程序的邮件，若成功收到了我的邮件，说明我的程序是OK的。&quot;</span>           </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="comment">// 邮件的正文</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    )</span></span>;</span><br><span class="line">    <span class="type">time_t</span> start_time2 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    smtp_cli.<span class="built_in">SendEmail_Ex</span>();                                                                    <span class="comment">// 发送邮件</span></span><br><span class="line">    <span class="type">time_t</span> start_time3 = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time3=&quot;</span>&lt;&lt;start_time3&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time2=&quot;</span>&lt;&lt;start_time2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;time1=&quot;</span>&lt;&lt;start_time1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;构造对象使用的时间:&quot;</span>&lt;&lt;start_time2 - start_time1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;发送邮件使用的时间:&quot;</span>&lt;&lt;start_time3 - start_time2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/SendEMail_LinuxCPlusPlus/SendEMail_LinuxCPlusPlus.png" alt="SendEMail_LinuxCPlusPlus"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win10安装WSL-Ubuntu18.04</title>
      <link href="/2023/12/01/Notes/WSL_Ubuntu_Win_InstallDocs/"/>
      <url>/2023/12/01/Notes/WSL_Ubuntu_Win_InstallDocs/</url>
      
        <content type="html"><![CDATA[<h1 id="Win10安装WSL-Ubuntu18-04"><a href="#Win10安装WSL-Ubuntu18-04" class="headerlink" title="Win10安装WSL-Ubuntu18.04"></a>Win10安装WSL-Ubuntu18.04</h1><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_01.png" alt="WSL_Ubuntu_Win_InstallDocs_01"></p><span id="more"></span><h2 id="一：安装前准备"><a href="#一：安装前准备" class="headerlink" title="一：安装前准备"></a>一：安装前准备</h2><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_02.png" alt="WSL_Ubuntu_Win_InstallDocs_02"></p><p><strong>适用于Linux的Windows子系统</strong> 这个勾选上，确定，安装后重启电脑。</p><h2 id="二：win应用商店安装-Ubuntu18-04-LTS"><a href="#二：win应用商店安装-Ubuntu18-04-LTS" class="headerlink" title="二：win应用商店安装 Ubuntu18.04 LTS"></a>二：win应用商店安装 Ubuntu18.04 LTS</h2><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_03.png" alt="WSL_Ubuntu_Win_InstallDocs_03"></p><p>到 Microsoft Store 下载安装 Ubuntu 18.04 LTS</p><p>下载安装完成后，打开 <strong>开始</strong> 菜单，能看到<img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_04.png" alt="WSL_Ubuntu_Win_InstallDocs_04"></p><p>直接打开这个， 会让你设置用户名，设置密码。 设置完成后，到此 可以说是已经安装完成成了。</p><h2 id="三：设置apt源为国内源"><a href="#三：设置apt源为国内源" class="headerlink" title="三：设置apt源为国内源"></a>三：设置apt源为国内源</h2><p><code>/etc/apt/sources.list</code> 这个文件，先备份一份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/apt</span><br><span class="line">cp sources.list sources.list.bk</span><br></pre></td></tr></table></figure><p>然后清空 原来的 <code>source.list</code> 文件</p><p>清空命令： <code>sudo echo &quot;&quot; &gt; sources.list</code></p><p>然后使用vm编辑该文件 <code>sudo vi sources.list</code> ，添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>添加上面内容后，保存，退出。</p><p>然后更新源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure><p>到此，Ubuntu源就切换为国内源了，使用 <code>apt-get</code> 安装时就会快很多。</p><h2 id="四：迁移WSL到非系统盘"><a href="#四：迁移WSL到非系统盘" class="headerlink" title="四：迁移WSL到非系统盘"></a>四：迁移WSL到非系统盘</h2><p>WSL默认是安装到C判断，当Ubuntu系统安装东西多了，占用的空间就多了，c盘可用空间就小了。接下来看看如何迁移到非系统盘吧。</p><h3 id="1）先查看wsl子系统版本，随便打开个cmd，输入如下命令"><a href="#1）先查看wsl子系统版本，随便打开个cmd，输入如下命令" class="headerlink" title="1）先查看wsl子系统版本，随便打开个cmd，输入如下命令"></a>1）先查看wsl子系统版本，随便打开个cmd，输入如下命令</h3><p> <code>wsl -l -v</code></p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_05.png" alt="WSL_Ubuntu_Win_InstallDocs_05"></p><p>如图所示，我的 WSL子系统是 Ubuntu-18.04 版本的，注意后面的 VERSION，我这里是2，是因为我使用的是WSL2这个版本，你们的很大可能是1，从应用商店安装的，默认就是WSL1。这个不用担心，接下来会说明如何升级到 WSL2的，因为我的也是从1升级到2的。</p><h3 id="2）导出系统"><a href="#2）导出系统" class="headerlink" title="2）导出系统"></a>2）导出系统</h3><p>打开cmd，输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export Ubuntu-18.04 d:\ubuntu18.04.tar</span><br></pre></td></tr></table></figure><p>命令解释： Ubuntu-18.04 是通过 <code>wsl -l -v</code> 查看到的，分发版本号</p><p><code>d:\ubuntu18.04.tar</code> 是要保存导出的系统文件的路径，这个路径你随意，想要导出到其他盘，使用其他名称也可以，如 <code>E:\my_ubuntu_18.04_LTS.tar</code> 这也是可以的。</p><h3 id="3）-注销当前分发版本"><a href="#3）-注销当前分发版本" class="headerlink" title="3） 注销当前分发版本"></a>3） 注销当前分发版本</h3><p>还是在cmd中指向如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister Ubuntu-18.04</span><br></pre></td></tr></table></figure><h3 id="4）重新导入并安装分发版本"><a href="#4）重新导入并安装分发版本" class="headerlink" title="4）重新导入并安装分发版本"></a>4）重新导入并安装分发版本</h3><p>在重新导入之前，如果你的 WSL版本是1，则需要先升级下WSL版本。</p><p>如果不升级，在导入安装时，会报 <code>WSL 2 需要更新其内核组件。</code> 这个错误</p><p>下载 <code>wsl_update</code> 更新文件</p><p>x64版本下载地址： <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">wsl_update_x64.msi</a></p><p>下载后，直接打开安装，一路点击 <code>next</code> 即可。</p><p>安装后，重启电脑。</p><p>此时，导入系统还不行，可能会报 <code>请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化</code> ，如何解决请看下面</p><p>打开<strong>控制面板-程序-启用或关闭Windows功能</strong></p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_06.png" alt="WSL_Ubuntu_Win_InstallDocs_06"></p><p>这里要 勾选 <strong>Hyper-V</strong> ，点确定安装后，在执行下面一条指令</p><p>使用 管理员方式打开 <code>PowerShell</code></p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_07.png" alt="WSL_Ubuntu_Win_InstallDocs_07"></p><p>输入命令 <code>bcdedit /set hypervisorlaunchtype auto</code> 回车，然后重启电脑。</p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_08.png" alt="WSL_Ubuntu_Win_InstallDocs_08"></p><p><strong>重启电脑后，现在来开始重新导入并安装分发版本</strong></p><p>在cmd中执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import Ubuntu-18.04 d:\ubuntu_18.04 d:\ubuntu18.04.tar --version 2</span><br></pre></td></tr></table></figure><p>命令解释： 把 之前导出的 ubuntu18.04.tar 导入到 路径 <code>d:\ubuntu_18.04 </code>这个文件夹(这个文件夹先创建好，在执行上述命令)</p><p><strong>设置默认登陆用户为安装时用户名</strong></p><p>还是在cmd中执行下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu1804 config --default-user 你的用户名</span><br></pre></td></tr></table></figure><p>解释：<code>你的用户名</code> 是在第二：安装这里设置的用户名。</p><p>如：我这里安装是设置了用户名为 <code>zhangsan</code> 则，我这里的命令就是 <code>ubuntu1804 config --default-user zhangsan</code> 即可。</p><p>最后，导出的tar文件，删不删出自己决定呗。我就留着，作为备份。</p><p>到此，WSL子系统Ubuntu18.04就迁移完成了。</p><h2 id="五：WSL安装openssh，配置远程登录"><a href="#五：WSL安装openssh，配置远程登录" class="headerlink" title="五：WSL安装openssh，配置远程登录"></a>五：WSL安装openssh，配置远程登录</h2><p>系统会默认安装 <code>openssh-server</code> 服务。但是这个不好用，把它删了，重新下载</p><p>登录Ubuntu18.04，在终端输入命令 <code>sudo apt-get remove openssh-server</code> 删除掉，然后重新安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>安装后，修改配置文件 <code>/etc/ssh/sshd_config</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">Port 23333    # 端口号改掉，不要用22，因为怕和主机冲突</span><br><span class="line">PasswordAuthentication yes   # 允许用户名密码方式登录</span><br></pre></td></tr></table></figure><p>然后重启服务： <code>sudo service ssh --full-restart</code></p><h2 id="六：安装MySQL-5-7-36"><a href="#六：安装MySQL-5-7-36" class="headerlink" title="六：安装MySQL 5.7.36"></a>六：安装MySQL 5.7.36</h2><p>下载MySQL5.7.36安装包。</p><p>登录Ubuntu18.04，使用<code>wget</code>命令下载 MySQL.tar安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.mysql.com/archives/mysql-5.7/mysql-server_5.7.36-1ubuntu18.04_amd64.deb-bundle.tar</span><br></pre></td></tr></table></figure><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_09.png" alt="WSL_Ubuntu_Win_InstallDocs_09"></p><p>下载完后，直接解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xf mysql-server_5.7.36-1ubuntu18.04_amd64.deb-bundle.tar</span><br></pre></td></tr></table></figure><p>解压后有很多个.deb包，如下图所示 ，其中蓝色方块圈起来的是 之前下载的 tar包。</p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_10.png" alt="WSL_Ubuntu_Win_InstallDocs_10"></p><p>开始安装MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ./*</span><br></pre></td></tr></table></figure><p>apt是可以直接安装deb包的。</p><p>注意，在安装过程中，会提示要求设置 MySQL登录用户名和密码</p><p>我这里直接设置 <code>root</code> 用户 密码为 <code>123456</code></p><p>安装后，启动MySQL， 命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/rc5.d</span><br><span class="line"></span><br><span class="line">sudo ./S01mysql start</span><br></pre></td></tr></table></figure><p>登录MySQL。</p><p><code>mysql -u root -p</code> 回车，然后输入密码 <code>123456</code> 即可。</p><p><img src="https://brkzh.github.io/docPics/WSL_Ubuntu_Win_InstallDocs/WSL_Ubuntu_Win_InstallDocs_11.png" alt="WSL_Ubuntu_Win_InstallDocs_11"></p><h2 id="七：额外说明"><a href="#七：额外说明" class="headerlink" title="七：额外说明"></a>七：额外说明</h2><p>openssh-server好像不会自动启动，尝试过几种方式，都不行，等以后可行方法再说。</p><p>现在每次启动Ubuntu，都需要手动开启 ssh服务， 执行命令：<code>sudo service --full-restart</code> 或者 <code>sudo service start</code></p><p>同样，MySQL服务好像也是没有自动启动。手动启动命令: <code>sudo /etc/rc5.d/S01mysql start</code></p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 二叉树(链式存储)</title>
      <link href="/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/"/>
      <url>/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树-链式存储"><a href="#二叉树-链式存储" class="headerlink" title="二叉树(链式存储)"></a>二叉树(链式存储)</h1><p>链式存储二叉树的C++语言实现，模板方式。</p><span id="more"></span><p><strong>链式存储方式的结构示意图</strong></p><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_LinkedStorage_1.png" alt="BinaryTree_LinkedStorage_1"></p><p>需要用到链式栈、链式队列头文件，可以从之前文章中获取。</p><p><a href="https://brkzh.github.io/2022/07/09/DataStructureAndAlgorithms/008.LinkedStack/">数据结构与算法 – 链式栈 </a></p><p><a href="https://brkzh.github.io/2022/07/15/DataStructureAndAlgorithms/010.LinkedQueue/">数据结构与算法 – 链式队列</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkQueue.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkStack.hpp&quot;</span></span></span><br><span class="line"><span class="comment">// 二叉树的链式存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ECCHILDSIGN</span><span class="comment">// 节点标记</span></span><br><span class="line">&#123;</span><br><span class="line">    E_Root,<span class="comment">// 树根</span></span><br><span class="line">    E_ChildLeft,<span class="comment">// 左孩子</span></span><br><span class="line">    E_ChildRight<span class="comment">// 右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* leftChild;<span class="comment">// 左子节点指针</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* rightChild;<span class="comment">// 右子节点指针</span></span><br><span class="line">    <span class="comment">// BinaryTreeNode&lt;T&gt;* parent;// 父节点指针</span></span><br><span class="line">    <span class="comment">// BinaryTreeNode* leftChild, rightChild, parent;// 这样写也可以，不用&lt;T&gt; ，因为是在类内部定义的，所以可以不需要加上&lt;T&gt;也可以</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为实现二叉树的非递归后序遍历引入的新模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode_extra</span></span><br><span class="line">&#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* point;</span><br><span class="line">    ECCHILDSIGN pointSign;<span class="comment">// 节点标记，标记该节点是 左孩子、右孩子、根</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BinaryTree</span>();</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建一个树节点</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">CreateNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="comment">// 释放树节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReleaseNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* pnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 利用扩展二叉树的前序遍历序列来创建一个二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPT</span><span class="params">(<span class="type">char</span>* pstr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(root, pstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 利用扩展二叉树的前序遍历序列创建二叉树的递归函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPTRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>*&amp; pstr)</span></span>;<span class="comment">// 参数类型为引用，确保递归调用中对参数的改变会影响到调用者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归方式前序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line">    <span class="comment">// 递归方式中序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line">    <span class="comment">// 递归方式后序遍历</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层序遍历二叉树</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int8_t</span> mis = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">levelOrder</span>(root, mis);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 参数2说明：=1 表示要判断该树是否是一颗完全二叉树，返回的结果记录在ifct里，如果返回-1，则不是一颗完全二叉树，返回1则是</span></span><br><span class="line">    <span class="comment">//=0 表示层序遍历输出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">int8_t</span>&amp; ifct)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断该树是否是一颗完全二叉树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IfCompleteTree</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求二叉树节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSize</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 也可以用遍历二叉树的方式求节点个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSize</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 左子树个数 + 右子树个数 + 1（之所以+1，是因为还有一个根节点）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetSize</span>(tnode-&gt;leftChild) + <span class="built_in">GetSize</span>(tnode-&gt;rightChild) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求二叉树高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetHeight</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找某个节点（假设二叉树的节点各不相同）</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">SearchElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchElem</span>(root, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">SearchElem</span><span class="params">(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找某个节点的父节点（如果节点存在指向父节点的指针，那就很方便，如果不存在，那么就要从根开始查找）</span></span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">GetParent</span><span class="params">(BinaryTreeNode&lt;T&gt;* tSonNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetParent</span>(root, tSonNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BinaryTreeNode&lt;T&gt;* <span class="title">GetParent</span><span class="params">(BinaryTreeNode&lt;T&gt;* tParNode, BinaryTreeNode&lt;T&gt;* tSonNode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 树的拷贝</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinaryTree&lt;T&gt;* targetTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">CopyTree</span>(root, targetTree-&gt;root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 注意参数2：是指针的引用， 因为需要修改参数2的值，得用引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CopyTree</span><span class="params">(BinaryTreeNode&lt;T&gt;* sSource, BinaryTreeNode&lt;T&gt;*&amp; tTarget)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------- 非递归遍历操作</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">需要借助栈来实现</span></span><br><span class="line"><span class="comment">前序遍历  根 左 右</span></span><br><span class="line"><span class="comment">1) 现将根节点入栈</span></span><br><span class="line"><span class="comment">2) 如果栈不为空，则循环下面的步骤，直到栈为空</span></span><br><span class="line"><span class="comment">2.1) 栈顶元素出栈并访问（显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.2) 如果这个被访问的元素右子节点不为空，则把其右子节点入栈</span></span><br><span class="line"><span class="comment">2.3) 如果这个被访问的元素左子节点不为空，则把其左子节点入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">中序遍历 左 根 右</span></span><br><span class="line"><span class="comment">1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line"><span class="comment">2) 如果 栈不为空，则循环下面步骤</span></span><br><span class="line"><span class="comment">2.1) 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line"><span class="comment">(1) 将 当前节点的左子节点入栈,</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line"><span class="comment">2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历</span></span><br><span class="line"><span class="comment">左 右 根</span></span><br><span class="line"><span class="comment">1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"><span class="comment">2) 循环下面的步骤(循环1)：</span></span><br><span class="line"><span class="comment">2.1) 如果 当前节点 不为空，则循环(循环2)做两件事情，直到当前节点为空：</span></span><br><span class="line"><span class="comment">(1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 如果栈不为空，则循环(循环3)做如下事情：</span></span><br><span class="line"><span class="comment">(1) 栈顶元素出栈</span></span><br><span class="line"><span class="comment">(2) 如果出栈的元素有 &quot;左子树&quot;标记，则</span></span><br><span class="line"><span class="comment">(2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line"><span class="comment">(2.2) 重新将该元素入栈</span></span><br><span class="line"><span class="comment">(2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line"><span class="comment">(2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line"><span class="comment">(3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.3） 如果栈为空，则遍历结束，循环1结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder_noRecu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder_noRecu</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder_noRecu</span><span class="params">(BinaryTreeNode&lt;T&gt;* troot)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------- ## 通过遍历序列创建二叉树</span></span><br><span class="line">    <span class="comment">// 结论：已知前序和中序遍历序列，是能够唯一确定一颗二叉树的。</span></span><br><span class="line">    <span class="comment">// 如何根据前序、中序遍历序列来创建一颗二叉树</span></span><br><span class="line">    <span class="comment">// 参数 pP_T：前序遍历序列(根左右)， 比如  “ABCDE”</span></span><br><span class="line">    <span class="comment">// 参数 pI_T：中序遍历序列(左根右)，比如 &quot;DBACE&quot;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPI</span><span class="params">(<span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordPI</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何根据中序、后序遍历序列来创建一颗二叉树？</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordIPO</span><span class="params">(<span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateBTreeAccordIPO</span><span class="params">(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T, <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* root;<span class="comment">// 树根节点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// *************************************************************</span></span><br><span class="line"><span class="comment">// *************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTree&lt;T&gt;::<span class="built_in">BinaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTree&lt;T&gt;::~<span class="built_in">BinaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从根开始释放节点</span></span><br><span class="line">    <span class="built_in">ReleaseNode</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放二叉树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">ReleaseNode</span>(BinaryTreeNode&lt;T&gt;* pnode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pnode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(pnode-&gt;leftChild);</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(pnode-&gt;rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pnode;<span class="comment">// delete一个空也无所谓</span></span><br><span class="line">    pnode = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">CreateNode</span>(BinaryTreeNode&lt;T&gt;* parentnode, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (parentnode == <span class="literal">nullptr</span> &amp;&amp; pointSign != E_Root)<span class="comment">// 只有创建根节点时，parentnode才允许为nullptr</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新节点创建出来</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;</span><br><span class="line">    tmpnode-&gt;data = e;</span><br><span class="line">    tmpnode-&gt;leftChild = <span class="literal">nullptr</span>;</span><br><span class="line">    tmpnode-&gt;rightChild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把新节点放入正确的位置</span></span><br><span class="line">    <span class="keyword">if</span> (pointSign == E_Root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)<span class="comment">// 已经存在了根节点，那么就把就得根节点释放掉，用新的替换</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpnode-&gt;leftChild = root-&gt;leftChild;</span><br><span class="line">            tmpnode-&gt;rightChild = root-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pointSign == E_ChildLeft)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是左孩子节点</span></span><br><span class="line">        parentnode-&gt;leftChild = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是右孩子节点</span></span><br><span class="line">        parentnode-&gt;rightChild = tmpnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式前序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">preOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式前序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历：根 左 右</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">        <span class="built_in">preOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        <span class="built_in">preOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式中序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">inOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式中序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 中序遍历：左 根 右</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">        <span class="built_in">inOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方式后序遍历</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">postOrder</span>(BinaryTreeNode&lt;T&gt;* tnode)<span class="comment">// 递归方式后序遍历 递归函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 后续遍历：左 右 根</span></span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(tnode-&gt;leftChild);<span class="comment">// 递归遍历 左子树</span></span><br><span class="line">        <span class="built_in">postOrder</span>(tnode-&gt;rightChild);<span class="comment">// 递归遍历 右子树</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// 输出节点的数据域值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该树是否是一颗完全二叉树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> BinaryTree&lt;T&gt;::<span class="built_in">IfCompleteTree</span>()<span class="comment">// 判断是否是一颗完全二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int8_t</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">levelOrder</span>(root, res);<span class="comment">// res返回来的值，要么是1 要么是 -1 </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">bool</span>)(res + <span class="number">1</span>);<span class="comment">// res + 1 然后强转成bool值，就不会出错了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数2说明：=1 表示要判断该树是否是一颗完全二叉树，返回的结果记录在ifct里，如果返回-1，则不是一颗完全二叉树，返回1则是</span></span><br><span class="line"><span class="comment">//=0 表示层序遍历输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">levelOrder</span>(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">int8_t</span>&amp; ifct)<span class="comment">// 层序遍历函数，因为判断一颗树是否是一颗完全二叉树，通过程序遍历 比较方便，在层序遍历中，如果某个节点不存在左孩子，却存在右孩子，那么肯定就不是一颗完全二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode != <span class="literal">nullptr</span>)<span class="comment">// 若二叉树非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">        LinkQueue&lt;BinaryTreeNode&lt;T&gt;*&gt; lnobj;<span class="comment">// 注意队列的元素类型是  节点指针  类型</span></span><br><span class="line">        lnobj.<span class="built_in">EnQueue</span>(tnode);<span class="comment">// 先把根节点指针入队</span></span><br><span class="line">        <span class="keyword">while</span> (lnobj.<span class="built_in">IsEmpty</span>() == <span class="literal">false</span>)<span class="comment">// 循环判断队列是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            lnobj.<span class="built_in">DeQueue</span>(tmpnode);<span class="comment">// 出队列</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ifct != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果某个节点 左孩子不存在 却存在 右孩子 那么这棵树肯定不是一颗完全二叉树</span></span><br><span class="line">                <span class="keyword">if</span> (tmpnode-&gt;leftChild == <span class="literal">nullptr</span> &amp;&amp; tmpnode-&gt;rightChild)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;这颗二叉树不是一颗完全二叉树.&quot; &lt;&lt; endl;</span></span><br><span class="line">                    ifct = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ifct = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmpnode-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lnobj.<span class="built_in">EnQueue</span>(tmpnode-&gt;leftChild);<span class="comment">// 左孩子入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lnobj.<span class="built_in">EnQueue</span>(tmpnode-&gt;rightChild);<span class="comment">// 右孩子入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line">    &#125; <span class="comment">// end if</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用扩展二叉树的前序遍历序列创建二叉树的递归函数</span></span><br><span class="line"><span class="comment">// 参数类型为引用，确保递归调用中对参数的改变会影响到调用者</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPTRecu</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>*&amp; pstr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 前序遍历序列：ABD###C#E##    根左右</span></span><br><span class="line">    <span class="keyword">if</span> (*pstr == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根左右</span></span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = *pstr;</span><br><span class="line">        tnode-&gt;leftChild = <span class="literal">nullptr</span>;</span><br><span class="line">        tnode-&gt;rightChild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(tnode-&gt;leftChild, ++pstr);<span class="comment">// 创建左子树</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPTRecu</span>(tnode-&gt;rightChild, ++pstr);<span class="comment">// 创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二叉树高度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> BinaryTree&lt;T&gt;::<span class="built_in">GetHeight</span>(BinaryTreeNode&lt;T&gt;* tnode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leftheight = <span class="built_in">GetHeight</span>(tnode-&gt;leftChild);<span class="comment">// 左子树高度</span></span><br><span class="line">    <span class="type">int</span> rightheight = <span class="built_in">GetHeight</span>(tnode-&gt;rightChild);<span class="comment">// 右子树高度</span></span><br><span class="line">    <span class="keyword">if</span> (leftheight &gt; rightheight)</span><br><span class="line">        <span class="keyword">return</span> leftheight + <span class="number">1</span>;<span class="comment">// 左子树高度 + 1（根节点）</span></span><br><span class="line">    <span class="keyword">return</span> rightheight + <span class="number">1</span>;<span class="comment">// 右子树高度 + 1（根节点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个节点（假设二叉树的节点各不相同）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">SearchElem</span>(BinaryTreeNode&lt;T&gt;* tnode, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tnode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (tnode-&gt;data == e)<span class="comment">// 从根开始找</span></span><br><span class="line">        <span class="keyword">return</span> tnode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* p = <span class="built_in">SearchElem</span>(tnode-&gt;leftChild, e);<span class="comment">// 查找左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)<span class="comment">// 这里判断不可少</span></span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">// 在左孩子这里扎到了，那就返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SearchElem</span>(tnode-&gt;rightChild, e);<span class="comment">// 左子树查不到的情况，那就继续到右子树里面查找，这里直接return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找某个节点的父节点（如果节点存在指向父节点的指针，那就很方便，如果不存在，那么就要从根开始查找）</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BinaryTreeNode&lt;T&gt;* BinaryTree&lt;T&gt;::<span class="built_in">GetParent</span>(BinaryTreeNode&lt;T&gt;* tParNode, BinaryTreeNode&lt;T&gt;* tSonNode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tParNode == <span class="literal">nullptr</span> || tSonNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (tParNode-&gt;leftChild == tSonNode || tParNode-&gt;rightChild == tSonNode)</span><br><span class="line">        <span class="keyword">return</span> tParNode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* p_left = <span class="built_in">GetParent</span>(tParNode-&gt;leftChild, tSonNode);</span><br><span class="line">    <span class="keyword">if</span> (p_left != <span class="literal">nullptr</span>)<span class="comment">// 走到这里，如果在左孩子树中找到了，那就返回</span></span><br><span class="line">        <span class="keyword">return</span> p_left;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetParent</span>(tParNode-&gt;rightChild, tSonNode);<span class="comment">// 左孩子没找到，那么就去右孩子树递归找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的拷贝</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 注意参数2：是指针的引用， 因为需要修改参数2的值，得用引用</span></span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CopyTree</span>(BinaryTreeNode&lt;T&gt;* sSource, BinaryTreeNode&lt;T&gt;*&amp; tTarget)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sSource == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tTarget = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tTarget = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;</span><br><span class="line">        tTarget-&gt;data = sSource-&gt;data;</span><br><span class="line">        <span class="built_in">CopyTree</span>(sSource-&gt;leftChild, tTarget-&gt;leftChild);<span class="comment">// 对左子树进行拷贝</span></span><br><span class="line">        <span class="built_in">CopyTree</span>(sSource-&gt;rightChild, tTarget-&gt;rightChild);<span class="comment">// 对右子树进行拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************************** 非递归遍历操作</span></span><br><span class="line"><span class="comment">// 需要借助栈来实现</span></span><br><span class="line"><span class="comment">// 前序遍历  根 左 右</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 现将根节点入栈</span></span><br><span class="line"><span class="comment">2) 如果栈不为空，则循环下面的步骤，直到栈为空</span></span><br><span class="line"><span class="comment">2.1) 栈顶元素出栈并访问（显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.2) 如果这个被访问的元素右子节点不为空，则把其右子节点入栈</span></span><br><span class="line"><span class="comment">2.3) 如果这个被访问的元素左子节点不为空，则把其左子节点入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">preOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkStack&lt;BinaryTreeNode&lt;T&gt;*&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(troot);<span class="comment">// 根节点入栈</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">    <span class="keyword">while</span> (slinkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)<span class="comment">// 栈不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        slinkobj.<span class="built_in">Pop</span>(tmpnode);<span class="comment">// 栈顶元素出栈</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(tmpnode-&gt;rightChild);</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;leftChild != <span class="literal">nullptr</span>)</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(tmpnode-&gt;leftChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历 左 根 右</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line"><span class="comment">2) 如果 栈不为空，则循环下面步骤</span></span><br><span class="line"><span class="comment">2.1) 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line"><span class="comment">(1) 将 当前节点的左子节点入栈,</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line"><span class="comment">2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">inOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkStack&lt;BinaryTreeNode&lt;T&gt;*&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(troot);<span class="comment">// 1) 先将根节点入栈，并把根节点标记为 “当前” 节点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* curr_node = troot;<span class="comment">// 这个可以不要，因为形参是指针类型，而不是指针引用，因此修改troot不会影响到外面， 但是为了方便阅读代码，直观表达 当前节点 这个概念，就直接使用curr_node来表示</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* tmpnode;</span><br><span class="line">    <span class="keyword">while</span> (slinkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr_node-&gt;leftChild != <span class="literal">nullptr</span>)<span class="comment">// 如果 “当前”节点的左子节点不为空，则循环做两件事情，直到当前节点的左子节点为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(curr_node-&gt;leftChild);<span class="comment">// (1) 将 当前节点的左子节点入栈,</span></span><br><span class="line">            curr_node = curr_node-&gt;leftChild;<span class="comment">// (2) 将 当前节点的左子节点重新标记为 当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        slinkobj.<span class="built_in">Pop</span>(tmpnode);<span class="comment">// 2.2) 栈顶元素出栈并访问 这个元素</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)tmpnode-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmpnode-&gt;rightChild != <span class="literal">nullptr</span>)<span class="comment">// 2.3) 如果被访问的右子节点不为空，则把其右子节点指定为 当前节点 并入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            curr_node = tmpnode-&gt;rightChild;</span><br><span class="line">            slinkobj.<span class="built_in">Push</span>(curr_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="comment">// 左 右 根</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"><span class="comment">2) 循环下面的步骤(循环1)：</span></span><br><span class="line"><span class="comment">2.1) 如果 当前节点 不为空，则循环(循环2)做两件事情，直到当前节点为空：</span></span><br><span class="line"><span class="comment">(1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line"><span class="comment">(2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line"><span class="comment">2.2) 如果栈不为空，则循环(循环3)做如下事情：</span></span><br><span class="line"><span class="comment">(1) 栈顶元素出栈</span></span><br><span class="line"><span class="comment">(2) 如果出栈的元素有 &quot;左子树&quot;标记，则</span></span><br><span class="line"><span class="comment">(2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line"><span class="comment">(2.2) 重新将该元素入栈</span></span><br><span class="line"><span class="comment">(2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line"><span class="comment">(2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line"><span class="comment">(3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line"><span class="comment">2.3） 如果栈为空，则遍历结束，循环1结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">postOrder_noRecu</span>(BinaryTreeNode&lt;T&gt;* troot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (troot == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    LinkStack&lt;BTNode_extra&lt;T&gt;&gt; linkobj;</span><br><span class="line">    BTNode_extra&lt;T&gt; ext_tmpnode;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* curr_node = troot;<span class="comment">// 1) 先将 根节点 标记为 当前节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span><span class="comment">// 循环1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr_node != <span class="literal">nullptr</span>)<span class="comment">// 循环2</span></span><br><span class="line">        &#123;</span><br><span class="line">            ext_tmpnode.point = curr_node;</span><br><span class="line">            ext_tmpnode.pointSign = E_ChildLeft;<span class="comment">// 标记先处理该节点的左孩子</span></span><br><span class="line">            linkobj.<span class="built_in">Push</span>(ext_tmpnode);<span class="comment">// (1) 将 当前节点 同 左子树 标记 一起入栈，意味着后续会继续将当前节点的左子节点压栈</span></span><br><span class="line">            curr_node = curr_node-&gt;leftChild;<span class="comment">// (2) 将 当前节点的左子节点 重新标记为 当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (linkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>)<span class="comment">// 循环3</span></span><br><span class="line">        &#123;</span><br><span class="line">            linkobj.<span class="built_in">Pop</span>(ext_tmpnode);<span class="comment">// (1) 栈顶元素出栈</span></span><br><span class="line">            <span class="keyword">if</span> (ext_tmpnode.pointSign == E_ChildLeft)</span><br><span class="line">            &#123;</span><br><span class="line">                ext_tmpnode.pointSign = E_ChildRight;<span class="comment">// (2.1) 把该元素的 &quot;左子树&quot;标记修改为 &quot;右子树&quot; 标记</span></span><br><span class="line">                linkobj.<span class="built_in">Push</span>(ext_tmpnode);<span class="comment">// (2.2) 重新将该元素入栈</span></span><br><span class="line">                curr_node = ext_tmpnode.point-&gt;rightChild;<span class="comment">// (2.3) 将该元素的右子节点标记为当前节点</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// (2.4) 终止循环(终止的是循环3)，流程将走到 2.3)这里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ext_tmpnode.pointSign == E_ChildRight)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="type">char</span>)ext_tmpnode.point-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;<span class="comment">// (3) 如果出栈的元素有 &quot;右子树&quot; 标记，则访问（比如显示节点值）这个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (linkobj.<span class="built_in">Empty</span>() == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **************************************** ## 通过遍历序列创建二叉树</span></span><br><span class="line"><span class="comment">// 结论：已知前序和中序遍历序列，是能够唯一确定一颗二叉树的。</span></span><br><span class="line"><span class="comment">// 如何根据前序、中序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">// 参数 pP_T：前序遍历序列(根左右)， 比如  “ABCDE”</span></span><br><span class="line"><span class="comment">// 参数 pI_T：中序遍历序列(左根右)，比如 &quot;DBACE&quot;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPI</span>(<span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有个小插曲，这个成员函数是通过 前序、中序 序列来创建二叉树的，而且创建到 root里面去。</span></span><br><span class="line">    <span class="comment">// 如果 root原本就保存着一颗二叉树，那么在创建之前最好先把原本的树节点给释放掉，以免造成内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(root);<span class="comment">// 释放节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreateBTreeAccordPI</span>(root, pP_T, pI_T, <span class="built_in">strlen</span>(pP_T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordPI</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pP_T, <span class="type">char</span>* pI_T, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// (1)在中序遍历序列中找到根，前序遍历序列中根是在最前面的</span></span><br><span class="line">        <span class="type">int</span> tmpindex = <span class="number">0</span>;<span class="comment">// 下标，从0开始</span></span><br><span class="line">        <span class="keyword">while</span> (pP_T[<span class="number">0</span>] != pI_T[tmpindex])</span><br><span class="line">        &#123;</span><br><span class="line">            ++tmpindex;<span class="comment">// 先找到根节点在 中序序列字符串中的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = pI_T[tmpindex];<span class="comment">// 给根节点的数据域赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 创建左孩子  通过递归来创建</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPI</span>(</span><br><span class="line">            tnode-&gt;leftChild,<span class="comment">// 创建左孩子</span></span><br><span class="line">            pP_T + <span class="number">1</span>,<span class="comment">// 找到前序遍历序列中左树开始节点的位置，这里跳过了第一个节点（根），  （根 左 右）</span></span><br><span class="line">            pI_T,<span class="comment">// 中序遍历不需要改动</span></span><br><span class="line">            tmpindex<span class="comment">// 左孩子的节点个数，因为 tmpindex是父节点(根)的下标</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// (3) 创建右孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordPI</span>(</span><br><span class="line">            tnode-&gt;rightChild,<span class="comment">// 创建右孩子</span></span><br><span class="line">            pP_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到前序遍历序列中右树开始节点的位置，不难发现前序遍历序列和中序遍历序列右树开始节点的位置相同</span></span><br><span class="line">            pI_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到中序遍历序列中右树节点开始的位置</span></span><br><span class="line">            n - tmpindex - <span class="number">1</span><span class="comment">// 右孩子节点数  n 节点总数， tmpindex 左孩子节点数， -1 减去根 所以 右孩子 = n - tmpindex - 1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何根据中序、后序遍历序列来创建一颗二叉树？</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordIPO</span>(<span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 有个小插曲，这个成员函数是通过 前序、中序 序列来创建二叉树的，而且创建到 root里面去。</span></span><br><span class="line">    <span class="comment">// 如果 root原本就保存着一颗二叉树，那么在创建之前最好先把原本的树节点给释放掉，以免造成内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ReleaseNode</span>(root);<span class="comment">// 释放节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreateBTreeAccordIPO</span>(root, pInorder_T, pPostOrder_T, <span class="built_in">strlen</span>(pInorder_T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1 为引用类型，指针的引用，确保递归调用中对参数的改变会影响到调用者。</span></span><br><span class="line"><span class="comment">参数4 n 是节点的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateBTreeAccordIPO</span>(BinaryTreeNode&lt;T&gt;*&amp; tnode, <span class="type">char</span>* pInorder_T, <span class="type">char</span>* pPostOrder_T, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以通过 后序遍历 找到根节点 （最后一个就是）</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        tnode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在中序遍历序列中 找根，后序遍历序列中 根是在最后</span></span><br><span class="line">        <span class="type">int</span> tmpindex = <span class="number">0</span>;<span class="comment">// 找根的 下标，找打了的话，那么下标就是根节点在中序序列中的下标</span></span><br><span class="line">        <span class="keyword">while</span> (pPostOrder_T[n - <span class="number">1</span>] != pInorder_T[tmpindex])</span><br><span class="line">            ++tmpindex;</span><br><span class="line">        tnode = <span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;<span class="comment">// 创建根节点</span></span><br><span class="line">        tnode-&gt;data = pInorder_T[tmpindex];<span class="comment">// 给根节点数据域赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) 创建左孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordIPO</span>(</span><br><span class="line">            tnode-&gt;leftChild,<span class="comment">// 创建左孩子</span></span><br><span class="line">            pInorder_T,<span class="comment">// 中序(左根右)的不需要改动，因为开头的都是左孩子</span></span><br><span class="line">            pPostOrder_T,<span class="comment">// 后序(左右根） 仍旧不需要改动</span></span><br><span class="line">            tmpindex<span class="comment">// 左孩子节点个数</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (2) 创建右孩子</span></span><br><span class="line">        <span class="built_in">CreateBTreeAccordIPO</span>(</span><br><span class="line">            tnode-&gt;rightChild,<span class="comment">// 创建右孩子</span></span><br><span class="line">            pInorder_T + tmpindex + <span class="number">1</span>,<span class="comment">// 找到中序遍历序列中右树开始节点的位置</span></span><br><span class="line">            pPostOrder_T + tmpindex,<span class="comment">// 找到后序遍历序列中右树开始的节点位置</span></span><br><span class="line">            n - tmpindex - <span class="number">1</span><span class="comment">// 右孩子节点数</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkBinaryTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree;</span><br><span class="line">    <span class="comment">// 创建一颗二叉树</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* rootpoint = mytree.<span class="built_in">CreateNode</span>(<span class="literal">nullptr</span>, E_Root, <span class="string">&#x27;A&#x27;</span>);<span class="comment">// 创建树根节点 A</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeB = mytree.<span class="built_in">CreateNode</span>(rootpoint, E_ChildLeft, <span class="string">&#x27;B&#x27;</span>);<span class="comment">// 创建A的左孩子B</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeC = mytree.<span class="built_in">CreateNode</span>(rootpoint, E_ChildRight, <span class="string">&#x27;C&#x27;</span>);<span class="comment">// 创建A的右孩子C</span></span><br><span class="line"></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeD = mytree.<span class="built_in">CreateNode</span>(treenodeB, E_ChildLeft, <span class="string">&#x27;D&#x27;</span>);<span class="comment">// 创建B的左孩子D</span></span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* treenodeE = mytree.<span class="built_in">CreateNode</span>(treenodeC, E_ChildRight, <span class="string">&#x27;E&#x27;</span>);<span class="comment">// 创建C的右孩子D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历序列：ABD###C#E##(给出一个扩展二叉树的前序遍历序列，是能够唯一确定一颗二叉树的)</span></span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree2;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">CreateBTreeAccordPT</span>((<span class="type">char</span>*)<span class="string">&quot;ABD###C#E##&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">前序遍历序列为：A  B  D  C  E</span></span><br><span class="line"><span class="comment">中序遍历序列为：D  B  A  C  E</span></span><br><span class="line"><span class="comment">后序遍历序列为：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;层序遍历序列为：&quot;</span>;</span><br><span class="line">    mytree<span class="number">2.l</span>evelOrder();</span><br><span class="line">    <span class="comment">/* 层序遍历序列为：A  B  C  D  E */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;是否是一颗完全二叉树? &quot;</span> &lt;&lt; ((mytree<span class="number">2.</span><span class="built_in">IfCompleteTree</span>()) ? <span class="string">&quot;是的&quot;</span> : <span class="string">&quot;不是&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树节点个数为：&quot;</span> &lt;&lt; mytree<span class="number">2.</span><span class="built_in">GetSize</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树的高度为：&quot;</span> &lt;&lt; mytree<span class="number">2.</span><span class="built_in">GetHeight</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 查找某个节点</span></span><br><span class="line">    <span class="type">int</span> val = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    BinaryTreeNode&lt;<span class="type">int</span>&gt;* s_node = mytree<span class="number">2.</span><span class="built_in">SearchElem</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (s_node != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)val &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 查找某个节点的父节点</span></span><br><span class="line">        BinaryTreeNode&lt;<span class="type">int</span>&gt;* p_node = mytree<span class="number">2.</span><span class="built_in">GetParent</span>(s_node);</span><br><span class="line">        <span class="keyword">if</span> (p_node != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;找到了节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)s_node-&gt;data &lt;&lt; <span class="string">&quot; 的父节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)p_node-&gt;data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;未找到节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)s_node-&gt;data &lt;&lt; <span class="string">&quot; 的父节&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到节点：&quot;</span> &lt;&lt; (<span class="type">char</span>)val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试树的拷贝</span></span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree3;</span><br><span class="line">    mytree<span class="number">2.</span><span class="built_in">CopyTree</span>(&amp;mytree3);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝的树mytree3的中序遍历：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">inOrder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归 前序遍历二叉树</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 前序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">preOrder_noRecu</span>();</span><br><span class="line">    <span class="comment">// 非递归 中序遍历二叉树</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 中序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">inOrder_noRecu</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用非递归的方式 后序遍历二叉树：&quot;</span>;</span><br><span class="line">    mytree<span class="number">3.</span><span class="built_in">postOrder_noRecu</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用前序遍历、中序遍历序列来创建一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree4;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">CreateBTreeAccordPI</span>((<span class="type">char</span>*)<span class="string">&quot;ABDCE&quot;</span>, (<span class="type">char</span>*)<span class="string">&quot;DBACE&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用前序：ABDCE 中序：DBACE 序列创建了一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的前序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的中序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的后序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">4.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">使用前序遍历、中序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">使用前序：ABDCE 中序：DBACE 序列创建了一颗二叉树</span></span><br><span class="line"><span class="comment">该二叉树的前序遍历序列：A  B  D  C  E</span></span><br><span class="line"><span class="comment">该二叉树的中序遍历序列：D  B  A  C  E</span></span><br><span class="line"><span class="comment">该二叉树的后序遍历序列：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用中序遍历、后序遍历序列来创建一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree5;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">CreateBTreeAccordIPO</span>((<span class="type">char</span>*)<span class="string">&quot;DBACE&quot;</span>, (<span class="type">char</span>*)<span class="string">&quot;DBECA&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用中序：DBACE 后序：DBECA 序列创建了一颗二叉树&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的前序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">preOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的中序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;该二叉树的后序遍历序列：&quot;</span>;</span><br><span class="line">    mytree<span class="number">5.</span><span class="built_in">postOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">使用中序遍历、后序遍历序列来创建一颗二叉树</span></span><br><span class="line"><span class="comment">使用中序：DBACE 后序：DBECA 序列创建了一颗二叉树</span></span><br><span class="line"><span class="comment">该二叉树的前序遍历序列：A  B  D  C  E</span></span><br><span class="line"><span class="comment">该二叉树的中序遍历序列：D  B  A  C  E</span></span><br><span class="line"><span class="comment">该二叉树的后序遍历序列：D  B  E  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_LinkedStorage_2.png" alt="BinaryTree_LinkedStorage_2"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 二叉树(顺序存储)</title>
      <link href="/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/"/>
      <url>/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树-顺序存储"><a href="#二叉树-顺序存储" class="headerlink" title="二叉树(顺序存储)"></a>二叉树(顺序存储)</h1><p>顺序存储二叉树的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ECCHILDSIGN</span><span class="comment">// 节点标记</span></span><br><span class="line">&#123;</span><br><span class="line">    E_Root,<span class="comment">// 树根</span></span><br><span class="line">    E_ChildLeft,<span class="comment">// 左孩子</span></span><br><span class="line">    E_ChildRight<span class="comment">// 右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，用于存放数据元素</span></span><br><span class="line">    <span class="type">bool</span> isValid;<span class="comment">// 该节点是否有效以应对非完全二叉树(只有保存了实际节点数据的节点才是有效的)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BinaryTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MaxSize; ++i)<span class="comment">// 这里数组大小是MaxSize +1，所以这里i的终止值没有问题</span></span><br><span class="line">        &#123;</span><br><span class="line">            SqBiTree[i].isValid = <span class="literal">false</span>;<span class="comment">// 开始时节点无效，没有保存任何数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 创建一个树节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">CreateNode</span><span class="params">(<span class="type">int</span> parindex, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="comment">// 获取父节点的下标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetParentIdx</span><span class="params">(<span class="type">int</span> sonindex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ifValidRangeIdx(sonindex))<span class="comment">// 位置不合理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[sonindex].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点，不要尝试找父节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(sonindex / <span class="number">2</span>); <span class="comment">// i的父节点是(i/2)向下取整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取某个节点所在的高度</span></span><br><span class="line">    <span class="comment">// 根据二叉树的性质5：具有n(n&gt;0)个节点的完全二叉树的高度log2(n+1) 向上取整 或者是 log2(n) 向下取整 再来 + 1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetPointLevel</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点，不要尝试找父节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 采用公式计算：log2(n) 向下取整 再来 +1</span></span><br><span class="line">        <span class="type">int</span> level = <span class="built_in">int</span>(<span class="built_in">log</span>(index) / <span class="built_in">log</span>(<span class="number">2</span>)) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// c++中的log(n)函数求的是以e(2.71828)为底的对数值，如果要求以数字m为底的，则需要 log(n) / log(m)</span></span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = MaxSize; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[i].isValid == <span class="literal">true</span>)<span class="comment">// 找到了最后一个有效节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetPointLevel</span>(i);<span class="comment">// 最后一个有效节点的高度，就是整个二叉树的深度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是个完全二叉树</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IfCompleteBT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = MaxSize; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[i].isValid == <span class="literal">true</span>)<span class="comment">// 找到了最后一个有效节点</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 找到最后一个有效节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个有效节点之前的所有下标必须都是有效的，才是一颗完全二叉树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (SqBiTree[k].isValid == <span class="literal">false</span>)<span class="comment">// 所有节点必须都要有效</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历二叉树，其他的遍历方式在二叉树的链式存储中再详细书写代码</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)<span class="comment">// 树 没根</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">1</span>);<span class="comment">// 根节点的数组下标是1，所以这里把根的下标传递进去</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根左右顺序</span></span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="comment">// 输出节点的数据域的值，为了方便观察，这里用char以显示字符</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">2</span> * index);<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);<span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 左右根 顺序</span></span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">2</span> * index);</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">posOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[<span class="number">1</span>].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">posOrder</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[index].isValid == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 左右根 顺序</span></span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">2</span> * index);</span><br><span class="line">        <span class="built_in">posOrder</span>(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; (<span class="type">char</span>)SqBiTree[index].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 判断下标是否有效</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ifValidRangeIdx</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 位置必须合理</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; MaxSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt; SqBiTree[MaxSize + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 存储二叉树节点的数组，为了写程序方便，下标为0的数组元素不使用，因此这里需要+1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个树节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 参数1：父节点所在的数组下标</span></span><br><span class="line"><span class="comment">// 参数2：标记所创建的是树根、左孩子、右孩子</span></span><br><span class="line"><span class="comment">// 参数3：插入的数据节点的元素值</span></span><br><span class="line"><span class="type">int</span> BinaryTree&lt;T&gt;::<span class="built_in">CreateNode</span>(<span class="type">int</span> parindex, ECCHILDSIGN pointSign, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointSign != E_Root)</span><br><span class="line">    &#123;<span class="comment">// 创建的是 非根节点，则一定是子节点，要求parindex一定是个合理值</span></span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(parindex) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (SqBiTree[parindex].isValid == <span class="literal">false</span>)<span class="comment">// 不是一个合理的节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pointSign == E_Root)<span class="comment">// 创建的是根</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">1</span>;<span class="comment">// 根节点固定存储在下标为1的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pointSign == E_ChildLeft)<span class="comment">// 左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是左孩子的节点，节点i的左孩子节点的下标是2*i</span></span><br><span class="line">        index = <span class="number">2</span> * parindex;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建的是右孩子的节点，节点i的右孩子节点的下标是2*i + 1</span></span><br><span class="line">        index = <span class="number">2</span> * parindex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ifValidRangeIdx(index) == <span class="literal">false</span>)<span class="comment">// 位置不合理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SqBiTree[index].data = e;</span><br><span class="line">    SqBiTree[index].isValid = <span class="literal">true</span>;<span class="comment">// 标记该下标中有有效数据</span></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqBinaryTree.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTree&lt;<span class="type">int</span>&gt; mytree;</span><br><span class="line">    <span class="comment">// 创建一颗二叉树</span></span><br><span class="line">    <span class="type">int</span> indexRoot = mytree.<span class="built_in">CreateNode</span>(<span class="number">-1</span>, E_Root, <span class="string">&#x27;A&#x27;</span>);<span class="comment">// 创建树根节点A</span></span><br><span class="line">    <span class="type">int</span> indexNodeB = mytree.<span class="built_in">CreateNode</span>(indexRoot, E_ChildLeft, <span class="string">&#x27;B&#x27;</span>);<span class="comment">// 创建根节点的左孩子节点B</span></span><br><span class="line">    <span class="type">int</span> indexNodeC = mytree.<span class="built_in">CreateNode</span>(indexRoot, E_ChildRight, <span class="string">&#x27;C&#x27;</span>);<span class="comment">// 创建根节点的右孩子节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeD = mytree.<span class="built_in">CreateNode</span>(indexNodeB, E_ChildLeft, <span class="string">&#x27;D&#x27;</span>);<span class="comment">// 创建节点B的左孩子节点D</span></span><br><span class="line">    <span class="type">int</span> indexNodeE = mytree.<span class="built_in">CreateNode</span>(indexNodeB, E_ChildRight, <span class="string">&#x27;E&#x27;</span>);<span class="comment">// 创建节点C的右孩子节点E</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeG = mytree.<span class="built_in">CreateNode</span>(indexNodeD, E_ChildRight, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> indexNodeH = mytree.<span class="built_in">CreateNode</span>(indexNodeE, E_ChildLeft, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> indexNodeF = mytree.<span class="built_in">CreateNode</span>(indexNodeC, E_ChildRight, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iParentIndexE = mytree.<span class="built_in">GetParentIdx</span>(indexNodeE);<span class="comment">// 获取某个节点父节点的下标</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点E的父节点的下标是:&quot;</span> &lt;&lt; iParentIndexE &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iLevel = mytree.<span class="built_in">GetPointLevel</span>(indexNodeD);<span class="comment">// 获取某个节点所在的高度/深度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点D所在的高度/深度是:&quot;</span> &lt;&lt; iLevel &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    iLevel = mytree.<span class="built_in">GetPointLevel</span>(indexNodeB);<span class="comment">// 获取某个节点所在的高度/深度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;节点B所在的高度/深度是:&quot;</span> &lt;&lt; iLevel &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整个二叉树的深度是:&quot;</span> &lt;&lt; mytree.<span class="built_in">GetLevel</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二叉树是个完全二叉树码? &quot;</span> &lt;&lt; (mytree.<span class="built_in">IfCompleteBT</span>() ? <span class="string">&quot;是的&quot;</span> : <span class="string">&quot;不是&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">PreOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">inOrder</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序遍历序列为:&quot;</span>;</span><br><span class="line">    mytree.<span class="built_in">posOrder</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">节点E的父节点的下标是:2</span></span><br><span class="line"><span class="comment">节点D所在的高度/深度是:3</span></span><br><span class="line"><span class="comment">节点B所在的高度/深度是:2</span></span><br><span class="line"><span class="comment">整个二叉树的深度是:4</span></span><br><span class="line"><span class="comment">二叉树是个完全二叉树码? 不是</span></span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="comment">前序遍历序列为:A  B  D  G  E  H  C  F</span></span><br><span class="line"><span class="comment">中序遍历序列为:D  G  B  H  E  A  C  F</span></span><br><span class="line"><span class="comment">后序遍历序列为:G  D  H  E  B  F  C  A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/BinaryTree_SeqStorage.png" alt="BinaryTree_SeqStorage"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 循环队列</title>
      <link href="/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/"/>
      <url>/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>循环队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYCIRCLEQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYCIRCLEQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircleQueue</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">CircleQueue</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EntQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入队列（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelQueue</span><span class="params">(T&amp; e)</span></span>;    <span class="comment">// 出队列（删除数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;   <span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;  <span class="comment">// 将队列清空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序队列中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>; <span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断顺序队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序队列是否为满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data; <span class="comment">// 存放顺序队列中的元素</span></span><br><span class="line">    <span class="type">int</span> m_front;  <span class="comment">// 队头指针（数组下标），允许删除的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> m_rear;  <span class="comment">// 队尾指针（数组下标），允许插入的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队尾元素的下一个位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircleQueue&lt;T&gt;::<span class="built_in">CircleQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[MaxSize];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    <span class="comment">// 空队列，约定m_front 和 m_rear 都为0</span></span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序队列进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CircleQueue&lt;T&gt;::~<span class="built_in">CircleQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列（增加数据）,也就是从队尾增加数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">EntQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂时先不扩容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列已满，无法进行入队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[m_rear] = e;  <span class="comment">// 将数据放到队尾</span></span><br><span class="line">    <span class="comment">// m_rear++;  // 队尾指针往后走， +1</span></span><br><span class="line">    m_rear = (m_rear + <span class="number">1</span>) % MaxSize;  </span><br><span class="line">    <span class="comment">// 队尾指针+1并取余，这样m_data的下标就控制在0~（MaxSize-1）之间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列（删除数据），也就是从队头删除数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">DelQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法进行出队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_front];   <span class="comment">// 队头元素值返回到e中</span></span><br><span class="line">    <span class="comment">// m_front++;  // 队头往后走一个</span></span><br><span class="line">    m_front = (m_front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法读取队头元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_rear];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列清空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CircleQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_rear = m_front = <span class="number">0</span>;  <span class="comment">// 直接修改队头、队尾指针，设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序队列中的所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> CircleQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123; <span class="comment">// 按照从队头到队尾的顺序来显示数据</span></span><br><span class="line">    <span class="comment">// for (int i = m_front; i &lt; m_rear; ++i)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m_front; i != m_rear;)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line"></span><br><span class="line">        i = (i + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> CircleQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return m_rear - m_front;</span></span><br><span class="line">    <span class="keyword">return</span> (m_rear + MaxSize - m_front) % MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为空, 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为满,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CircleQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((m_rear + <span class="number">1</span>)%MaxSize == m_front)<span class="comment">// 队尾指针和数组容量作比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYCIRCLEQUEUE_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCircleQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CircleQueue&lt;<span class="type">int</span>&gt; cricleobj;</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">150</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">200</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">300</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">400</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    cricleobj.<span class="built_in">DelQueue</span>(eval);</span><br><span class="line">    cricleobj.<span class="built_in">DelQueue</span>(eval);</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">500</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">600</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">700</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">800</span>);</span><br><span class="line">    cricleobj.<span class="built_in">EntQueue</span>(<span class="number">900</span>);</span><br><span class="line">    cricleobj.<span class="built_in">DispQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopQueue.png" alt="LoopQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 双端链式队列</title>
      <link href="/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/"/>
      <url>/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/</url>
      
        <content type="html"><![CDATA[<h1 id="双端链式队列"><a href="#双端链式队列" class="headerlink" title="双端链式队列"></a>双端链式队列</h1><p>双端链式队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T 代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblQueueNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* prev;<span class="comment">// 指针域，指向前一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblLinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblLinkQueue</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">DblLinkQueue</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue_Front</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素） 队头入</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue_Front</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素） 队头出</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue_Back</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素） 队尾入</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue_Back</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素） 队尾出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队头元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetRear</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队尾元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList_Front</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素  队头开始</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList_Back</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素  队尾开始</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取链式队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">// 判断链式队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblQueueNode&lt;T&gt;* m_front;<span class="comment">// 头指针（指向头结点），这一端允许出队（删除）</span></span><br><span class="line">    DblQueueNode&lt;T&gt;* m_rear;<span class="comment">// 专门引入尾指针以方便入队（插入）操作</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 记录长度，方便长度使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkQueue&lt;T&gt;::<span class="built_in">DblLinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_front = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_front-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear = m_front;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对链式队列进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkQueue&lt;T&gt;::~<span class="built_in">DblLinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* pnode = m_front-&gt;next;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_front;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_front = m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列 队头开始入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">EnQueue_Front</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* node = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;next = m_front-&gt;next;</span><br><span class="line">    node-&gt;prev = m_front;</span><br><span class="line">    <span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">    &#123;</span><br><span class="line">        m_rear = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_front-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    m_front-&gt;next = node;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列 队尾开始入</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">EnQueue_Back</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* node = <span class="keyword">new</span> DblQueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear-&gt;next = node;<span class="comment">// 新节点插入到m_rear后面</span></span><br><span class="line">    node-&gt;prev = m_rear;</span><br><span class="line">    m_rear = node;<span class="comment">// 更新队尾指针</span></span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列 从队头出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DeQueue_Front</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp = m_front-&gt;next;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_front-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="comment">// 这里需要考虑，如果只有一个元素时，出队了就为空了</span></span><br><span class="line">    <span class="keyword">if</span> (ptmp == m_rear)</span><br><span class="line">    &#123;<span class="comment">// 只有一个元素，出队了就为空了，那么尾指针就指向m_front了</span></span><br><span class="line">        m_rear = m_front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 超过2个元素，那么就需要更新前向指针指向m_front</span></span><br><span class="line">        ptmp-&gt;next-&gt;prev = m_front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == ptmp)</span><br><span class="line">    &#123;<span class="comment">// 队列中只有一个元素节点（被删除后，整个队列为空）</span></span><br><span class="line">        m_rear = m_front;<span class="comment">// 设置队列为空，尾指针指向头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列 从队尾出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DeQueue_Back</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblQueueNode&lt;T&gt;* ptmp = m_rear;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_rear = m_rear-&gt;prev;</span><br><span class="line">    m_rear-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取队头元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队尾元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">GetRear</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_rear-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)  从前往后输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DispList_Front</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* p = m_front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)  从后往输出</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> DblLinkQueue&lt;T&gt;::<span class="built_in">DispList_Back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblQueueNode&lt;T&gt;* p = m_rear;</span><br><span class="line">    <span class="keyword">while</span> (p != m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链式队列的长度 O&#123;1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkQueue&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链式队列是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m_length &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblLinkQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblLinkQueue&lt;<span class="type">int</span>&gt; lnobj;</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">150</span>);</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    lnobj.<span class="built_in">DeQueue_Front</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">212</span>);</span><br><span class="line">    lnobj.<span class="built_in">DeQueue_Back</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">200</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">700</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList_Front</span>();<span class="comment">// 200  700</span></span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Back</span>(<span class="number">666</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue_Front</span>(<span class="number">888</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList_Front</span>();</span><br><span class="line">    lnobj.<span class="built_in">DispList_Back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">700  200</span></span><br><span class="line"><span class="comment">888  700  200  666</span></span><br><span class="line"><span class="comment">666  200  700  888</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedDequeue.png" alt="LinkedDequeue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 链式队列</title>
      <link href="/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/"/>
      <url>/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h1><p>链式队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T 代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    QueueNode&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkQueue</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkQueue</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 入队列（增加元素）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出队列（删除元素）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 获取队头元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 显示队列中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取链式队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;<span class="comment">// 判断链式队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    QueueNode&lt;T&gt;* m_front;<span class="comment">// 头指针（指向头结点），这一端允许出队（删除）</span></span><br><span class="line">    QueueNode&lt;T&gt;* m_rear;<span class="comment">// 专门引入尾指针以方便入队（插入）操作</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 记录长度，方便长度使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_front = <span class="keyword">new</span> QueueNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear = m_front;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对链式队列进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkQueue&lt;T&gt;::~<span class="built_in">LinkQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* pnode = m_front-&gt;next;</span><br><span class="line">    QueueNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_front;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_front = m_rear = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">EnQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* node = <span class="keyword">new</span> QueueNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    m_rear-&gt;next = node;<span class="comment">// 新节点插入到m_rear后面</span></span><br><span class="line">    m_rear = node;<span class="comment">// 更新队尾指针</span></span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">DeQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,不能进行出队操作!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode&lt;T&gt;* ptmp = m_front-&gt;next;;</span><br><span class="line">    e = ptmp-&gt;data;</span><br><span class="line">    m_front-&gt;next = ptmp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == ptmp)<span class="comment">// 队列中只有一个元素节点（被删除后，整个队列为空）</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_rear = m_front;<span class="comment">// 设置队列为空，尾指针指向头指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptmp;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取队头元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前链式队列为空,无法读取队头元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出队列中所有元素  O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkQueue&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    QueueNode&lt;T&gt;* p = m_front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链式队列的长度 O&#123;1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkQueue&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断链式队列是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_front == m_rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue&lt;<span class="type">int</span>&gt; lnobj;</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    lnobj.<span class="built_in">DeQueue</span>(eval);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">200</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">700</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList</span>();<span class="comment">// 200  700</span></span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">666</span>);</span><br><span class="line">    lnobj.<span class="built_in">EnQueue</span>(<span class="number">888</span>);</span><br><span class="line">    lnobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedQueue.png" alt="LinkedQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序队列</title>
      <link href="/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/"/>
      <url>/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><p>顺序队列的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQQUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">// 数组的尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqQueue</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqQueue</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">SeqQueue</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">EntQueue</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入队列（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DelQueue</span><span class="params">(T&amp; e)</span></span>;    <span class="comment">// 出队列（删除数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(T&amp; e)</span></span>;   <span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearQueue</span><span class="params">()</span></span>;  <span class="comment">// 将队列清空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispQueue</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序队列中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">()</span></span>;  <span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断顺序队列是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序队列是否为满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;  <span class="comment">// 存放顺序队列中的元素</span></span><br><span class="line">    <span class="type">int</span> m_front;  <span class="comment">// 队头指针（数组下标），允许删除的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队列头元素</span></span><br><span class="line">    <span class="type">int</span> m_rear;  <span class="comment">// 队尾指针（数组下标），允许插入的一端，</span></span><br><span class="line">    <span class="comment">// 如果队列不为空，则指向队尾元素的下一个位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序队列进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[MaxSize];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    <span class="comment">// 空队列，约定m_front 和 m_rear 都为0</span></span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序队列进行释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqQueue&lt;T&gt;::~<span class="built_in">SeqQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_front = <span class="number">0</span>;</span><br><span class="line">    m_rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队列（增加数据）,也就是从队尾增加数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">EntQueue</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 暂时先不扩容</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列已满，无法进行入队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[m_rear] = e;  <span class="comment">// 将数据放到队尾</span></span><br><span class="line">    m_rear++;  <span class="comment">// 队尾指针往后走， +1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队列（删除数据），也就是从队头删除数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">DelQueue</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法进行出队操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_front];   <span class="comment">// 队头元素值返回到e中</span></span><br><span class="line">    m_front++;  <span class="comment">// 队头往后走一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取队头元素，但是这个元素并没有出队，而是依旧在队列中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">GetHead</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;顺序队列为空，无法读取队头元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_rear];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将队列清空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">ClearQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_rear = m_front = <span class="number">0</span>;   <span class="comment">// 直接修改队头、队尾指针，设置为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序队列中的所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqQueue&lt;T&gt;::<span class="built_in">DispQueue</span>()</span><br><span class="line">&#123; <span class="comment">// 按照从队头到队尾的顺序来显示数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m_front; i &lt; m_rear; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序队列的长度（实际拥有的元素数量）,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqQueue&lt;T&gt;::<span class="built_in">QueueLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_rear - m_front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为空, 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear == m_front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序队列是否为满,时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqQueue&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_rear &gt;= MaxSize)  <span class="comment">// 队尾指针和数组容量作比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSEQQUEUE_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqQueue.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqQueue&lt;<span class="type">int</span>&gt; seqobj;</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">150</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">200</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">300</span>);</span><br><span class="line">    seqobj.<span class="built_in">EntQueue</span>(<span class="number">400</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    seqobj.<span class="built_in">DispQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqQueue.png" alt="SeqQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 链式栈</title>
      <link href="/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/"/>
      <url>/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/</url>
      
        <content type="html"><![CDATA[<h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><p>链式栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYLINKSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYLINKSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 链式栈中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;  <span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    StackNode&lt;T&gt;* next;  <span class="comment">// 指针域，指向下一个同类型(和本节点类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式栈的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkStack</span>();  <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkStack</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 入栈元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>; <span class="comment">// 出栈(删除数据)操作，也就是删除栈顶数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;  <span class="comment">// 读取栈顶数据，但该元素并没有出栈，依旧在栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;  <span class="comment">// 输出链式栈中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;   <span class="comment">// 获取链式栈的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;  <span class="comment">// 判断链式栈是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    StackNode&lt;T&gt;* m_top;  <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> m_length; <span class="comment">// 链式栈当前长度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对链式栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_top = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作。入栈元素e，时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    StackNode&lt;T&gt;* p_new = <span class="keyword">new</span> StackNode&lt;T&gt;;</span><br><span class="line">    p_new-&gt;data = e;</span><br><span class="line">    p_new-&gt;next = m_top;</span><br><span class="line">    m_top = p_new;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈(删除数据)操作，也就是删除栈顶数据</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;当前链式栈为空，无法进行出栈操作!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode&lt;T&gt;* p_curr = m_top;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    m_top = m_top-&gt;next;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;出栈操作成功，元素为值为:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">delete</span> p_curr;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取栈顶数据，但该元素并没有出栈，依旧在栈中</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前链式栈为空，无法读取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_top-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出链式栈中所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkStack&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Empty</span>() == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    StackNode&lt;T&gt;* p_curr = m_top;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取链式栈的长度 O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断链式栈是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkStack&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数 释放链式栈内存空间</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkStack&lt;T&gt;::~<span class="built_in">LinkStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T tmp_value = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Pop</span>(tmp_value) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里不用干啥</span></span><br><span class="line">        <span class="comment">// 把栈顶元素删除光，while循环也就退出了，此时也就是空栈了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYLINKSTACK_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkStack.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两个数字相加的和值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> tmpA, <span class="type">int</span> tmpB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = tmpA + tmpB;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_operator_ch[] = &#123; <span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">Push</span>(<span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result = <span class="built_in">Add</span>(a1, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;和值为:&quot;</span> &lt;&lt; result &lt;&lt; endl;<span class="comment">// 和值为:115</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isMatchSucc = <span class="literal">true</span>;<span class="comment">// 是否匹配成功的标志，先标记为匹配成功</span></span><br><span class="line">    LinkStack&lt;<span class="type">char</span>&gt; slinkobjprocKH;<span class="comment">// 用来保存左括号的栈 &#123; [ (</span></span><br><span class="line">    string strExp = <span class="string">&quot;[(&#123;&#125;)&#123;&#125;]&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strExp.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (strExp[i] == <span class="string">&#x27;(&#x27;</span> || </span><br><span class="line">            strExp[i] == <span class="string">&#x27;[&#x27;</span> || </span><br><span class="line">            strExp[i] == <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">           )</span><br><span class="line">        &#123;</span><br><span class="line">            slinkobjprocKH.<span class="built_in">Push</span>(strExp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前是个右括号，则从栈顶取出一个左括号</span></span><br><span class="line">            <span class="type">char</span> tmpTopChar;</span><br><span class="line">            <span class="keyword">if</span> (slinkobjprocKH.<span class="built_in">Pop</span>(tmpTopChar) == <span class="literal">false</span>)</span><br><span class="line">            &#123;<span class="comment">// 从栈顶取出数据失败</span></span><br><span class="line">                isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((strExp[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;(&#x27;</span>) ||</span><br><span class="line">                (strExp[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                (strExp[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; tmpTopChar == <span class="string">&#x27;&#123;&#x27;</span>) </span><br><span class="line">               )  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// isMatchSucc = true;</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 匹配，继续扫描</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;  <span class="comment">// 不匹配，直接退出循环，因为已经不匹配了，直接不扫描了</span></span><br><span class="line">                isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">// end if</span></span><br><span class="line">    &#125;  <span class="comment">// end for</span></span><br><span class="line">    <span class="comment">// 扫描完成，还要确定slinkobjprocKH为空才可以</span></span><br><span class="line">    <span class="keyword">if</span> ((isMatchSucc == <span class="literal">true</span>) &amp;&amp; (slinkobjprocKH.<span class="built_in">Empty</span>() == <span class="literal">false</span>))</span><br><span class="line">    &#123; <span class="comment">// 栈不为空，也是不可以的</span></span><br><span class="line">        isMatchSucc = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMatchSucc)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式合法，括号配对数量和顺序都正确！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; strExp &lt;&lt; <span class="string">&quot;\&quot;格式非法，括号配对数量和顺序都不正确！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------- Main 结束 -------------------------&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LinkedStack.png" alt="LinkedStack"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 共享栈</title>
      <link href="/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/"/>
      <url>/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/</url>
      
        <content type="html"><![CDATA[<h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><p>共享栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSHARESTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSHARESTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10  <span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5   <span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"><span class="comment">// 共享栈</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShareStack</span>(<span class="type">int</span> length = InitSize);  <span class="comment">// 构造函数参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">ShareStack</span>();  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span>  <span class="comment">// 判断共享栈是否满</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_top1 + <span class="number">1</span> &gt;= m_top2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> stackNum, <span class="type">const</span> T&amp; e)</span>  <span class="comment">// 入栈(增加数据) 参数 stackNum用于表示栈1还是栈2</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里简单处理</span></span><br><span class="line">            <span class="comment">// 也可以增加代码支持共享栈的扩容操作</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;共享栈满了，无法入栈新数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的入栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的入栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;  <span class="comment">// 走这里，就是入栈1</span></span><br><span class="line">            m_data[++m_top1] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// 前面已经判断过 stackNum 不是1 就是2</span></span><br><span class="line">        &#123; <span class="comment">// 走到这里，就是入栈2</span></span><br><span class="line">            m_data[--m_top2] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(<span class="type">int</span> stackNum, T&amp; e)</span>  <span class="comment">// 出栈(删除数据)，也就是删除栈顶数据</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top1 &lt;= <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈1为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top1--];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top2 &gt;= m_maxsize)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈2为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top2++];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetPop</span><span class="params">(<span class="type">int</span> stackNum, T&amp; e)</span>  <span class="comment">// 获取栈顶元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top1 &lt;= <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈1为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top1];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_top2 &gt;= m_maxsize)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;当前顺序栈2为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e = m_data[m_top2];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DisplayStack</span><span class="params">(<span class="type">int</span> stackNum = <span class="number">0</span>)</span><span class="comment">// 打印栈元素</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">/* 参数说明：  </span></span><br><span class="line"><span class="comment">stackNum = 0 代表打印所有元素， 先打印栈1，后打印栈2，从栈顶往栈底打印</span></span><br><span class="line"><span class="comment">stackNum = 1 代表打印栈1的元素，从栈顶往栈顶打印</span></span><br><span class="line"><span class="comment">stackNum = 2 代表打印栈2的元素，从栈顶往栈底打印</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="keyword">if</span> (stackNum != <span class="number">1</span> &amp;&amp; stackNum != <span class="number">2</span> &amp;&amp; stackNum != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对不起，您输入的出栈编号:&quot;</span> &lt;&lt; stackNum &lt;&lt; <span class="string">&quot;不合法!合法的出栈编号是:[0 或者 1 或者 2]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Priv_DisplayStack</span>(stackNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Priv_DisplayStack</span><span class="params">(<span class="type">int</span> stackNum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打印共享栈1的数据:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m_top1; i &gt; <span class="number">-1</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;打印共享栈2的数据:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m_top2; i &lt; m_maxsize; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;   <span class="comment">// 存放共享栈中的元素</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;  <span class="comment">// 动态数组最大容量</span></span><br><span class="line">    <span class="type">int</span> m_top1;   <span class="comment">// 顺序栈1的栈顶指针为-1，表示空栈</span></span><br><span class="line">    <span class="type">int</span> m_top2;  <span class="comment">// 顺序栈2的栈顶指针为m_maxsize，表示空栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数参数可以有默认值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ShareStack&lt;T&gt;::<span class="built_in">ShareStack</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];  <span class="comment">// 为一维数组动态分配内存</span></span><br><span class="line">    m_maxsize = length;  <span class="comment">// 共享栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">    m_top1 = <span class="number">-1</span>;   <span class="comment">// 顺序栈1的栈顶指针为-1，表示空栈</span></span><br><span class="line">    m_top2 = m_maxsize;  <span class="comment">// 顺序栈2的栈顶指针为m_maxsize，表示空栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ShareStack&lt;T&gt;::~<span class="built_in">ShareStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSHARESTACK_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 共享栈 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyShareStack.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ShareStack&lt;<span class="type">int</span>&gt; <span class="title">shareobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">1</span>, <span class="number">150</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">1</span>, <span class="number">200</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">2</span>, <span class="number">1500</span>);</span><br><span class="line">    shareobj.<span class="built_in">Push</span>(<span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">    shareobj.<span class="built_in">DisplayStack</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SharedStack.png" alt="SharedStack"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序栈</title>
      <link href="/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/"/>
      <url>/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>顺序栈的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySeqStack.h 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQSTACK_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数组中元素的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqStack</span>(<span class="type">int</span> length = InitSize);<span class="comment">// 构造函数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">SeqStack</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">//入栈（增加数据）</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 出栈（删除数据），也就是删除栈顶数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(T&amp; e)</span></span>;<span class="comment">// 读取栈顶元素，但该元素并没有出栈，而依旧是在栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispStack</span><span class="params">()</span></span>;  <span class="comment">// 输出顺序栈中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;  <span class="comment">// 获取顺序栈的长度（实际拥有的元素数量）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序栈是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>;  <span class="comment">// 判断顺序栈是否已满</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;  <span class="comment">// 当顺序栈存满数据后可以调用此函数为顺序栈扩容</span></span><br><span class="line"></span><br><span class="line">    T* m_data;  <span class="comment">// 存放顺序栈中的元素</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;  <span class="comment">// 动态数组最大容量</span></span><br><span class="line">    <span class="type">int</span> m_top;  <span class="comment">// 栈顶指针（用作数组下标），指向栈顶元素，该值为-1表示空栈</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序栈进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::<span class="built_in">SeqStack</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];  <span class="comment">// 为一维数组动态分配内存，该值和算法空间复杂度无关。</span></span><br><span class="line">    <span class="comment">// 空间复杂度一般指的是，算法额外需要的存储空间</span></span><br><span class="line">    m_top = <span class="number">-1</span>;  <span class="comment">// -1 代表空栈</span></span><br><span class="line">    m_maxsize = length;  <span class="comment">// 顺序栈最多可以存储m_maxsize个数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序栈进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqStack&lt;T&gt;::~<span class="built_in">SeqStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈（增加数据） 通常时间复杂度为O(1)，但一旦栈满了，就需要扩容，时间复杂度就变为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Push</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsFull</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 栈已经满了，需要扩容</span></span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;顺序栈已满，无法进行入栈操作了!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">//return false;</span></span><br><span class="line">        <span class="built_in">IncreaseSize</span>();  <span class="comment">// 扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_top++;  <span class="comment">// 栈顶指针向后走</span></span><br><span class="line">    m_data[m_top] = e;</span><br><span class="line">    <span class="comment">// 或者写成  m_data[++m_top] = e;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当顺序栈存满数据后可以调用此函数为顺序栈扩容, 时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T* p = m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[m_maxsize + IncSize];<span class="comment">// 重新为顺序栈分配更大的内存空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m_top; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = p[i];  <span class="comment">// 将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_maxsize = m_maxsize + IncSize;<span class="comment">// 顺序栈最大长度增加 IncSize;</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈（删除数据），也就是删除栈顶数据  时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">Pop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，无法进行出栈操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_top];  <span class="comment">// 栈顶元素返回到e中</span></span><br><span class="line">    <span class="comment">// 有的实现版本不会在Pop成员函数中返回栈顶元素，此时要取得栈顶元素，就得通过GetTop成员函数取得</span></span><br><span class="line">    --m_top;</span><br><span class="line">    <span class="comment">// 代码合并  e = m_data[m_top--];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取栈顶元素，但该元素并没有出栈，而依旧是在栈中   时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">GetTop</span>(T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前顺序栈为空，无法获取栈顶元素!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[m_top];  <span class="comment">// 栈顶元素值返回到e中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序栈中所有元素  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqStack&lt;T&gt;::<span class="built_in">DispStack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从栈顶到栈底的顺序显示数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m_top; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序栈的长度（实际拥有的元素数量） 时间复杂度O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqStack&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序栈是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsEmpty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断顺序栈是否已满</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqStack&lt;T&gt;::<span class="built_in">IsFull</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_top &gt;= m_maxsize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 顺序栈</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqStack.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SeqStack&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">150</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">200</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">300</span>);</span><br><span class="line">    seqobj.<span class="built_in">Push</span>(<span class="number">400</span>);</span><br><span class="line">    seqobj.<span class="built_in">DispStack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    seqobj.<span class="built_in">Pop</span>(eval);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    seqobj.<span class="built_in">DispStack</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqQueue.png" alt="SeqQueue"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 静态链表</title>
      <link href="/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/"/>
      <url>/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><p>静态链表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSTATICLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSTATICLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 201</span></span><br><span class="line"><span class="comment">// 静态链表的尺寸，可以根据实际需要设定该值，可用数组下标 0 - 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点使用情况，枚举标记值</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">NODEUSE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这些枚举值都给负值，以免和数组下标(从0开始的正值)冲突</span></span><br><span class="line">    e_NOUSE = <span class="number">-1</span>,<span class="comment">// 未使用(未用)</span></span><br><span class="line">    e_LAST = <span class="number">-2</span>,<span class="comment">// 最后一个节点(末尾)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 元素数据域，存放数据元素</span></span><br><span class="line">    <span class="type">int</span> cur;<span class="comment">// 游标，记录下个静态链表节点的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StaticLinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">StaticLinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findAnIdlePos</span><span class="params">()</span></span>; <span class="comment">// 找到一个空闲位置用于保存数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 在第i个位置插入指定元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelte</span><span class="params">(<span class="type">int</span> i)</span></span>;  <span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;  <span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;  <span class="comment">// 按元素值查找其在静态链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;  <span class="comment">// 输出静态链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;  <span class="comment">// 获取静态链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;  <span class="comment">// 判断静态链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; m_data[MaxSize];  <span class="comment">// 保存节点数据的数组</span></span><br><span class="line">    <span class="type">int</span> m_length; <span class="comment">// 当前长度，也就是当前保存的数据节点数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对静态链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">StaticLinkList&lt;T&gt;::<span class="built_in">StaticLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MaxSize; ++i)</span><br><span class="line">    &#123;<span class="comment">// 从下标1开始的节点用于保存实际的数据，这些节点的curr有必要设置值，而头结点其实不用给任何值</span></span><br><span class="line">        m_data[i].cur = e_NOUSE;</span><br><span class="line">    &#125;</span><br><span class="line">    m_length = <span class="number">0</span>;  <span class="comment">// 还未向其中存入任何数据元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在m_data中找到一个空闲位置用于保存数据,若没找到(静态链表满了)就返回-1</span></span><br><span class="line"><span class="comment">// (插入数据的辅助函数)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">findAnIdlePos</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MaxSize; ++i)  </span><br><span class="line">    &#123;<span class="comment">// 因为下标0是头结点，不能用于保存数据，所以循环变量从1开始</span></span><br><span class="line">        <span class="keyword">if</span> (m_data[i].cur == e_NOUSE)  <span class="comment">// 未使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第iPos个位置(编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> iPos, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (iPos &lt; <span class="number">1</span> || iPos &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;不合法，合法位置是: [1 - &quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;] !&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> iIdx;</span><br><span class="line">    <span class="keyword">if</span> ((iIdx = <span class="built_in">findAnIdlePos</span>()) == <span class="number">-1</span>)  <span class="comment">// 静态链表满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表已满!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然需要在第iPos位置插入元素，那么肯定需要找到iPos-1个位置</span></span><br><span class="line">    <span class="type">int</span> iDataCount = <span class="number">1</span>;  <span class="comment">// 统计静态链表中元素数量</span></span><br><span class="line">    <span class="type">int</span> iIdxPrev;   <span class="comment">// 保存第iPos-1个位置对应的m_data数组的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iPos == <span class="number">1</span>)   <span class="comment">// 向第一个位置插入元素，需要单独处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data[iIdx].data = e;</span><br><span class="line">        <span class="keyword">if</span> (m_length == <span class="number">0</span>)  <span class="comment">// 插入前是，空表</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[iIdx].cur = e_LAST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 非空表</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_data[iIdx].cur = m_data[<span class="number">0</span>].cur;  </span><br><span class="line">            <span class="comment">// 新插入的元素的游标指向原来头节点游标指向的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_data[<span class="number">0</span>].cur = iIdx;  <span class="comment">// 头节点的游标指向新插入的节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 插入位置不等于1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> iPosCount = <span class="number">0</span>;  <span class="comment">// 位置计数</span></span><br><span class="line">        <span class="type">int</span> tmpcur = m_data[<span class="number">0</span>].cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为前面已经判断过插入位置合法，所以一定可以扎到合适的位置</span></span><br><span class="line">            <span class="comment">// while(true)循环肯定可以正常退出</span></span><br><span class="line">            iPosCount++;</span><br><span class="line">            <span class="keyword">if</span> (iPosCount &gt;= (iPos - <span class="number">1</span>))  <span class="comment">// 找到了第iPos-1个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                iIdxPrev = tmpcur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpcur = m_data[tmpcur].cur;</span><br><span class="line">        &#125;  <span class="comment">// end while</span></span><br><span class="line">        <span class="type">int</span> iTmpCurr = m_data[iIdxPrev].cur;</span><br><span class="line">        m_data[iIdxPrev].cur = iIdx;</span><br><span class="line">        m_data[iIdx].data = e;</span><br><span class="line">        m_data[iIdx].cur = iTmpCurr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法获取数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1-&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="type">int</span> iPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iPos++;</span><br><span class="line">        <span class="keyword">if</span> (iPos == i)</span><br><span class="line">        &#123;</span><br><span class="line">            e = m_data[tmp_cur].data;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在静态链表中第一次出现的位置  时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法获取数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="type">int</span> iPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iPos++;</span><br><span class="line">        <span class="keyword">if</span> (e == m_data[tmp_cur].data &amp;&amp; m_data[tmp_cur].cur != e_NOUSE)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;成功找到元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;在静态链表中的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> iPos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_data[tmp_cur].cur == e_LAST)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;在静态链表中没有找到!:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出静态链表中的所有元素 O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> StaticLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[tmp_cur].data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((tmp_cur = m_data[tmp_cur].cur) == e_LAST)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态链表的长度  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断静态链表是否为空  O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第iPos个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> StaticLinkList&lt;T&gt;::<span class="built_in">ListDelte</span>(<span class="type">int</span> iPos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;静态链表为空，无法删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (iPos &lt; <span class="number">1</span> || iPos &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;待删除的位置:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1-&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp_cur = m_data[<span class="number">0</span>].cur; <span class="comment">// 第一个数据节点的数组下标</span></span><br><span class="line">    <span class="keyword">if</span> (iPos == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">// 删除第一个位置元素，要单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (m_length != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这个静态链表里有多个元素，那么</span></span><br><span class="line">            m_data[<span class="number">0</span>].cur = m_data[tmp_cur].cur; </span><br><span class="line">            <span class="comment">// 头结点指向第二个数据节点数组下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_data[tmp_cur].cur = e_NOUSE;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;的元素，该元素值为:&quot;</span> &lt;&lt; m_data[tmp_cur].data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 删除的不是第一个位置的元素</span></span><br><span class="line">        <span class="type">int</span> iIdxPrev;  <span class="comment">// 第iPos - 1个位置对应的m_data数组的下标</span></span><br><span class="line">        <span class="type">int</span> iPosCount = <span class="number">0</span>; <span class="comment">// 位置计数</span></span><br><span class="line">        <span class="comment">// 前面已经判断过删除位置合法，所以一定可以找到合适位置，while(true)循环肯定可以正常退出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iPosCount++;</span><br><span class="line">            <span class="keyword">if</span> (iPosCount &gt;= (iPos - <span class="number">1</span>))<span class="comment">// 找到了第i-1个位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                iIdxPrev = tmp_cur;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp_cur = m_data[tmp_cur].cur;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line">        <span class="type">int</span> iTmpCur = m_data[iIdxPrev].cur;<span class="comment">// 当前要删除的这个节点的数组下标</span></span><br><span class="line">        m_data[iIdxPrev].cur = m_data[iTmpCur].cur;<span class="comment">// 前一个系欸但的cur指向当前要删除节点的cur</span></span><br><span class="line">        m_data[iTmpCur].cur = e_NOUSE;<span class="comment">// 标记被删除数据节点的数组下标为未用状态</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; iPos &lt;&lt; <span class="string">&quot;的元素，该元素值为:&quot;</span> &lt;&lt; m_data[iTmpCur].data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">StaticLinkList&lt;T&gt;::~<span class="built_in">StaticLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先暂时为空</span></span><br><span class="line">    <span class="comment">// 静态链表没有动态new空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYSTATICLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyStaticLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StaticLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">5</span>, <span class="number">190</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">190</span>);</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(<span class="number">300</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">0</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">6</span>, eval);  <span class="comment">// 如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">1</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">5</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListDelte</span>(<span class="number">10</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">500</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">600</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">4</span>, <span class="number">700</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/StaticLinkedList.png" alt="StaticLinkedList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 循环链表</title>
      <link href="/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/"/>
      <url>/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>循环链表的C++语言实现，模板方式。</p><span id="more"></span><h1 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单循环链表中每个节点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;       <span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;                <span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    Node&lt;T&gt;* next;         <span class="comment">// 指针域，指向下一个同类型(和本节点类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CirLinkList</span>();                   <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">CirLinkList</span>();                  <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;    <span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;                <span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;    <span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;   <span class="comment">// 按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;              <span class="comment">// 输出单循环链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;             <span class="comment">// 获取单循环链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                 <span class="comment">// 判断单循环链表是否为空</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* m_head; <span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;    <span class="comment">// 单循环链表当前长度(当前有几个元素)，为编程更方便而引入的，但非必须</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对单循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    m_head-&gt;next = m_head;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要插入的位置，比如要在第2个位置插入，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next; </span><br><span class="line">    <span class="comment">// 让新节点链上后续链表，因为pcurr-&gt;next指向后续的链表节点</span></span><br><span class="line">    </span><br><span class="line">    p_curr-&gt;next = node; <span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length++;                                                     <span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next; </span><br><span class="line">        <span class="comment">// pcurr会找到当前要删除的位置所代表的节点的前一个节点的位置，比如要删除第2个位置的节点，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_curr-&gt;next;   <span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;   <span class="comment">// 第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length--;     <span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前单循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        e = p_curr-&gt;data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在单循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span> CirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单循环链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;                                                      <span class="comment">// 返回-1表示查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出单循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">void</span> CirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != m_head)                                             <span class="comment">// 这里采用while循环或者for循环书写都可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;                                <span class="comment">// 每个数据之间以空格分隔</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;                                         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span>  CirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> CirLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_head-&gt;next == m_head)                                     <span class="comment">// 单循环链表为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对单循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CirLinkList&lt;T&gt;::~<span class="built_in">CirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">    Node&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != m_head)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;</span><br><span class="line">    m_head = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYCIRLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCirLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单循环链表</span></span><br><span class="line">    CirLinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval); <span class="comment">//如果GetElem()返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">100</span>; <span class="comment">//在单循环链表中要找的元素值</span></span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单循环链表的长度为：&quot;</span> &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopLinkedList_1.png" alt="LoopLinkedList_1"></p><h1 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h1><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYDBLCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYDBLCIRLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//双循环链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T        data;          <span class="comment">//数据域，存放数据元素</span></span><br><span class="line">    DblNode&lt;T&gt;* prior;      <span class="comment">//前趋指针，指向前一个同类型（和本节点类型相同）节点</span></span><br><span class="line">    DblNode&lt;T&gt;* next;       <span class="comment">//后继指针，指向下一个同类型（和本节点类型相同）节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双循环链表的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblCirLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblCirLinkList</span>();     <span class="comment">//构造函数，参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">DblCirLinkList</span>();    <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;    <span class="comment">//在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;                <span class="comment">//删除第i个位置的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;     <span class="comment">//获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;   <span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;               <span class="comment">//输出双循环链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">ListLength</span><span class="params">()</span></span>;             <span class="comment">//获取双循环链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;                  <span class="comment">//判断双循环链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;T&gt;* m_head;            </span><br><span class="line">    <span class="comment">//头指针（指向链表第一个节点的指针，如果链表有头结点则指向头结点）</span></span><br><span class="line">    <span class="type">int</span> m_length;                  </span><br><span class="line">    <span class="comment">//双循环链表当前长度（当前有几个元素），为编写程序更加方便和提高程序运行效率而引入，但不是必须引入</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数对双循环链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblCirLinkList&lt;T&gt;::<span class="built_in">DblCirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> DblNode&lt;T&gt;;    <span class="comment">//先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = m_head;</span><br><span class="line">    m_head-&gt;prior = m_head;</span><br><span class="line">    m_length = <span class="number">0</span>;               <span class="comment">//头结点不计入双循环链表的长度     </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个位置（位置编号从1开始）插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断插入位置i是否合法，i的合法值应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要插入的位置，比如要在第2个位置插入，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next; </span><br><span class="line">    <span class="comment">// 让新节点链上后续链表，因为pcurr-&gt;next指向后续的链表节点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;prior = p_curr;</span><br><span class="line">    <span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        p_curr-&gt;next-&gt;prior = node;</span><br><span class="line"></span><br><span class="line">    p_curr-&gt;next = node;   <span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length++;     <span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j) </span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点（头结点）</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// pcurr会找到当前要删除的位置所代表的节点的前一个节点的位置，比如要删除第2个位置的节点，pcurr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_willdel = p_curr-&gt;next;   <span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    DblNode&lt;T&gt;* p_willdelNext = p_willdel-&gt;next; <span class="comment">// p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;  <span class="comment">// 第i-1个节点的next指针指向第i+1个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_willdelNext != <span class="literal">nullptr</span>)</span><br><span class="line">        p_willdelNext-&gt;prior = p_curr;  <span class="comment">// 第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_length--;       <span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;当前双循环链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是1到&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;之间!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        e = p_curr-&gt;data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;成功获取位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按元素值查找其在双循环链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span> DblCirLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中第一次出现的位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            p_curr = p_curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双循环链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//返回-1表示查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出双循环链表中的所有元素，时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">void</span> DblCirLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        DblNode&lt;T&gt;* p = m_head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != m_head)                                             <span class="comment">// 这里采用while循环或者for循环书写都可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;                                <span class="comment">// 每个数据之间以空格分隔</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取双循环链表的长度，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">int</span>  DblCirLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断双循环链表是否为空，时间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="type">bool</span> DblCirLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_head-&gt;next == m_head)                                     <span class="comment">// 双循环链表为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过析构函数对双循环链表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblCirLinkList&lt;T&gt;::~<span class="built_in">DblCirLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* pnode = m_head-&gt;next;</span><br><span class="line">    DblNode&lt;T&gt;* ptmp;</span><br><span class="line">    <span class="keyword">while</span> (pnode != m_head)                                         <span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ptmp = pnode;</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> ptmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;                                                  <span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;                                               <span class="comment">// 非必须</span></span><br><span class="line">    m_length = <span class="number">0</span>;                                                   <span class="comment">// 非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYDBLCIRLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblCirLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblCirLinkList&lt;<span class="type">int</span>&gt; sdblcirlinkobj;</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">2</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line">    sdblcirlinkobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/LoopLinkedList_2.png" alt="LoopLinkedList_2"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 双向链表</title>
      <link href="/2023/06/03/DataStructuresAndAlgorithms/003.DeList/"/>
      <url>/2023/06/03/DataStructuresAndAlgorithms/003.DeList/</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>双向链表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYDBLLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYDBLLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DblNode</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，用于存放数据元素</span></span><br><span class="line">    DblNode&lt;T&gt;* prior; <span class="comment">// 前趋指针，指向前一个同类型(和本节点类型相同的)节点</span></span><br><span class="line">    DblNode&lt;T&gt;* next; <span class="comment">// 后继指针，指向下一个同类型(和本节点类型相同的)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DblLinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DblLinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">DblLinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(DblNode&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 通过已知节点之前插入新元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeletePriorNode</span><span class="params">(DblNode&lt;T&gt;* p_del)</span></span>;<span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出双链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispListAndAddr</span><span class="params">()</span></span>;<span class="comment">// 输出双链表中的所有元素并打印地址</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取双链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">// 判断双链表是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListReverse</span><span class="params">()</span></span>;<span class="comment">// 双链表的翻转操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function">DblNode&lt;T&gt;* <span class="title">GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DblNode&lt;T&gt;* p_tmp = m_head;</span><br><span class="line">        <span class="keyword">return</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;T&gt;* m_head;</span><br><span class="line">    <span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点，则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 双链表当前长度(当前有几个元素),</span></span><br><span class="line">    <span class="comment">// 为了编写程序更方便和提高程序运行效率而引入，但不是必须引入。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的翻转操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListReverse</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next-&gt;next;</span><br><span class="line">    m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    DblNode&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_curr!= <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_curr;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        p_tmp-&gt;prior = m_head;</span><br><span class="line">        p_tmp-&gt;next = m_head-&gt;next;</span><br><span class="line">        m_head-&gt;next-&gt;prior = p_tmp;</span><br><span class="line">        m_head-&gt;next = p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取双链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断双链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*if (m_length &lt; 1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    <span class="keyword">if</span> (m_head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="comment">// 如果是不带头节点的双链表，则用if(m_head == nullptr)来判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; i || i &gt;(m_length ))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按元素值查找其在双链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> DblLinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p_curr-&gt;next-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中第一次出现的位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在双链表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对双链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkList&lt;T&gt;::<span class="built_in">DblLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> DblNode&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 该值暂时为nullptr，因为还没有后继节点</span></span><br><span class="line">    m_head-&gt;prior = <span class="literal">nullptr</span>;<span class="comment">// 该值一直为nullptr</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 头结点不计入双链表的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双链表的元素插入操作  在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断插入的位置i是否合法，i的合法位置应该是1到length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; (m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于扎到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头节点)</span></span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next;</span><br><span class="line">    <span class="comment">// 让新节点链上后续节点，因为p_curr-&gt;next 指向后续的链表节点</span></span><br><span class="line"></span><br><span class="line">    node-&gt;prior = p_curr;<span class="comment">// 新节点的前趋节点指向当前p_curr节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_curr-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr-&gt;next-&gt;prior = node;<span class="comment">// 原p_curr的下一个节点的前趋指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    p_curr-&gt;next = node;<span class="comment">// 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;<span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过已知节点之前插入新元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">InsertPriorNode</span>(DblNode&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* new_node = <span class="keyword">new</span> DblNode&lt;T&gt;;</span><br><span class="line">    new_node-&gt;data = e;</span><br><span class="line">    new_node-&gt;next = p_curr;</span><br><span class="line">    new_node-&gt;prior = p_curr-&gt;prior;</span><br><span class="line">    p_curr-&gt;prior-&gt;next = new_node;</span><br><span class="line">    p_curr-&gt;prior = new_node;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出双链表中的所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>  DblLinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;  </span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出双链表中的所有元素并打印地址</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span>  DblLinkList&lt;T&gt;::<span class="built_in">DispListAndAddr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head-&gt;next;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m_head:&quot;</span> &lt;&lt; m_head &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p_curr != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node :&quot;</span> &lt;&lt; i &lt;&lt; p_curr &lt;&lt; <span class="string">&quot;  value:&quot;</span> &lt;&lt; p_curr-&gt;data &lt;&lt; std::endl;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">DblLinkList&lt;T&gt;::~<span class="built_in">DblLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    DblNode&lt;T&gt;* p_node = m_head-&gt;next;</span><br><span class="line">    DblNode&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_node != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_node;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;<span class="comment">// 非必须</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 非必须</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前双链表为空，不能删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;<span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DblNode&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)</span><br><span class="line">    &#123;<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头结点)</span></span><br><span class="line">        p_curr = p_curr-&gt;next;  </span><br><span class="line">        <span class="comment">// p_curr会找到当前要删除的位置所代表的节点的前一个节点位置，</span></span><br><span class="line">        <span class="comment">// 比如要删除第2个位置的节点，p_curr会指向第1个位置(节点)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    DblNode&lt;T&gt;* p_willdelNext = p_willdel-&gt;next;</span><br><span class="line">    <span class="comment">// p_willdelNext指向待删除节点的下一个节点</span></span><br><span class="line">    </span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">// 第i-1个节点的next指针指向第i+1节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_willdelNext != <span class="literal">nullptr</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        p_willdelNext-&gt;prior = p_curr;</span><br><span class="line">        <span class="comment">// 第i+1个节点的prior指针指向第i-1个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> DblLinkList&lt;T&gt;::<span class="built_in">DeletePriorNode</span>(DblNode&lt;T&gt;* p_del)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DblNode&lt;T&gt;* p_del_prod = p_del-&gt;prior;</span><br><span class="line">    DblNode&lt;T&gt;* p_del_next = p_del-&gt;next;</span><br><span class="line">    p_del_prod-&gt;next = p_del_next;</span><br><span class="line">    <span class="keyword">if</span> (p_del_next)</span><br><span class="line">    &#123;</span><br><span class="line">        p_del_next-&gt;prior = p_del_prod;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除元素为:&quot;</span> &lt;&lt; p_del-&gt;data &lt;&lt; <span class="string">&quot;的节点!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p_del;</span><br><span class="line">    --m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYDBLLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyDblLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DblLinkList&lt;<span class="type">int</span>&gt; sdbllinkobj;</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转双链表前打印元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispListAndAddr</span>();</span><br><span class="line">    sdbllinkobj.<span class="built_in">ListReverse</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转双链表后打印元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispListAndAddr</span>();</span><br><span class="line">    sdbllinkobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/DeList.png" alt="DeList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 单链表</title>
      <link href="/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/"/>
      <url>/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>单链表的<code>C++</code>语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYLINKLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表中每个节点的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// T代表数据元素的类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;<span class="comment">// 数据域，存放数据元素</span></span><br><span class="line">    Node&lt;T&gt;* next;<span class="comment">// 指针域，指向下一个同类型(和本类型相同)节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>();<span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="built_in">LinkList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素e</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span><span class="params">(Node&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">DeletePriorNode</span><span class="params">(Node&lt;T&gt;* p_del)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在单链表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出单链表中的所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取单链表的长度</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>;<span class="comment">// 判断单链表是否为空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;<span class="comment">// 翻转单链表</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt;* <span class="title">GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;* m_head;<span class="comment">// 头指针(指向链表第一个节点的指针，如果链表有头结点，则指向头结点)</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 单链表当前长度(当前有几个元素),</span></span><br><span class="line">    <span class="comment">// 为了编写程序更方便和提高程序运行效率而引入，但不是必须引入。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对单链表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_head = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">// 先创建一个头结点</span></span><br><span class="line">    m_head-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 头结点的指针域指向空</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 头结点不计入单链表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 不带头结点的单链表 </span></span><br><span class="line"><span class="comment">m_head = mullptr;</span></span><br><span class="line"><span class="comment">m_length = 0;  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带头节点的单链表插入操作</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断插入位置是否合法，i的合法值应该时从 1 到 m_length + 1 之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法,合法的位置是:[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">// j从0开始，表示p_curr更开始指向的是第0个节点(头结点)</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;<span class="comment">// p_curr会找到当前要插入的位置，</span></span><br><span class="line">        <span class="comment">// 比如要在第2个位置插入,p_curr最终会指向第1个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">// ①   创建新节点</span></span><br><span class="line">    node-&gt;data = e;<span class="comment">// ②</span></span><br><span class="line">    node-&gt;next = p_curr-&gt;next;<span class="comment">// ③   让新节点链上后续链表，因为p_curr-&gt;next指向的是后续链表的节点</span></span><br><span class="line">    p_curr-&gt;next = node;<span class="comment">// ④   让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;<span class="comment">// 实际表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 不带头结点的单链表插入操作</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e  【【仅供参考】】</span></span><br><span class="line"><span class="comment">template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">bool LinkList&lt;T&gt;::ListInsert(int i, const T&amp; e)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">// 判断插入位置是否合法，i的合法值应该时从 1 到 m_length + 1 之间</span></span><br><span class="line"><span class="comment">if (i &lt; 1 || i &gt;(m_length + 1))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;元素:&quot; &lt;&lt; e &lt;&lt; &quot;插入位置:&quot; &lt;&lt; i &lt;&lt; &quot;不合法,合法的位置是:[1~&quot; &lt;&lt; m_length + 1 &lt;&lt; &quot;]!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (i == 1)  // 插入到第一个位置与插入到其他位置不同，需要单独处理</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* node = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">node-&gt;data = e;</span></span><br><span class="line"><span class="comment">node-&gt;next = m_head;   // m_head原来指向的啥，就让新创建的 node(新的头结点)指向m_head</span></span><br><span class="line"><span class="comment">m_head = node;   // 头指针指向新插入的第一个节点</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;成功在位置为:&quot; &lt;&lt; i &lt;&lt; &quot;处插入元素:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">++m_length;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 插入的不是第一个位置，测程序流程继续向下走</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* p_curr = m_head;</span></span><br><span class="line"><span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line"><span class="comment">for (int j = 1; j &lt; (i - 1); ++j)  // j从1开始，表示p_curr刚开始指向的是第1个节点</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">p_curr = p_curr-&gt;next;</span></span><br><span class="line"><span class="comment"> // p_curr会找到当前要插入的位置，比如要在第2个位置插入，p_curr会指向第1个节点</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Node&lt;T&gt;* node = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">node-&gt;data = e;</span></span><br><span class="line"><span class="comment">node-&gt;next = p_curr-&gt;next;  // 让新节点链上后续链表,因为p_curr-&gt;next指向的就是后续链表节点</span></span><br><span class="line"><span class="comment">p_curr-&gt;next = node;  // 让当前位置链上新节点，因为node指向新节点</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;成功在位置为:&quot; &lt;&lt; i &lt;&lt; &quot;处插入元素:&quot; &lt;&lt; e &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">++m_length;  // 实际长度+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现向某个已知节点之前插入新节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">InsertPriorNode</span>(Node&lt;T&gt;* p_curr, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在节点p_curr之前插入新节点，新节点数据域元素值为e</span></span><br><span class="line">    Node&lt;T&gt;* node = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    node-&gt;data = e;</span><br><span class="line">    node-&gt;next = p_curr-&gt;next;</span><br><span class="line">    p_curr-&gt;next = node;</span><br><span class="line">    node-&gt;data = p_curr-&gt;data;</span><br><span class="line">    p_curr-&gt;data = e;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表为空，无法删除任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;  </span><br><span class="line">    <span class="comment">// 整个for循环用于找到第i-1个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (i - <span class="number">1</span>); ++j)<span class="comment">// j从0开始，表示p_curr刚开始指向的是第0个节点(头结点)</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="comment">// p_curr会找到当前要删除的位置所代表的节点的前一个节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_curr-&gt;next;<span class="comment">// p_willdel指向待删除的节点</span></span><br><span class="line">    p_curr-&gt;next = p_willdel-&gt;next;<span class="comment">// 第i-1个节点的next指针指向了第i+1个节点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以更快捷高效的方式实现删除某个已知节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">DeletePriorNode</span>(Node&lt;T&gt;* p_del)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 思想：把要删除的节点的下一个节点数据域拷贝到当前要删除的节点，</span></span><br><span class="line">    <span class="comment">// 当前要删除的节点的指针域指向下一个节点的指针域指向的节点。</span></span><br><span class="line">    <span class="comment">// 这样就相当于把待删除的节点的下一个节点数据拷贝到了需要待删除的节点上。</span></span><br><span class="line">    <span class="comment">// 然后真正删除的是待删除节点的下一个节点，从而实现时间复杂度为O(1)</span></span><br><span class="line">    <span class="comment">// 删除p_del所指向的节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_del-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 待删除的节点正好是最后一个节点,不能用这种方法删除，只能常规删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ListDelete</span>(m_length);</span><br><span class="line">    &#125;</span><br><span class="line">    p_del-&gt;data = p_del-&gt;next-&gt;data;<span class="comment">// 把待删除的下一个节点的数据保存到当前的需要删除节点的数据域</span></span><br><span class="line">    Node&lt;T&gt;* p_willdel = p_del-&gt;next;<span class="comment">// 待删除的节点的下一个节点(真正要删除的节点)</span></span><br><span class="line">    p_del-&gt;next = p_willdel-&gt;next;</span><br><span class="line">    --m_length;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除节点元素值为:&quot;</span> &lt;&lt; p_willdel-&gt;data &lt;&lt; <span class="string">&quot;的节点!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p_willdel;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表为空，无法获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前元素的位置:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法位置是:[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p_curr-&gt;data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在单链表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p_curr-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中第一次出现的位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在单链表中不存在!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出单链表中的所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">DispList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始打印单链表的元素&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Node&lt;T&gt;* p_curr = m_head-&gt;next;<span class="comment">// 直接略过头结点</span></span><br><span class="line">    <span class="keyword">while</span> (p_curr!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; p_curr-&gt;data &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        p_curr = p_curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;单链表元素打印结束!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// O(1)</span></span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断单链表是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// O(1)</span></span><br><span class="line"><span class="type">bool</span> LinkList&lt;T&gt;::<span class="built_in">Empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  带头节点的还可以这样判断</span></span><br><span class="line"><span class="comment">if (m_head-&gt;next == nullptr)</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转单链表</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123; <span class="comment">// 这个不是针对数据域的翻转，而是整个节点的翻转</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前单链表中的元素不超过1个，不用做任何翻转操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 至少有2个节点才会走到这里</span></span><br><span class="line">    Node&lt;T&gt;* pothersjd = m_head-&gt;next-&gt;next;<span class="comment">// 指向从第二个节点开始的后续节点</span></span><br><span class="line">    m_head-&gt;next-&gt;next = <span class="literal">nullptr</span>;<span class="comment">// 把第一个节点的指针域先置空</span></span><br><span class="line">    Node&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (pothersjd != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = pothersjd;<span class="comment">// 当前需要移动的元素</span></span><br><span class="line">        pothersjd = pothersjd-&gt;next;<span class="comment">// 指向下一个需要移动的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ListInsert(1, p_tmp);// 这样也可以</span></span><br><span class="line">        p_tmp-&gt;next = m_head-&gt;next;</span><br><span class="line">        m_head-&gt;next = p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放单链表-析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* p_node = m_head-&gt;next;</span><br><span class="line">    Node&lt;T&gt;* p_tmp;</span><br><span class="line">    <span class="keyword">while</span> (p_node != <span class="literal">nullptr</span>)<span class="comment">// 该循环负责释放数据节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p_tmp = p_node;</span><br><span class="line">        p_node = p_node-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> m_head;<span class="comment">// 释放头结点</span></span><br><span class="line">    m_head = <span class="literal">nullptr</span>;<span class="comment">//非必须，但是是个好习惯</span></span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 长度置0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__MYLINKLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main 主函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLinkList.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList&lt;<span class="type">int</span>&gt; slinkobj;</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">24</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    slinkobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    slinkobj.<span class="built_in">ListDelete</span>(<span class="number">4</span>);<span class="comment">// 删除第四个位置的节点</span></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    slinkobj.<span class="built_in">GetElem</span>(<span class="number">3</span>, eval);</span><br><span class="line">    <span class="comment">// 如果GetElem返回true，则eval中保存着获取到的元素值</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">100</span>;<span class="comment">// 在单链表中要找的元素值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单链表的长度:&quot;</span> &lt;&lt; slinkobj.<span class="built_in">ListLength</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单链表是否为空:&quot;</span> &lt;&lt; slinkobj.<span class="built_in">Empty</span>() &lt;&lt; endl;</span><br><span class="line">    slinkobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">    slinkobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SinglyLinkedList.png" alt="SinglyLinkedList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 顺序表</title>
      <link href="/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/"/>
      <url>/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>顺序表的C++语言实现，模板方式。</p><span id="more"></span><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySeqList.h 文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYSEQLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYSEQLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">// 动态数组的初始尺寸</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IncSize 5<span class="comment">// 当动态数组存满数据后每次扩容所能多保存的数据元素数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>(<span class="type">int</span> length = InitSize);<span class="comment">// 构造函数，参数可以有默认值</span></span><br><span class="line">    ~<span class="built_in">SeqList</span>();<span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">// 接口</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 在第i个位置插入指定元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">// 删除第i个位置的元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, T&amp; e)</span></span>;<span class="comment">// 获取第i个位置的元素，值通过形参引用方式返回</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">const</span> T&amp; e)</span></span>;<span class="comment">// 按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DispList</span><span class="params">()</span></span>;<span class="comment">// 输出顺序表中所有元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;<span class="comment">// 获取顺序表长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ReverseList</span><span class="params">()</span></span>;<span class="comment">// 反转顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">()</span></span>;<span class="comment">// 当顺序表满了，扩容函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T* m_data;<span class="comment">// 存放顺序表中的元素</span></span><br><span class="line">    <span class="type">int</span> m_length;<span class="comment">// 当前长度</span></span><br><span class="line">    <span class="type">int</span> m_maxsize;<span class="comment">// 最大容量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造函数对顺序表进行初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::<span class="built_in">SeqList</span>(<span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[length];</span><br><span class="line">    m_length = <span class="number">0</span>;<span class="comment">// 顺序表当前长度为0，表示还没有存储任何元素</span></span><br><span class="line">    m_maxsize = length;<span class="comment">// 顺序表最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过析构函数对顺序表进行资源释放</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SeqList&lt;T&gt;::~<span class="built_in">SeqList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    m_length = <span class="number">0</span>;</span><br><span class="line">    m_maxsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表元素插入</span></span><br><span class="line"><span class="comment">// 在第i个位置(位置编号从1开始)插入指定元素e</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(n)，时间开销主要是缘于元素的移动</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListInsert</span>(<span class="type">int</span> i, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 如果数组表已经存在，则不允许再插入数据，当前先这样，后续课程再完善</span></span><br><span class="line">    <span class="keyword">if</span> (m_length &gt;= m_maxsize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">IncreaseSize</span>();<span class="comment">// 存满了，扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断插入位置i是否合法，i的和法治应该时从1到m_length+1之间</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt;(m_length + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;插入位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length + <span class="number">1</span> &lt;&lt; <span class="string">&quot;].&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从最后一个元素开始向前遍历到要插入新元素的第i个位置，</span></span><br><span class="line">    <span class="comment">// 分别将这些位置中原有的元素向后移动一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = m_length; j &gt;= i; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[j] = m_data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    m_data[i - <span class="number">1</span>] = e;<span class="comment">// 在指定位置i出插入元素e，因为数组下标从0开始，所以这里用i-1表示插入位置所对应的数组下标</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功在位置为&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;处插入元素&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">    ++m_length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个位置的元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">ListDelete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)<span class="comment">// 空的元素表</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;空列表，无法进行删除操作!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;删除的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从数组中第i+1个位置开始向后遍历所有元素，分别将这些位置中原有的元素向前移动一个位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; m_length; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[j - <span class="number">1</span>] = m_data[j];<span class="comment">// 依次往前移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    --m_length;<span class="comment">// 实际表长-1</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功删除位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; m_data[i - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第i个位置的元素值</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> SeqList&lt;T&gt;::<span class="built_in">GetElem</span>(<span class="type">int</span> i, T&amp; e)<span class="comment">// 参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt; <span class="number">1</span>)<span class="comment">// 空的元素表</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;空列表，无法获取任何数据!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; m_length)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取元素的位置&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;不合法，合法的位置是[1~&quot;</span> &lt;&lt; m_length &lt;&lt; <span class="string">&quot;]!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = m_data[i - <span class="number">1</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;成功获取位置为:&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;的元素，该元素的值为:&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按元素值查找其在顺序表中第一次出现的位置</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">LocateElem</span>(<span class="type">const</span> T&amp; e)<span class="comment">// 参数e是引用类型参数，确保将该值带回调用者</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中第一次出现的位置为&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;<span class="comment">// 返回位置应该用数组 下标值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里，在该顺序表中没有找到对应的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;的元素在顺序表中没有找到!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 返回-1表示查找失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表元素的其他常用操作</span></span><br><span class="line"><span class="comment">// 输出顺序表中所有元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">DispList</span>()  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; m_data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取顺序表的长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T&gt;::<span class="built_in">ListLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转顺序表reverse，时间复杂度O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">ReverseList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果顺序表中没有元素或者只有一个元素，那么就不用做任何操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T temp;<span class="comment">// 中间变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length / <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = m_data[i];</span><br><span class="line">        m_data[i] = m_data[m_length - i - <span class="number">1</span>];  </span><br><span class="line">        <span class="comment">// 第一个和最后一个交换，依次往后走 第二个和倒数第二交换...</span></span><br><span class="line">        m_data[m_length - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序表的扩展操作</span></span><br><span class="line"><span class="comment">// 当顺序表存满数据后可以调用此函数为顺序表扩容,时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T&gt;::<span class="built_in">IncreaseSize</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T* p = m_data;</span><br><span class="line">    m_data = <span class="keyword">new</span> T[m_maxsize + IncSize];</span><br><span class="line">    <span class="comment">// 重新为顺序表分配更大的内存空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data[i] = p[i];<span class="comment">// 将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_maxsize += IncSize;<span class="comment">// 顺序表最大长度郑家IncSize</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __MYSEQLIST_H__</span></span></span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><code>main</code>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySeqList.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> _nmsp1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m_data[<span class="number">10</span>];  <span class="comment">// 静态数组来保存顺序表中的元素</span></span><br><span class="line">        <span class="comment">// 最多能存储10个元素</span></span><br><span class="line">        <span class="type">int</span> m_length;  <span class="comment">// 顺序表中当前实际长度(已存在的元素个数)</span></span><br><span class="line">    &#125; SeqList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* m_data; <span class="comment">// 顺序表中的元素保存在m_data所指向的动态数组内存中</span></span><br><span class="line">        <span class="type">int</span> m_length;  <span class="comment">// 顺序表中当前实际长度(已存在的元素个数)</span></span><br><span class="line">        <span class="type">int</span> m_maxsize;   <span class="comment">// 动态数组最大容量，因为动态数组可以扩容，因此要记录该值</span></span><br><span class="line">    &#125; SeqList_Dync;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SeqList&lt;<span class="type">int</span>&gt; <span class="title">seqobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">30</span>, <span class="number">8</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListDelete</span>(<span class="number">1</span>);</span><br><span class="line">    seqobj.<span class="built_in">ListDelete</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> eval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> get_res = seqobj.<span class="built_in">GetElem</span>(<span class="number">1</span>, eval);</span><br><span class="line">    <span class="comment">// 如果get_res值为true，则eval中保存着获取到的元素值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> findvalue = <span class="number">10</span>;  <span class="comment">// 在顺序表中要找的元素值</span></span><br><span class="line">    <span class="type">int</span> find_res = seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line">    findvalue = <span class="number">22</span>;  <span class="comment">// 这里改为了22，表示查找值22这个元素的下标</span></span><br><span class="line">    find_res = seqobj.<span class="built_in">LocateElem</span>(findvalue);</span><br><span class="line"></span><br><span class="line">    seqobj.<span class="built_in">ListInsert</span>(<span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前顺序表中存在元素个数:&quot;</span> &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; std::endl;</span><br><span class="line">    seqobj.<span class="built_in">ReverseList</span>();</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        seqobj.<span class="built_in">ListInsert</span>(i, i * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前顺序表中存在元素个数:&quot;</span> &lt;&lt; seqobj.<span class="built_in">ListLength</span>() &lt;&lt; std::endl;</span><br><span class="line">    seqobj.<span class="built_in">DispList</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="https://brkzh.github.io/docPics/DataStructuresAndAlgorithms/docPics/SeqList.png" alt="SeqList"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法 -- 导航栏</title>
      <link href="/2023/05/31/DataStructuresAndAlgorithms/000.DataStructersAndAlgorithmsIndex/"/>
      <url>/2023/05/31/DataStructuresAndAlgorithms/000.DataStructersAndAlgorithmsIndex/</url>
      
        <content type="html"><![CDATA[<p><strong>快速导航</strong></p><p><a href="https://brkzh.github.io/2023/06/01/DataStructuresAndAlgorithms/001.SeqList/">数据结构与算法 – 顺序表</a></p><p><a href="https://brkzh.github.io/2023/06/02/DataStructuresAndAlgorithms/002.SinglyLinkedList/">数据结构与算法 – 单链表</a></p><p><a href="https://brkzh.github.io/2023/06/03/DataStructuresAndAlgorithms/003.DeList/">数据结构与算法 – 双链表</a></p><p><a href="https://brkzh.github.io/2023/06/04/DataStructuresAndAlgorithms/004.LoopLinkedList/">数据结构与算法 – 循环链表</a></p><p><a href="https://brkzh.github.io/2023/06/05/DataStructuresAndAlgorithms/005.StaticLinkedList/">数据结构与算法 – 静态链表</a></p><p><a href="https://brkzh.github.io/2023/06/06/DataStructuresAndAlgorithms/006.SeqStack/">数据结构与算法 – 顺序栈</a></p><p><a href="https://brkzh.github.io/2023/06/07/DataStructuresAndAlgorithms/007.SharedStack/">数据结构与算法 – 共享栈</a></p><p><a href="https://brkzh.github.io/2023/06/08/DataStructuresAndAlgorithms/008.LinkedStack/">数据结构与算法 – 链式栈</a></p><p><a href="https://brkzh.github.io/2023/06/09/DataStructuresAndAlgorithms/009.SeqQueue/">数据结构与算法 – 顺序队列</a></p><p><a href="https://brkzh.github.io/2023/06/10/DataStructuresAndAlgorithms/010.LinkedQueue/">数据结构与算法 – 链式队列</a></p><p><a href="https://brkzh.github.io/2023/06/11/DataStructuresAndAlgorithms/011.LinkedDequeue/">数据结构与算法 – 双端队列</a></p><p><a href="https://brkzh.github.io/2023/06/12/DataStructuresAndAlgorithms/012.LoopQueue/">数据结构与算法 – 循环队列</a></p><p><a href="https://brkzh.github.io/2023/06/13/DataStructuresAndAlgorithms/013.BinaryTree_SeqStorage/">数据结构与算法 – 二叉树(顺序存储)</a></p><p><a href="https://brkzh.github.io/2023/06/14/DataStructuresAndAlgorithms/014.BinaryTree_LinkedStorage/">数据结构与算法 – 二叉树(链式存储)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win系统tcp模拟粘包Demo - C语言</title>
      <link href="/2023/01/02/C_CPlusPlus/TcSimulationPacketSticking_Win_C/"/>
      <url>/2023/01/02/C_CPlusPlus/TcSimulationPacketSticking_Win_C/</url>
      
        <content type="html"><![CDATA[<h1 id="Win系统tcp模拟粘包Demo-C语言"><a href="#Win系统tcp模拟粘包Demo-C语言" class="headerlink" title="Win系统tcp模拟粘包Demo - C语言"></a>Win系统tcp模拟粘包Demo - C语言</h1><p><strong>粘包</strong>：客户端发送的多个数据包被当做一个数据包接收。</p><p>也叫做 <strong>数据的无边界性</strong></p><span id="more"></span><p>函数 <code>recv()/read()</code> 是不知道数据包的开始、结束标志的（实际上也没有标志），这两个函数只把数据包当作连续的数据流来处理的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：server.c</span></span><br><span class="line"><span class="comment">// 描述：服务器端代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 11111</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    SOCKET servSock =  socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockAddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(SERV_IP);</span><br><span class="line">    sockAddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Server IP:%s\nServer Port:%d\n&quot;</span>,SERV_IP, SERV_PORT);</span><br><span class="line">    bind(servSock, (SOCKADDR*)&amp;sockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入监听</span></span><br><span class="line">    listen(servSock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端请求</span></span><br><span class="line">    SOCKADDR clntAddr;</span><br><span class="line">    <span class="type">int</span> nSize = <span class="keyword">sizeof</span>(SOCKADDR);</span><br><span class="line">    <span class="type">char</span> buffer[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wait Client Accept\n&quot;</span>);</span><br><span class="line">    SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp;clntAddr, &amp;nSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client Connected\n&quot;</span>);</span><br><span class="line">    Sleep(<span class="number">8000</span>);  <span class="comment">// 这里让程序暂停8秒钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据，并原样返回</span></span><br><span class="line">    <span class="type">int</span> recvLen = recv(clntSock, buffer, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    send(clntSock, buffer, recvLen, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字并终止DLL的使用</span></span><br><span class="line">    closesocket(clntSock);</span><br><span class="line">    closesocket(servSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server is Closed\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：client.c</span></span><br><span class="line"><span class="comment">// 描述：客户端代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)  <span class="comment">//加载 ws2_32.dll</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化DLL</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockAddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sockAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(sockAddr));</span><br><span class="line">    sockAddr.sin_family = PF_INET;</span><br><span class="line">    sockAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    sockAddr.sin_port = htons(<span class="number">11111</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    connect(sock, (SOCKADDR*)&amp;sockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户输入的字符串并发送给服务器</span></span><br><span class="line">    <span class="type">char</span> bufSend[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string:&quot;</span>);</span><br><span class="line">    gets(bufSend);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        send(sock, bufSend, <span class="built_in">strlen</span>(bufSend), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收服务器传回的数据</span></span><br><span class="line">    <span class="type">char</span> bufRecv[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Recving Message From Server.\n&quot;</span>);</span><br><span class="line">    recv(sock, bufRecv, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 输出接收到的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server:%s\n&quot;</span>, bufRecv);</span><br><span class="line"></span><br><span class="line">    closesocket(sock); <span class="comment">// 关闭套接字</span></span><br><span class="line">    WSACleanup();  <span class="comment">// 终止使用DLL</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译脚本</strong></p><p>文件名：<code>编译.bat</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o server server.c -lws2_32</span><br><span class="line">gcc -o client client.c -lws2_32</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://brkzh.github.io/docPics/C_CPlusPlus/TcSimulationPacketSticking_Win_C/TcSimulationPacketSticking_Win_C.png" alt="TcSimulationPacketSticking_Win_C"></p><p><strong>说明</strong></p><p><code>client</code> 的 <code>send()</code> 发送了三个数据包，而 <code>server</code> 的 <code>recv()</code> 却只接收到一个数据包，这很好的说明了数据的粘包问题。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现配置文件的读写</title>
      <link href="/2023/01/01/C_CPlusPlus/ConfigurationFileLoadingAndModify_C/"/>
      <url>/2023/01/01/C_CPlusPlus/ConfigurationFileLoadingAndModify_C/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言实现配置文件的读写"><a href="#C语言实现配置文件的读写" class="headerlink" title="C语言实现配置文件的读写"></a>C语言实现配置文件的读写</h1><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>global.h</td><td>定义一些宏</td></tr><tr><td>Func.h</td><td>公用函数头文件</td></tr><tr><td>Func.c</td><td>公用函数的实现</td></tr><tr><td>config.h</td><td>读写配置文件的函数声明</td></tr><tr><td>config.c</td><td>读写配置文件的函数实现</td></tr><tr><td>config_main.c</td><td>主函数入口</td></tr><tr><td>config.conf</td><td>配置文件</td></tr></tbody></table><span id="more"></span><p>直接上代码，一些解释以注释的形式写在了相应的文件里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：global.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GLOBAL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GLOBAL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__GLOBAL_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：Func.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __Func_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __Func_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rtrim</span><span class="params">(<span class="type">char</span>* sstring)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Ltrim</span><span class="params">(<span class="type">char</span>* sstring)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较str1和str2两个字符串内容是否一样，忽略大小写的比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StrcaseCmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把str全都变成大写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCase</span><span class="params">(<span class="type">char</span>* str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__Func_h__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：Func.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Func.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//截取字符串尾部空格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rtrim</span><span class="params">(<span class="type">char</span> *sstring)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sstring == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">len = <span class="built_in">strlen</span>(sstring);</span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">0</span> &amp;&amp; sstring[len - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)<span class="comment">//位置换一下</span></span><br><span class="line">sstring[--len] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//截取字符串首部空格</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ltrim</span><span class="params">(<span class="type">char</span> *sstring)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (sstring == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">char</span> *p_tmp = sstring;  <span class="comment">//此时p_tmp指向了sstring</span></span><br><span class="line"><span class="keyword">if</span> ((*p_tmp) != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">return</span>;  <span class="comment">//不是以空格开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到第一个不为空格的位置</span></span><br><span class="line"><span class="keyword">while</span> ((*p_tmp) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*p_tmp) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">p_tmp++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*p_tmp) == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//全是空格</span></span><br><span class="line">&#123;</span><br><span class="line">*sstring = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *p_tmp2 = sstring;  <span class="comment">//此时 p_tmp2 指向了 sstring</span></span><br><span class="line"><span class="keyword">while</span> ((*p_tmp2) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">(*p_tmp2) = (*p_tmp);</span><br><span class="line">p_tmp++;</span><br><span class="line">p_tmp2++;</span><br><span class="line">&#125;</span><br><span class="line">(*p_tmp2) = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//空格处理完毕，记得在末尾添加一个&#x27;\0&#x27; 表示字符串结尾</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较str1和str2两个字符串内容是否一样，忽略大小写的比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StrcaseCmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str1 == <span class="literal">NULL</span> || str2 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">size_t</span> strLen1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line"><span class="type">size_t</span> strLen2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line"><span class="keyword">if</span> (strLen1 != strLen2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// char *str = new char[strLen2]; </span></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">malloc</span>(strLen2);</span><br><span class="line"><span class="built_in">strcpy</span>(str, str2); <span class="comment">//把str2的内容拷贝到str中</span></span><br><span class="line">StringCase(str);  <span class="comment">//把str中的所有内容转成大写字母</span></span><br><span class="line"><span class="keyword">while</span> ((*str) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((*str1) &gt; <span class="number">90</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (((*str1) - <span class="number">32</span>) == (*str))</span><br><span class="line">&#123;</span><br><span class="line">++str1;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((*str1) == (*str))</span><br><span class="line">&#123;</span><br><span class="line">++str1;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把str中所有的小写字母变成大写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringCase</span><span class="params">(<span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(str) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> strLen = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="type">char</span> *ptmp = str;</span><br><span class="line"><span class="keyword">while</span> ((*ptmp) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">97</span> &lt;= (*ptmp)) &amp;&amp; ((*ptmp) &lt;= <span class="number">122</span>))</span><br><span class="line">&#123;</span><br><span class="line">(*ptmp) -= <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">++ptmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：config.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CONFIG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CONFIG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// item数组的大小，也是配置文件中有效的item项目的最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGSTRUCTSIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGNAMESIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGCONTENTSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ItemName[CONFIGNAMESIZE];</span><br><span class="line">    <span class="type">char</span> ItemContent[CONFIGCONTENTSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pconfName)</span>;</span><br><span class="line"><span class="comment">// 通过item名字获取item的内容</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetConfigFromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname)</span>;</span><br><span class="line"><span class="comment">// 通过item名字获取item内容，整型，获取不到返回默认值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetConfigIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 释放内存</span></span><br><span class="line"><span class="comment">// void FreeConfigItem();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写配置文件</span></span><br><span class="line"><span class="comment">// 通过item名字修改item内容</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ModifyConfigItemContent</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span>;</span><br><span class="line"><span class="comment">// 通过item名字和内容 添加新的item项目</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">AddConfigItem</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span>;</span><br><span class="line"><span class="comment">// 把加载进来的、或者有修改过了、增加过的 item数组写到指定的文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">WriteNewConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pconfName)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !__CONFIG_H__</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：config.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> arr_curr_ind = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span> <span class="title">ArrayConfig</span>[<span class="title">CONFIGSTRUCTSIZE</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pconfName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr_curr_ind &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(pconfName, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一行配置文件读取出来放到这里</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> linebuf_size = CONFIGCONTENTSIZE + <span class="number">1</span> + CONFIGNAMESIZE + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> linebuf[linebuf_size];  <span class="comment">// 128+1 结尾为结束符</span></span><br><span class="line">    <span class="built_in">memset</span>(linebuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(linebuf));</span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fgets(linebuf, linebuf_size, fp) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(linebuf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(*linebuf == <span class="string">&#x27;;&#x27;</span> || *linebuf == <span class="string">&#x27; &#x27;</span> || *linebuf == <span class="string">&#x27;#&#x27;</span> || *linebuf == <span class="string">&#x27;\t&#x27;</span> || *linebuf == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除字符串中的 \r \n 以及空格&#x27; &#x27;</span></span><br><span class="line">    lblprocstring:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(linebuf) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] == <span class="number">10</span> || linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] == <span class="number">13</span> || linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] == <span class="number">32</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                linebuf[<span class="built_in">strlen</span>(linebuf) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">goto</span> lblprocstring;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(linebuf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(*linebuf == <span class="string">&#x27;[&#x27;</span>)  <span class="comment">// [ 开头的注释，也保存，方便以后写文件时写回去</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr_curr_ind &lt; CONFIGSTRUCTSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemName, linebuf);</span><br><span class="line">                <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemContent, <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">// ArrayConfig[arr_curr_ind] = p_configitem;</span></span><br><span class="line">                arr_curr_ind += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ERROR</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，都是合法的配置项</span></span><br><span class="line">        <span class="type">char</span> *ptmp = <span class="built_in">strchr</span>(linebuf, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptmp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr_curr_ind &lt; CONFIGSTRUCTSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">strncpy</span>(ArrayConfig[arr_curr_ind].ItemName, linebuf, (<span class="type">int</span>)(ptmp-linebuf));</span><br><span class="line">                <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemContent, ptmp+<span class="number">1</span>);</span><br><span class="line">                Rtrim(ArrayConfig[arr_curr_ind].ItemName);</span><br><span class="line">                Ltrim(ArrayConfig[arr_curr_ind].ItemName);</span><br><span class="line">                Rtrim(ArrayConfig[arr_curr_ind].ItemContent);</span><br><span class="line">                Ltrim(ArrayConfig[arr_curr_ind].ItemContent);</span><br><span class="line">                arr_curr_ind += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ERROR</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end if</span></span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetConfigFromString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p_itemname, ArrayConfig[i].ItemName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ArrayConfig[i].ItemContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetConfigIntDefault</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemname, <span class="type">const</span> <span class="type">int</span> def)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p_itemname, ArrayConfig[i].ItemName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> atoi(ArrayConfig[i].ItemContent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> def;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ModifyConfigItemContent</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p_itemName || !p_itemContent)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret_res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p_itemName, ArrayConfig[i].ItemName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(ArrayConfig[i].ItemContent, p_itemContent);</span><br><span class="line">            ret_res = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">AddConfigItem</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*p_itemName, <span class="type">const</span> <span class="type">char</span>* p_itemContent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p_itemName || !p_itemContent)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret_res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;arr_curr_ind; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ret_res = ModifyConfigItemContent(p_itemName, p_itemContent);</span><br><span class="line">        <span class="keyword">if</span>(ret_res == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ret_res;</span><br><span class="line">    &#125;</span><br><span class="line">    ret_res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr_curr_ind &lt; CONFIGSTRUCTSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemName, p_itemName);</span><br><span class="line">        <span class="built_in">strcpy</span>(ArrayConfig[arr_curr_ind].ItemContent, p_itemContent);</span><br><span class="line">        arr_curr_ind += <span class="number">1</span>;</span><br><span class="line">        ret_res = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret_res = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">WriteNewConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*pconfName)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pconfName)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> new_fd;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (new_fd = open(pconfName,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> line_buf[<span class="number">32</span>+<span class="number">128</span>+<span class="number">1</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="type">char</span> equal_char = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; arr_curr_ind; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(ArrayConfig[i].ItemName) == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            equal_char = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            equal_char = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(line_buf, <span class="string">&quot;%s%c%s\n&quot;</span>, ArrayConfig[i].ItemName, equal_char, ArrayConfig[i].ItemContent);</span><br><span class="line">        write(new_fd, line_buf, <span class="built_in">strlen</span>(line_buf));</span><br><span class="line">        <span class="built_in">memset</span>(line_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(line_buf));</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：config_main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Func.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* config_file = <span class="string">&quot;./config.conf&quot;</span>;</span><br><span class="line"></span><br><span class="line">    LoadConfigFile(config_file);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ip = GetConfigFromString(<span class="string">&quot;server_url&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> port = GetConfigIntDefault(<span class="string">&quot;server_port&quot;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="keyword">if</span> (ip)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;url:%s\t&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;port:%d\n&quot;</span>, port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;device_id:%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;device_id&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;device_name:%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;device_name&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serv_pub_info_url=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;serv_pub_info_url&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serv_pub_curr_log=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;serv_pub_curr_log&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serv_pub_hist_log=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;serv_pub_hist_log&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;certificate=%s\n&quot;</span>, GetConfigFromString(<span class="string">&quot;certificate&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>文件名：config.conf</code></strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[服务器地址]</span>  </span><br><span class="line"><span class="attr">server_url</span>=<span class="number">192.168</span>.<span class="number">137.1</span></span><br><span class="line"><span class="attr">server_port</span>=<span class="number">80</span></span><br><span class="line"><span class="section">[信息推送地址]</span>  </span><br><span class="line"><span class="attr">serv_regi_dev_url</span>=/regist_dev</span><br><span class="line"><span class="attr">serv_pub_info_url</span>=/pub_dev_info</span><br><span class="line"><span class="attr">serv_pub_curr_log</span>=/pub_current_log</span><br><span class="line"><span class="attr">serv_pub_hist_log</span>=/pub_history_log</span><br><span class="line"><span class="section">[设备信息]</span>  </span><br><span class="line"><span class="attr">device_id</span>=<span class="number">20210830_1400_00001</span></span><br><span class="line"><span class="attr">device_name</span>=DEV_001</span><br><span class="line"><span class="section">[设备证书]</span>  </span><br><span class="line"><span class="attr">certificate</span>=CONFIG_BRKZH.GITHUB.IO_CONFIG</span><br><span class="line"><span class="section">[设备是否注册]</span>  </span><br><span class="line"><span class="attr">registry_flag</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">CT</span>=<span class="number">65534</span></span><br></pre></td></tr></table></figure><p>把以上的代码都存到 <strong>对应文件</strong> 里面，并且放到 <strong>同一个目录</strong> 下。</p><p>编译指令：<code>gcc -o my_conf config_main.c config.c Func.c -I ./</code></p><p>运行指令：<code>./my_config</code></p><p>运行结果：<br><img src="https://brkzh.github.io/docPics/C_CPlusPlus/ConfigurationFileLoadingAndModify_C/ConfigurationFileLoadingAndModify_C.png" alt="ConfigurationFileLoadingAndModify_C"><br>注意：此份代码仅供学习使用，并没有什么商业价值。<br>因为这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// item数组的大小，也是配置文件中有效的item项目的最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGSTRUCTSIZE 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGNAMESIZE 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIGCONTENTSIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ItemName[CONFIGNAMESIZE];</span><br><span class="line">    <span class="type">char</span> ItemContent[CONFIGCONTENTSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConfigStruct</span> <span class="title">ArrayConfig</span>[<span class="title">CONFIGSTRUCTSIZE</span>];</span></span><br></pre></td></tr></table></figure><p>这里设定了配置文件的最大项目数量等，一开始就创建这么多数组，用于保存配置文件，这些开销都是在栈上。没有使用malloc动态分配内存，所以代码<strong>仅供学习。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取网卡地址 -- Linux C</title>
      <link href="/2022/11/01/C_CPlusPlus/GetEthMacIpAddr_LinuxC/"/>
      <url>/2022/11/01/C_CPlusPlus/GetEthMacIpAddr_LinuxC/</url>
      
        <content type="html"><![CDATA[<h1 id="获取指定名字的网卡的Mac地址和IP地址"><a href="#获取指定名字的网卡的Mac地址和IP地址" class="headerlink" title="获取指定名字的网卡的Mac地址和IP地址"></a>获取指定名字的网卡的Mac地址和IP地址</h1><p>文件名：<code>get_mac_ip.c</code><br>运行环境：<code>Linux、Arm</code><br>编译指令：<code>gcc -o get_mac_ip get_mac_ip.c</code><br>运行程序：<code>./get_mac_ip eth0</code> 其中<code>eth0</code>是网卡的名字，不同网卡名字一般是不一样的。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：get_ip_mac.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_mac_addr</span><span class="params">(<span class="type">char</span>* mac, <span class="type">char</span>* ip, <span class="type">char</span> *_net_card)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">tmp</span>;</span></span><br><span class="line"><span class="type">int</span> sock_mac;</span><br><span class="line"><span class="type">char</span> mac_addr[<span class="number">30</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">sin</span>;</span></span><br><span class="line">sock_mac = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sock_mac == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;create socket fail\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(&amp;tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="built_in">strncpy</span>(tmp.ifr_name, _net_card, <span class="keyword">sizeof</span>(tmp.ifr_name)<span class="number">-1</span> );</span><br><span class="line"><span class="keyword">if</span>(ioctl(sock_mac, SIOCGIFHWADDR, &amp;tmp)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mac ioctl error\n&quot;</span>);</span><br><span class="line">close(sock_mac);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(mac_addr, <span class="string">&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</span>,</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">0</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">1</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">2</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">3</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">4</span>],</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">char</span>)tmp.ifr_hwaddr.sa_data[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">memcpy</span>(mac, mac_addr, <span class="built_in">strlen</span>(mac_addr));</span><br><span class="line"><span class="comment">// printf(&quot;local mac:%s\n&quot;, mac_addr);</span></span><br><span class="line"><span class="keyword">if</span>(ioctl(sock_mac, SIOCGIFADDR, &amp;tmp) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">close(sock_mac);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sin</span> = (<span class="keyword">struct</span> sockaddr_in *)&amp;(tmp.ifr_addr);</span><br><span class="line"><span class="built_in">strcpy</span>(ip, inet_ntoa(<span class="built_in">sin</span>-&gt;sin_addr));</span><br><span class="line">close(sock_mac);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> mac[<span class="number">32</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ip[<span class="number">32</span>]=<span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sorry. Please input net card name.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Such as: ./get_ip_mac eth0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    get_mac_addr(mac, ip, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mac=%s\nip=%s\n&quot;</span>, mac, ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行截图：<br><img src="https://brkzh.github.io/docPics/GetEthMacIpAddr_LinuxC/GetEthMacIpAddr_LinuxC.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>监听键盘输入 C语言</title>
      <link href="/2022/10/01/C_CPlusPlus/MonitorKeyboardInput_C/"/>
      <url>/2022/10/01/C_CPlusPlus/MonitorKeyboardInput_C/</url>
      
        <content type="html"><![CDATA[<h1 id="监听键盘的输入"><a href="#监听键盘的输入" class="headerlink" title="监听键盘的输入"></a>监听键盘的输入</h1><p>程序编译： <code>gcc -o keyboard_listen keyboard_listen.c</code></p><p>程序运行： <code>./keyboard_listen</code></p><p>说明：程序运行，当用户敲击键盘时，程序会打印初敲击的案件。其中<code>q</code>是退出程序。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名：keyboard_listen.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc=%d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ti=<span class="number">0</span>; ti &lt; argc; ti++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]=%s\n&quot;</span>, ti, argv[ti]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> keyboard;</span><br><span class="line">    <span class="type">int</span> ret, i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line">    c= <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> tm_ts = <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> tm_us = <span class="number">3333</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tm_ts = (<span class="type">long</span> <span class="type">int</span>)atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tm_ts = (<span class="type">long</span> <span class="type">int</span>)atoi(argv[<span class="number">1</span>]);</span><br><span class="line">        tm_us = (<span class="type">long</span> <span class="type">int</span>)atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    keyboard = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY|O_NONBLOCK);</span><br><span class="line">    assert(keyboard&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> w_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        timeout.tv_sec = tm_ts;</span><br><span class="line">        timeout.tv_usec = tm_us;</span><br><span class="line">        FD_ZERO(&amp;readfd);</span><br><span class="line">        </span><br><span class="line">        FD_SET(keyboard, &amp;readfd);</span><br><span class="line">        <span class="comment">// 监控函数</span></span><br><span class="line">        ret = select(keyboard+<span class="number">1</span>, &amp;readfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret)  <span class="comment">// 返回值大于0，有数据到来</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">if</span>(FD_ISSET(keyboard, &amp;readfd))</span><br><span class="line">            &#123;</span><br><span class="line">                i = read(keyboard, &amp;c, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;\n&#x27;</span> == c)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;char &#x27;q&#x27; is quit. &quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;you input is &lt;[%c]&gt;.\n&quot;</span>, c);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&#x27;q&#x27;</span> == c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 超时情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;time out...\t%ld\t%d\t%d\t%d\t%d\t%d\n&quot;</span>, time(<span class="literal">NULL</span>), rand(), rand(), rand(), rand(), rand());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏服务器与客户端</title>
      <link href="/2022/06/22/Adventure_Road/"/>
      <url>/2022/06/22/Adventure_Road/</url>
      
        <content type="html"><![CDATA[<p>卡牌游戏Demo</p><span id="more"></span><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>说明：服务器使用C++语言开发，使用到了epoll高并发通讯技术，线程池处理业务逻辑，MySQL存储用户数据，定时心跳包检测，服务器安全（畸形数据包识别并处理、恶意客户端识别并处理）等等。<br>服务器使用 “主服务器+游戏服务器”的程序架构。<br>主服务器负责一些基本的业务逻辑，如账号注册、账号登录验证1、修改密码、忘记密码功能。<br>游戏服务器负责一些游戏相关的业务，账号登录验证2、游戏逻辑等。</p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/serverRun.png" alt="服务器运行"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/mainServerSpLogicFunc.png" alt="主服务器业务逻辑相关函数"></p><p>后期如果需要扩展业务逻辑，只需要在statusHandler数组里面添加相应的函数，同时约定好对应的消息码，然后实现相应函数即可完成对业务逻辑的扩充。</p><p>游戏服务器的相关业务逻辑就不展示了。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端使用Unity-3D开发引擎，搭配C#语言，开发一个2D战棋游戏。<br>客户端（C#）和服务器（C++）的通讯，是使用自己封装的Dll库来实现的。<br>下面的图片是客户端的部分界面的截图。</p><h3 id="账号登录"><a href="#账号登录" class="headerlink" title="账号登录"></a>账号登录</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/clientLoginPage.png" alt="客户端登录界面"></p><h3 id="账号注册"><a href="#账号注册" class="headerlink" title="账号注册"></a>账号注册</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage1.png" alt="注册界面1"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage2.png" alt="注册界面2"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage3.png" alt="注册界面3"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/registerPage4.png" alt="注册界面4"><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emailVerify.jpg" alt="邮箱验证码 (2)"></p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager1.png" alt="密码管理-1"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager_forget.png" alt="密码管理-忘记密码"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/passwdManager_Modify.png" alt="密码管理-修改密码"></p><h3 id="登录后主界面"><a href="#登录后主界面" class="headerlink" title="登录后主界面"></a>登录后主界面</h3><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/loginedMainPage.png" alt="登录后的主界面"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/clientMain_SettingPage.png" alt="客户端登录界面-设置菜单"></p><h2 id=""><a href="#" class="headerlink" title="."></a>.</h2><p>游戏还不是很完善，游戏的玩法正在开发中。</p><p>敬请期待…</p><h3 id="客户端下载链接"><a href="#客户端下载链接" class="headerlink" title="客户端下载链接"></a>客户端下载链接</h3><p>客户端配置文件<code>Adventure_Road.conf</code>，在程序的根目录</p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/Adventure_Road_conf.png" alt="image-20230918225002524"></p><p>给配置文件配置主服务器的<code>ip</code>地址和端口号。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器IP地址</span></span><br><span class="line"><span class="attr">MasterServerAddr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># 服务器端口</span></span><br><span class="line"><span class="attr">MasterServerPort</span> = <span class="number">35300</span></span><br></pre></td></tr></table></figure><p>百度网盘链接：</p><p>链接：<a href="https://pan.baidu.com/s/1Fl9mRH0gFj3PmATxoGVZDA">https://pan.baidu.com/s/1Fl9mRH0gFj3PmATxoGVZDA</a><br>提取码：mxzl</p><p>115网盘链接：</p><p><a href="https://115.com/s/sw6c6sv36eu?password=mxzl&#">https://115.com/s/sw6c6sv36eu?password=mxzl&amp;#</a><br>Adventure_Road_Client.0906.R.zip<br>访问码:mxzl</p><p>夸克网盘：<br>链接：<a href="https://pan.quark.cn/s/e868fc0d4e38">https://pan.quark.cn/s/e868fc0d4e38</a><br>提取码：XmHH</p><h3 id="服务器下载链接"><a href="#服务器下载链接" class="headerlink" title="服务器下载链接"></a>服务器下载链接</h3><p>服务器，笔者制作了<code>docker</code>镜像，下载后导入镜像，创建容器后就可以使用了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">导入镜像</span><br><span class="line">docker import - mxzl_demo_image &lt; mxzlDemoImage.tar </span><br><span class="line">这样就把，mxzlDemoImage.tar导入了，镜像名字为mxzl_demo_image</span><br><span class="line"></span><br><span class="line">创建容器</span><br><span class="line">docker run --name mxzl_demo_env -itd -p 35300:35300 -p 39300:39300 mxzl_demo_image  /bin/bash</span><br><span class="line">这样就创建了容器mxzl_demo_env</span><br><span class="line"></span><br><span class="line">启动容器</span><br><span class="line">docker start mxzl_demo_env</span><br><span class="line"></span><br><span class="line">进入已启动的容器</span><br><span class="line">docker <span class="built_in">exec</span> -it mxzl_demo_env /bin/bash</span><br><span class="line"></span><br><span class="line">启动脚本，启动数据库、启动游戏服务器</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line">./startDemo.sh </span><br><span class="line"></span><br><span class="line">数据库已经有了测试账号，服务器运行起来后可以直接登录使用</span><br><span class="line">账号：brkzh</span><br><span class="line">密码：brkzh</span><br><span class="line"></span><br><span class="line">如果需要注册账号等，需要启用验证码功能，那么就需要改主服务器的配置文件：</span><br><span class="line">vim /home/mxzl/MasterServer.conf</span><br><span class="line">需要更改 [E-Mail]节点的 sendUser、sendPass等配置项</span><br></pre></td></tr></table></figure><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/vim_config.png" alt="image-20230918222156628"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emainConfig.png" alt="image-20230918222222613"></p><p><img src="https://brkzh.github.io/docPics/Adventure_Road_GameServerAndClient.assets/emainConfig2.png" alt="image-20230918222233795"></p><p>百度网盘链接：</p><p>链接：<a href="https://pan.baidu.com/s/1wLpDleYBLlprs58rPv-ZFA">https://pan.baidu.com/s/1wLpDleYBLlprs58rPv-ZFA</a><br>提取码：mxzl</p><p>夸克网盘：<br>链接：<a href="https://pan.quark.cn/s/a914ea04c026">https://pan.quark.cn/s/a914ea04c026</a><br>提取码：7GNC</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
